===== D:\Computer Science\flutter project\stock_tracker_app\.dart_tool\dartpad\web_plugin_registrant.dart ===== 
// Flutter web plugin registrant file.
//
// Generated file. Do not edit.
//

// @dart = 2.13
// ignore_for_file: type=lint

import 'package:shared_preferences_web/shared_preferences_web.dart';
import 'package:url_launcher_web/url_launcher_web.dart';
import 'package:flutter_web_plugins/flutter_web_plugins.dart';

void registerPlugins([final Registrar? pluginRegistrar]) {
  final Registrar registrar = pluginRegistrar ?? webPluginRegistrar;
  SharedPreferencesPlugin.registerWith(registrar);
  UrlLauncherPlugin.registerWith(registrar);
  registrar.registerMessageHandler();
}

===== D:\Computer Science\flutter project\stock_tracker_app\.dart_tool\flutter_build\49287208ba8376ed0baa5167af3c2c31\main.dart ===== 
// @dart=3.7
// Flutter web bootstrap script for package:stock_tracker_app/main.dart.
//
// Generated file. Do not edit.
//

// ignore_for_file: type=lint

import 'dart:ui_web' as ui_web;
import 'dart:async';

import 'package:stock_tracker_app/main.dart' as entrypoint;
import 'web_plugin_registrant.dart' as pluginRegistrant;

typedef _UnaryFunction = dynamic Function(List<String> args);
typedef _NullaryFunction = dynamic Function();

Future<void> main() async {
  await ui_web.bootstrapEngine(
    runApp: () {
      if (entrypoint.main is _UnaryFunction) {
        return (entrypoint.main as _UnaryFunction)(<String>[]);
      }
      return (entrypoint.main as _NullaryFunction)();
    },
    registerPlugins: () {
      pluginRegistrant.registerPlugins();
    },
  );
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\.dart_tool\flutter_build\49287208ba8376ed0baa5167af3c2c31\web_plugin_registrant.dart ===== 
// Flutter web plugin registrant file.
//
// Generated file. Do not edit.
//

// @dart = 2.13
// ignore_for_file: type=lint

import 'package:shared_preferences_web/shared_preferences_web.dart';
import 'package:url_launcher_web/url_launcher_web.dart';
import 'package:flutter_web_plugins/flutter_web_plugins.dart';

void registerPlugins([final Registrar? pluginRegistrar]) {
  final Registrar registrar = pluginRegistrar ?? webPluginRegistrar;
  SharedPreferencesPlugin.registerWith(registrar);
  UrlLauncherPlugin.registerWith(registrar);
  registrar.registerMessageHandler();
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\main.dart ===== 
import 'package:flutter/material.dart';
import 'package:intl/date_symbol_data_local.dart';
import 'package:stock_tracker_app/src/app.dart';
import 'package:stock_tracker_app/src/shared/bindings/initial_binding.dart';
import 'package:stock_tracker_app/src/shared/utils/cache_helper.dart';
import 'package:flutter_web_plugins/flutter_web_plugins.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  
  // ✅ Initialize locale data
  await initializeDateFormatting('vi_VN', null);
  
  // Initialize cache
  await CacheHelper.init();
  
  // Initialize dependencies
  InitialBinding().dependencies();

  usePathUrlStrategy();
  
  runApp(const MyApp());
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\app.dart ===== 
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:stock_tracker_app/src/shared/utils/app_pages.dart';
import 'package:stock_tracker_app/src/shared/utils/app_constants.dart';
import 'package:stock_tracker_app/src/shared/utils/theme_helper.dart';

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return GetMaterialApp(
      title: AppConstants.appName,
      debugShowCheckedModeBanner: false,
      theme: ThemeHelper.getLightTheme(),
      darkTheme: ThemeHelper.getDarkTheme(),
      themeMode: ThemeMode.system,
      initialRoute: AppPages.initial,
      getPages: AppPages.routes,
      locale: const Locale('vi', 'VN'),
      fallbackLocale: const Locale('en', 'US'),
    );
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\features\analytics\analytics_screen.dart ===== 
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:fl_chart/fl_chart.dart';
import 'package:stock_tracker_app/src/features/analytics/controllers/analytics_controller.dart';
import 'package:stock_tracker_app/src/shared/widgets/loading_widget.dart';
import 'package:stock_tracker_app/src/shared/widgets/error_widget.dart';
import 'package:stock_tracker_app/src/shared/utils/app_constants.dart';
import 'package:stock_tracker_app/src/shared/utils/app_routes.dart';
import 'package:stock_tracker_app/src/shared/widgets/main_navigation.dart';

class AnalyticsScreen extends StatelessWidget {
  const AnalyticsScreen({super.key});

  @override
  Widget build(BuildContext context) {
    final analyticsController = Get.put(AnalyticsController());

    return MainNavigation(
      child: Scaffold(
        appBar: AppBar(
          title: const Text('Phân tích & Thống kê'),
          actions: [
            IconButton(
              icon: const Icon(Icons.refresh),
              onPressed: () => analyticsController.refreshAnalytics(),
            ),
          ],
        ),
        body: Obx(() {
          if (analyticsController.isLoading) {
            return const LoadingWidget(message: 'Đang phân tích dữ liệu...');
          }

          if (analyticsController.errorMessage.isNotEmpty) {
            return ErrorDisplayWidget(
              message: analyticsController.errorMessage,
              onRetry: () => analyticsController.refreshAnalytics(),
            );
          }

          return RefreshIndicator(
            onRefresh: () => analyticsController.refreshAnalytics(),
            child: SingleChildScrollView(
              physics: const AlwaysScrollableScrollPhysics(),
              child: Padding(
                padding: const EdgeInsets.all(16),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Time Range Selector
                    _buildTimeRangeSelector(context, analyticsController),
                    const SizedBox(height: 24),

                    // Summary Cards
                    _buildSummaryCards(context, analyticsController),
                    const SizedBox(height: 24),

                    // Category Distribution Chart
                    _buildCategoryChart(context, analyticsController),
                    const SizedBox(height: 24),

                    // Sentiment Analysis Chart
                    _buildSentimentChart(context, analyticsController),
                    const SizedBox(height: 24),

                    // Impact Analysis Chart
                    _buildImpactChart(context, analyticsController),
                    const SizedBox(height: 24),

                    // High Impact Articles
                    _buildHighImpactSection(context, analyticsController),
                  ],
                ),
              ),
            ),
          );
        }),
      ),
    );
  }

  Widget _buildTimeRangeSelector(
    BuildContext context,
    AnalyticsController controller,
  ) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Khoảng thời gian',
              style: Theme.of(
                context,
              ).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w600),
            ),
            const SizedBox(height: 12),
            Row(
              children: [
                _buildTimeRangeChip(context, 'Tuần', 'week', controller),
                const SizedBox(width: 8),
                _buildTimeRangeChip(context, 'Tháng', 'month', controller),
                const SizedBox(width: 8),
                _buildTimeRangeChip(context, 'Quý', 'quarter', controller),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildTimeRangeChip(
    BuildContext context,
    String label,
    String value,
    AnalyticsController controller,
  ) {
    final isSelected = controller.selectedTimeRange == value;

    return FilterChip(
      selected: isSelected,
      label: Text(label),
      onSelected: (selected) {
        if (selected) {
          controller.changeTimeRange(value);
        }
      },
    );
  }

  Widget _buildSummaryCards(
    BuildContext context,
    AnalyticsController controller,
  ) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Tổng quan',
          style: Theme.of(
            context,
          ).textTheme.titleLarge?.copyWith(fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 16),
        GridView.count(
          crossAxisCount: 2,
          shrinkWrap: true,
          physics: const NeverScrollableScrollPhysics(),
          crossAxisSpacing: 16,
          mainAxisSpacing: 16,
          childAspectRatio: 1.5,
          children: [
            _buildSummaryCard(
              context,
              'Tổng bài viết',
              '${controller.totalArticlesAnalyzed}',
              Icons.article_outlined,
              Colors.blue,
            ),
            _buildSummaryCard(
              context,
              'Cảm xúc TB',
              '${(controller.averageSentiment * 100).toStringAsFixed(1)}%',
              Icons.sentiment_satisfied,
              _getSentimentColor(controller.averageSentiment),
            ),
            _buildSummaryCard(
              context,
              'Tác động TB',
              '${(controller.averageImpact * 100).toStringAsFixed(1)}%',
              Icons.trending_up,
              Colors.orange,
            ),
            _buildSummaryCard(
              context,
              'Danh mục chính',
              controller.dominantCategory,
              Icons.category,
              Colors.purple,
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildSummaryCard(
    BuildContext context,
    String title,
    String value,
    IconData icon,
    Color color,
  ) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(icon, color: color, size: 24),
                const Spacer(),
                Text(
                  value,
                  style: Theme.of(context).textTheme.headlineSmall?.copyWith(
                    color: color,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 8),
            Text(
              title,
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                color: Theme.of(context).colorScheme.onSurfaceVariant,
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildCategoryChart(
    BuildContext context,
    AnalyticsController controller,
  ) {
    if (controller.categoryDistribution.isEmpty) {
      return const SizedBox.shrink();
    }

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Phân bổ theo danh mục',
              style: Theme.of(
                context,
              ).textTheme.titleLarge?.copyWith(fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 20),
            SizedBox(
              height: 300,
              child: PieChart(
                PieChartData(
                  sections: _buildPieChartSections(
                    controller.categoryDistribution,
                  ),
                  centerSpaceRadius: 40,
                  sectionsSpace: 2,
                ),
              ),
            ),
            const SizedBox(height: 16),
            _buildLegend(controller.categoryDistribution),
          ],
        ),
      ),
    );
  }

  List<PieChartSectionData> _buildPieChartSections(Map<String, int> data) {
    final total = data.values.reduce((a, b) => a + b);
    final colors = [
      Colors.blue,
      Colors.green,
      Colors.orange,
      Colors.red,
      Colors.purple,
      Colors.teal,
      Colors.pink,
      Colors.amber,
    ];

    return data.entries.map((entry) {
      final index = data.keys.toList().indexOf(entry.key);
      final percentage = (entry.value / total * 100);

      return PieChartSectionData(
        value: entry.value.toDouble(),
        title: '${percentage.toStringAsFixed(1)}%',
        color: colors[index % colors.length],
        radius: 100,
        titleStyle: const TextStyle(
          fontSize: 12,
          fontWeight: FontWeight.bold,
          color: Colors.white,
        ),
      );
    }).toList();
  }

  Widget _buildLegend(Map<String, int> data) {
    final colors = [
      Colors.blue,
      Colors.green,
      Colors.orange,
      Colors.red,
      Colors.purple,
      Colors.teal,
      Colors.pink,
      Colors.amber,
    ];

    return Wrap(
      spacing: 16,
      runSpacing: 8,
      children:
          data.entries.map((entry) {
            final index = data.keys.toList().indexOf(entry.key);
            return Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Container(
                  width: 16,
                  height: 16,
                  decoration: BoxDecoration(
                    color: colors[index % colors.length],
                    shape: BoxShape.circle,
                  ),
                ),
                const SizedBox(width: 8),
                Text(
                  '${entry.key} (${entry.value})',
                  style: const TextStyle(fontSize: 12),
                ),
              ],
            );
          }).toList(),
    );
  }

  Widget _buildSentimentChart(
    BuildContext context,
    AnalyticsController controller,
  ) {
    if (controller.sentimentTrends.isEmpty) {
      return const SizedBox.shrink();
    }

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Phân tích cảm xúc',
              style: Theme.of(
                context,
              ).textTheme.titleLarge?.copyWith(fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 20),
            SizedBox(
              height: 250, // ✅ SỬA: Tăng height cho chart
              child: BarChart(
                BarChartData(
                  barGroups: _buildSentimentBarGroups(
                    controller.sentimentTrends,
                  ),
                  // ✅ SỬA: Improved spacing và formatting
                  titlesData: FlTitlesData(
                    // Left titles (Y-axis) với more space
                    leftTitles: AxisTitles(
                      sideTitles: SideTitles(
                        showTitles: true,
                        reservedSize: 60, // ✅ SỬA: Tăng từ default ~40 lên 60
                        interval: 0.2, // ✅ SỬA: Show labels mỗi 0.2 units
                        getTitlesWidget: (value, meta) {
                          return Padding(
                            padding: const EdgeInsets.only(
                              right: 8,
                            ), // ✅ SỬA: Thêm padding
                            child: Text(
                              value.toStringAsFixed(
                                1,
                              ), // ✅ SỬA: Format with 1 decimal
                              style: Theme.of(
                                context,
                              ).textTheme.bodySmall?.copyWith(
                                fontSize: 11,
                                color:
                                    Theme.of(
                                      context,
                                    ).colorScheme.onSurfaceVariant,
                              ),
                            ),
                          );
                        },
                      ),
                    ),
                    // Bottom titles (X-axis) với better formatting
                    bottomTitles: AxisTitles(
                      sideTitles: SideTitles(
                        showTitles: true,
                        reservedSize: 40, // ✅ SỬA: Space cho bottom labels
                        getTitlesWidget: (value, meta) {
                          final labels = controller.sentimentLabels;
                          if (value.toInt() < labels.length) {
                            return Padding(
                              padding: const EdgeInsets.only(
                                top: 8,
                              ), // ✅ SỬA: Thêm padding
                              child: Text(
                                labels[value.toInt()],
                                style: Theme.of(
                                  context,
                                ).textTheme.bodySmall?.copyWith(
                                  fontSize: 12,
                                  fontWeight: FontWeight.w500,
                                  color:
                                      Theme.of(context).colorScheme.onSurface,
                                ),
                              ),
                            );
                          }
                          return const Text('');
                        },
                      ),
                    ),
                    rightTitles: AxisTitles(
                      sideTitles: SideTitles(showTitles: false),
                    ),
                    topTitles: AxisTitles(
                      sideTitles: SideTitles(showTitles: false),
                    ),
                  ),
                  // ✅ SỬA: Improved border và grid
                  borderData: FlBorderData(
                    show: true,
                    border: Border(
                      left: BorderSide(
                        color: Theme.of(
                          context,
                        ).colorScheme.outline.withOpacity(0.3),
                        width: 1,
                      ),
                      bottom: BorderSide(
                        color: Theme.of(
                          context,
                        ).colorScheme.outline.withOpacity(0.3),
                        width: 1,
                      ),
                    ),
                  ),
                  // ✅ SỬA: Show grid để dễ đọc
                  gridData: FlGridData(
                    show: true,
                    horizontalInterval: 0.2,
                    drawVerticalLine: false,
                    drawHorizontalLine: true,
                    getDrawingHorizontalLine: (value) {
                      return FlLine(
                        color: Theme.of(
                          context,
                        ).colorScheme.outline.withOpacity(0.1),
                        strokeWidth: 1,
                      );
                    },
                  ),
                  // ✅ SỬA: Set min/max để có better spacing
                  minY: 0,
                  maxY: _calculateMaxY(controller.sentimentTrends),
                  // ✅ SỬA: Thêm margin cho bars
                  barTouchData: BarTouchData(
                    enabled: true,
                    touchTooltipData: BarTouchTooltipData(
                      tooltipPadding: const EdgeInsets.all(8),
                      tooltipMargin: 8,
                      getTooltipItem: (group, groupIndex, rod, rodIndex) {
                        final labels = controller.sentimentLabels;
                        final value = rod.toY;
                        return BarTooltipItem(
                          '${labels[groupIndex]}\n${value.toStringAsFixed(2)}',
                          TextStyle(
                            color:
                                Theme.of(context).colorScheme.onSurfaceVariant,
                            fontWeight: FontWeight.w500,
                          ),
                        );
                      },
                    ),
                  ),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  // ✅ THÊM: Helper method để calculate max Y value
  double _calculateMaxY(Map<String, double> data) {
    if (data.isEmpty) return 1.0;

    final maxValue = data.values.reduce((a, b) => a > b ? a : b);
    // Thêm 20% padding ở top và round up
    return ((maxValue * 1.2) * 10).ceil() / 10.0;
  }

  List<BarChartGroupData> _buildSentimentBarGroups(Map<String, double> data) {
    final colors = [Colors.green, Colors.grey, Colors.red];

    return data.entries.map((entry) {
      final index = data.keys.toList().indexOf(entry.key);
      return BarChartGroupData(
        x: index,
        barRods: [
          BarChartRodData(
            toY: entry.value,
            color: colors[index % colors.length],
            width: 30,
            borderRadius: const BorderRadius.vertical(top: Radius.circular(4)),
          ),
        ],
      );
    }).toList();
  }

  Widget _buildImpactChart(
    BuildContext context,
    AnalyticsController controller,
  ) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Phân tích tác động',
              style: Theme.of(
                context,
              ).textTheme.titleLarge?.copyWith(fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 20),
            ...controller.impactAnalysis.entries.map((entry) {
              final total = controller.impactAnalysis.values.reduce(
                (a, b) => a + b,
              );
              final percentage = total > 0 ? (entry.value / total) : 0.0;

              return Padding(
                padding: const EdgeInsets.symmetric(vertical: 8),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        Text(
                          'Tác động ${entry.key}',
                          style: Theme.of(context).textTheme.bodyMedium,
                        ),
                        Text(
                          '${entry.value} (${(percentage * 100).toStringAsFixed(1)}%)',
                          style: Theme.of(context).textTheme.bodyMedium
                              ?.copyWith(fontWeight: FontWeight.w600),
                        ),
                      ],
                    ),
                    const SizedBox(height: 4),
                    LinearProgressIndicator(
                      value: percentage,
                      backgroundColor: Colors.grey.withOpacity(0.3),
                      valueColor: AlwaysStoppedAnimation<Color>(
                        _getImpactColor(entry.key),
                      ),
                    ),
                  ],
                ),
              );
            }).toList(),
          ],
        ),
      ),
    );
  }

  Widget _buildHighImpactSection(
    BuildContext context,
    AnalyticsController controller,
  ) {
    if (controller.highImpactArticles.isEmpty) {
      return const SizedBox.shrink();
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text(
              'Tin tức tác động cao',
              style: Theme.of(
                context,
              ).textTheme.titleLarge?.copyWith(fontWeight: FontWeight.bold),
            ),
            TextButton(
              onPressed: () => Get.toNamed(AppRoutes.articles),
              child: const Text('Xem tất cả'),
            ),
          ],
        ),
        const SizedBox(height: 16),
        ListView.builder(
          shrinkWrap: true,
          physics: const NeverScrollableScrollPhysics(),
          itemCount: controller.highImpactArticles.take(5).length,
          itemBuilder: (context, index) {
            final article = controller.highImpactArticles[index];
            return _buildHighImpactArticleCard(context, article);
          },
        ),
      ],
    );
  }

  Widget _buildHighImpactArticleCard(BuildContext context, article) {
    final categoryColor =
        AppConstants.categoryColors[article.aiAnalysis?.category] ??
        AppConstants.categoryColors['Không liên quan']!;

    return Card(
      margin: const EdgeInsets.only(bottom: 8),
      child: ListTile(
        leading: Container(
          width: 4,
          height: double.infinity,
          decoration: BoxDecoration(
            color: Color(categoryColor),
            borderRadius: BorderRadius.circular(2),
          ),
        ),
        title: Text(
          article.title,
          style: Theme.of(
            context,
          ).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w600),
          maxLines: 2,
          overflow: TextOverflow.ellipsis,
        ),
        subtitle: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const SizedBox(height: 4),
            Row(
              children: [
                if (article.aiAnalysis?.category != null)
                  Container(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 8,
                      vertical: 4,
                    ),
                    decoration: BoxDecoration(
                      color: Color(categoryColor).withOpacity(0.1),
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Text(
                      article.aiAnalysis!.category!,
                      style: TextStyle(
                        fontSize: 11,
                        color: Color(categoryColor),
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ),
                const SizedBox(width: 8),
                if (article.aiAnalysis?.impactScore != null)
                  Container(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 8,
                      vertical: 4,
                    ),
                    decoration: BoxDecoration(
                      color: Colors.red.withOpacity(0.1),
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Text(
                      'Tác động cao',
                      style: TextStyle(
                        fontSize: 11,
                        color: Colors.red,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ),
              ],
            ),
            const SizedBox(height: 4),
            Text(
              article.timeAgo,
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                color: Theme.of(context).colorScheme.onSurfaceVariant,
              ),
            ),
          ],
        ),
        onTap:
            () => Get.toNamed(
              AppRoutes.articleDetail.replaceAll(':id', article.id.toString()),
            ),
      ),
    );
  }

  Color _getSentimentColor(double sentiment) {
    if (sentiment > 0.1) return Colors.green;
    if (sentiment < -0.1) return Colors.red;
    return Colors.grey;
  }

  Color _getImpactColor(String impact) {
    switch (impact) {
      case 'Cao':
        return Colors.red;
      case 'Trung bình':
        return Colors.orange;
      case 'Thấp':
        return Colors.green;
      default:
        return Colors.grey;
    }
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\features\analytics\bindings\analytics_binding.dart ===== 
import 'package:get/get.dart';
import 'package:stock_tracker_app/src/features/analytics/controllers/analytics_controller.dart';

class AnalyticsBinding implements Bindings {
  @override
  void dependencies() {
    Get.lazyPut(() => AnalyticsController());
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\features\analytics\controllers\analytics_controller.dart ===== 
import 'package:get/get.dart';
import 'package:stock_tracker_app/src/shared/models/article_with_analysis_model.dart';
import 'package:stock_tracker_app/src/shared/repositories/articles_repository.dart';
import 'package:stock_tracker_app/src/shared/utils/app_constants.dart';

class AnalyticsController extends GetxController {
  final ArticlesRepository _repository = Get.find<ArticlesRepository>();

  final _isLoading = false.obs;
  final _errorMessage = ''.obs;
  final _selectedTimeRange = 'week'.obs;

  // ✅ SỬA: Sử dụng ArticleWithAnalysis
  final _categoryDistribution = <String, int>{}.obs;
  final _sentimentTrends = <String, double>{}.obs;
  final _impactAnalysis = <String, int>{}.obs;
  final _highImpactArticles = <ArticleWithAnalysis>[].obs;
  final _allArticles = <ArticleWithAnalysis>[].obs;

  // Getters
  bool get isLoading => _isLoading.value;
  String get errorMessage => _errorMessage.value;
  String get selectedTimeRange => _selectedTimeRange.value;
  Map<String, int> get categoryDistribution => _categoryDistribution.value;
  Map<String, double> get sentimentTrends => _sentimentTrends.value;
  Map<String, int> get impactAnalysis => _impactAnalysis.value;
  List<ArticleWithAnalysis> get highImpactArticles => _highImpactArticles.value;

  @override
  void onInit() {
    super.onInit();
    loadAnalyticsData();
  }

  Future<void> loadAnalyticsData() async {
    try {
      _isLoading.value = true;
      _errorMessage.value = '';

      await Future.wait([
        _loadAllArticles(),
        _loadHighImpactArticles(),
      ]);

      _calculateAnalytics();
    } catch (e) {
      _errorMessage.value = 'Failed to load analytics: $e';
    } finally {
      _isLoading.value = false;
    }
  }

  Future<void> _loadAllArticles() async {
    // ✅ SỬA: Fetch articles with analysis
    final articles = await _repository.getArticlesWithAnalysis(skip: 0, limit: 100);
    _allArticles.value = articles;
  }

  Future<void> _loadHighImpactArticles() async {
    // ✅ SỬA: Return type đúng
    final highImpact = await _repository.getHighImpactArticles(minImpact: 0.7);
    _highImpactArticles.value = highImpact;
  }

  void _calculateAnalytics() {
    _calculateCategoryDistribution();
    _calculateSentimentTrends();
    _calculateImpactAnalysis();
  }

  void _calculateCategoryDistribution() {
    final distribution = <String, int>{};
    
    for (final articleWithAnalysis in _allArticles) {
      // ✅ SỬA: Access AI analysis từ ArticleWithAnalysis
      final category = articleWithAnalysis.aiAnalysis?.category ?? 'Không rõ';
      distribution[category] = (distribution[category] ?? 0) + 1;
    }
    
    _categoryDistribution.value = distribution;
  }

  void _calculateSentimentTrends() {
    final sentimentData = <String, List<double>>{
      'Tích cực': [],
      'Trung tính': [],
      'Tiêu cực': [],
    };

    for (final articleWithAnalysis in _allArticles) {
      // ✅ SỬA: Access sentiment từ AI analysis
      final sentiment = articleWithAnalysis.aiAnalysis?.sentimentScore;
      if (sentiment != null) {
        if (sentiment > 0.1) {
          sentimentData['Tích cực']!.add(sentiment);
        } else if (sentiment < -0.1) {
          sentimentData['Tiêu cực']!.add(sentiment.abs());
        } else {
          sentimentData['Trung tính']!.add(0.5);
        }
      }
    }

    final trends = <String, double>{};
    sentimentData.forEach((key, values) {
      if (values.isNotEmpty) {
        trends[key] = values.reduce((a, b) => a + b) / values.length;
      } else {
        trends[key] = 0.0;
      }
    });

    _sentimentTrends.value = trends;
  }

  void _calculateImpactAnalysis() {
    final impactData = <String, int>{
      'Cao': 0,
      'Trung bình': 0,
      'Thấp': 0,
    };

    for (final articleWithAnalysis in _allArticles) {
      // ✅ SỬA: Access impact từ AI analysis
      final impact = articleWithAnalysis.aiAnalysis?.impactScore;
      if (impact != null) {
        if (impact >= 0.7) {
          impactData['Cao'] = impactData['Cao']! + 1;
        } else if (impact >= 0.4) {
          impactData['Trung bình'] = impactData['Trung bình']! + 1;
        } else {
          impactData['Thấp'] = impactData['Thấp']! + 1;
        }
      }
    }

    _impactAnalysis.value = impactData;
  }

  void changeTimeRange(String timeRange) {
    _selectedTimeRange.value = timeRange;
    _calculateAnalytics();
  }

  Future<void> refreshAnalytics() async {
    await loadAnalyticsData();
  }

  // Getters cho chart data
  List<double> get categoryChartData {
    return _categoryDistribution.values.map((e) => e.toDouble()).toList();
  }

  List<String> get categoryLabels {
    return _categoryDistribution.keys.toList();
  }

  List<double> get sentimentChartData {
    return _sentimentTrends.values.toList();
  }

  List<String> get sentimentLabels {
    return _sentimentTrends.keys.toList();
  }

  // Summary statistics
  int get totalArticlesAnalyzed => _allArticles.length;
  
  double get averageSentiment {
    final articlesWithSentiment = _allArticles
        .where((a) => a.aiAnalysis?.sentimentScore != null)
        .toList();
    
    if (articlesWithSentiment.isEmpty) return 0.0;
    
    final total = articlesWithSentiment
        .map((a) => a.aiAnalysis!.sentimentScore!)
        .reduce((a, b) => a + b);
    
    return total / articlesWithSentiment.length;
  }

  double get averageImpact {
    final articlesWithImpact = _allArticles
        .where((a) => a.aiAnalysis?.impactScore != null)
        .toList();
    
    if (articlesWithImpact.isEmpty) return 0.0;
    
    final total = articlesWithImpact
        .map((a) => a.aiAnalysis!.impactScore!)
        .reduce((a, b) => a + b);
    
    return total / articlesWithImpact.length;
  }

  String get dominantCategory {
    if (_categoryDistribution.isEmpty) return 'N/A';
    
    return _categoryDistribution.entries
        .reduce((a, b) => a.value > b.value ? a : b)
        .key;
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\features\articles\articles_list_screen.dart ===== 
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:stock_tracker_app/src/features/articles/controllers/articles_controller.dart';
import 'package:stock_tracker_app/src/shared/models/article_with_analysis_model.dart';
import 'package:stock_tracker_app/src/shared/widgets/loading_widget.dart';
import 'package:stock_tracker_app/src/shared/widgets/error_widget.dart';
import 'package:stock_tracker_app/src/shared/widgets/empty_widget.dart';
import 'package:stock_tracker_app/src/shared/utils/app_constants.dart';
import 'package:stock_tracker_app/src/shared/utils/app_routes.dart';
import 'package:stock_tracker_app/src/shared/widgets/main_navigation.dart';

class ArticlesListScreen extends StatelessWidget {
  const ArticlesListScreen({super.key});

  @override
  Widget build(BuildContext context) {
    final articlesController = Get.find<ArticlesController>();
    final searchController = TextEditingController();

    return MainNavigation(
      child: Scaffold(
        appBar: AppBar(
          title: const Text('Tin tức'),
          actions: [
            IconButton(
              icon: const Icon(Icons.refresh),
              onPressed: () => articlesController.refreshArticles(),
            ),
          ],
        ),
        body: Column(
          children: [
            // Search and Filter Section
            Padding(
              padding: const EdgeInsets.all(16),
              child: Column(
                children: [
                  // Search Bar
                  TextField(
                    controller: searchController,
                    decoration: InputDecoration(
                      hintText: 'Tìm kiếm tin tức...',
                      prefixIcon: const Icon(Icons.search),
                      suffixIcon: IconButton(
                        icon: const Icon(Icons.clear),
                        onPressed: () {
                          searchController.clear();
                          articlesController.clearFilters();
                        },
                      ),
                      border: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(12),
                      ),
                    ),
                    onSubmitted: (value) {
                      // Implement search logic nếu backend có search API
                      articlesController.filterBySearch(value);
                    },
                  ),
                  const SizedBox(height: 12),
                  
                  // Filter Row
                  SingleChildScrollView(
                    scrollDirection: Axis.horizontal,
                    child: Obx(() => Row(
                      children: [
                        // High Impact Filter
                        FilterChip(
                          selected: articlesController.showHighImpactOnly,
                          label: const Text('Tác động cao'),
                          onSelected: (selected) {
                            articlesController.toggleHighImpactFilter();
                          },
                          avatar: const Icon(Icons.priority_high, size: 16),
                        ),
                        const SizedBox(width: 8),
                        
                        // Category Filters
                        // ...articlesController.availableCategories.map((category) {
                        //   final isSelected = articlesController.selectedCategory == category;
                        //   final categoryColor = AppConstants.categoryColors[category] ?? 
                        //                        AppConstants.categoryColors['Không liên quan']!;
                          
                        //   return Padding(
                        //     padding: const EdgeInsets.only(right: 8),
                        //     child: FilterChip(
                        //       selected: isSelected,
                        //       label: Text(category),
                        //       onSelected: (selected) {
                        //         articlesController.filterByCategory(
                        //           selected ? category : null
                        //         );
                        //       },
                        //       backgroundColor: Color(categoryColor).withOpacity(0.1),
                        //       selectedColor: Color(categoryColor).withOpacity(0.2),
                        //     ),
                        //   );
                        // }).toList(),
                        
                        // Clear Filter
                        if (articlesController.selectedCategory != null || 
                            articlesController.showHighImpactOnly)
                          Padding(
                            padding: const EdgeInsets.only(left: 8),
                            child: ActionChip(
                              label: const Text('Xóa bộ lọc'),
                              onPressed: () => articlesController.clearFilters(),
                              avatar: const Icon(Icons.clear, size: 16),
                            ),
                          ),
                      ],
                    )),
                  ),
                ],
              ),
            ),
            
            // Articles List
            Expanded(
              child: Obx(() {
                if (articlesController.isLoading && articlesController.articles.isEmpty) {
                  return const LoadingWidget(message: 'Đang tải tin tức...');
                }
      
                if (articlesController.errorMessage.isNotEmpty && 
                    articlesController.articles.isEmpty) {
                  return ErrorDisplayWidget(
                    message: articlesController.errorMessage,
                    onRetry: () => articlesController.refreshArticles(),
                  );
                }
      
                if (articlesController.articles.isEmpty) {
                  return EmptyWidget(
                    title: 'Không tìm thấy tin tức',
                    subtitle: 'Thử điều chỉnh bộ lọc hoặc quay lại sau',
                    icon: Icons.error,
                    onAction: () => articlesController.clearFilters(),
                    actionText: 'Xóa bộ lọc',
                    iconForButton: Icons.search_off,
                  );
                }
      
                return RefreshIndicator(
                  onRefresh: () => articlesController.refreshArticles(),
                  child: ListView.builder(
                    padding: const EdgeInsets.symmetric(horizontal: 16),
                    itemCount: articlesController.articles.length + 
                        (articlesController.hasMore ? 1 : 0),
                    itemBuilder: (context, index) {
                      // Load more indicator
                      if (index == articlesController.articles.length) {
                        if (articlesController.isLoading) {
                          return const Padding(
                            padding: EdgeInsets.all(16),
                            child: Center(child: CircularProgressIndicator()),
                          );
                        } else {
                          return Padding(
                            padding: const EdgeInsets.all(16),
                            child: ElevatedButton(
                              onPressed: () => articlesController.loadMoreArticles(),
                              child: const Text('Tải thêm'),
                            ),
                          );
                        }
                      }
      
                      final article = articlesController.articles[index];
                      return _buildArticleItem(context, article);
                    },
                  ),
                );
              }),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildArticleItem(BuildContext context, ArticleWithAnalysis articleWithAnalysis) {
  final article = articleWithAnalysis.article;
  final aiAnalysis = articleWithAnalysis.aiAnalysis;
  
  // Có thể null-safe access AI analysis
  final categoryColor = aiAnalysis?.category != null 
      ? AppConstants.categoryColors[aiAnalysis!.category!] ?? AppConstants.categoryColors['Không liên quan']!
      : AppConstants.categoryColors['Không liên quan']!;
  
  return Card(
    child: ListTile(
      title: Text(article.title),
      subtitle: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          if (article.summary != null) ...[
            Text(article.summary!),
            const SizedBox(height: 8),
          ],
          
          // AI Analysis indicators (có thể null)
          if (aiAnalysis != null) ...[
            Row(
              children: [
                if (aiAnalysis.category != null)
                  Container(
                    padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                    decoration: BoxDecoration(
                      color: Color(categoryColor).withOpacity(0.1),
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Text(
                      aiAnalysis.category!,
                      style: TextStyle(
                        fontSize: 11,
                        color: Color(categoryColor),
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ),
                const SizedBox(width: 8),
                if (aiAnalysis.sentimentScore != null)
                  _buildSentimentChip(context, aiAnalysis.sentimentScore!),
              ],
            ),
          ] else ...[
            // Hiển thị khi chưa có AI analysis
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
              decoration: BoxDecoration(
                color: Colors.grey.withOpacity(0.1),
                borderRadius: BorderRadius.circular(12),
              ),
              child: const Text(
                'Đang phân tích...',
                style: TextStyle(
                  fontSize: 11,
                  color: Colors.grey,
                ),
              ),
            ),
          ],
        ],
      ),
      onTap: () => Get.toNamed(
          AppRoutes.articleDetail.replaceAll(':id', article.id.toString()),
        ),
    ),
  );
}

  Widget _buildSentimentChip(BuildContext context, double sentiment) {
    Color color;
    String text;
    IconData icon;
    
    if (sentiment > 0.1) {
      color = Colors.green;
      text = 'Tích cực';
      icon = Icons.trending_up;
    } else if (sentiment < -0.1) {
      color = Colors.red;
      text = 'Tiêu cực';
      icon = Icons.trending_down;
    } else {
      color = Colors.grey;
      text = 'Trung tính';
      icon = Icons.trending_flat;
    }

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: color.withOpacity(0.1),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon, size: 12, color: color),
          const SizedBox(width: 4),
          Text(
            text,
            style: TextStyle(
              fontSize: 11,
              color: color,
              fontWeight: FontWeight.w500,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildImpactChip(BuildContext context, double impact) {
    Color color;
    String text;
    
    if (impact >= 0.7) {
      color = Colors.red;
      text = 'Cao';
    } else if (impact >= 0.4) {
      color = Colors.orange;
      text = 'TB';
    } else {
      color = Colors.green;
      text = 'Thấp';
    }

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: color.withOpacity(0.1),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Text(
        'Tác động: $text',
        style: TextStyle(
          fontSize: 11,
          color: color,
          fontWeight: FontWeight.w500,
        ),
      ),
    );
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\features\articles\article_detail_screen.dart ===== 
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:stock_tracker_app/src/features/articles/controllers/article_detail_controller.dart';
import 'package:stock_tracker_app/src/shared/widgets/loading_widget.dart';
import 'package:stock_tracker_app/src/shared/widgets/error_widget.dart';
import 'package:stock_tracker_app/src/shared/utils/app_constants.dart';
import 'package:stock_tracker_app/src/shared/widgets/main_navigation.dart';
import 'package:url_launcher/url_launcher.dart';

class ArticleDetailScreen extends StatelessWidget {
  const ArticleDetailScreen({super.key});

  @override
  Widget build(BuildContext context) {
    final controller = Get.find<ArticleDetailController>();

    return MainNavigation(
      child: Scaffold(
        appBar: AppBar(
          title: const Text('Chi tiết tin tức'),
          actions: [
            Obx(() {
              // ✅ SỬA: Access từ articleWithAnalysis
              final article = controller.article;
              if (article?.url != null) {
                return IconButton(
                  icon: const Icon(Icons.open_in_new),
                  onPressed: () => _launchUrl(article!.url),
                );
              }
              return const SizedBox.shrink();
            }),
            IconButton(
              icon: const Icon(Icons.share),
              onPressed: () {
                final article = controller.article;
                if (article != null) {
                  Get.snackbar(
                    'Chia sẻ',
                    'Tính năng chia sẻ sẽ sớm có',
                    snackPosition: SnackPosition.BOTTOM,
                  );
                }
              },
            ),
          ],
        ),
        body: Obx(() {
          if (controller.isLoading) {
            return const LoadingWidget(message: 'Đang tải bài viết...');
          }
      
          if (controller.errorMessage.isNotEmpty) {
            return ErrorDisplayWidget(
              message: controller.errorMessage,
              onRetry: () {
                final articleId = Get.parameters['id'];
                if (articleId != null) {
                  controller.loadArticle(int.parse(articleId));
                }
              },
            );
          }
      
          // ✅ SỬA: Lấy articleWithAnalysis thay vì article
          final articleWithAnalysis = controller.articleWithAnalysis;
          if (articleWithAnalysis == null) {
            return const Center(child: Text('Không tìm thấy bài viết'));
          }

          final article = articleWithAnalysis.article;
          final aiAnalysis = articleWithAnalysis.aiAnalysis;
      
          return SingleChildScrollView(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Hero section with title
                Container(
                  width: double.infinity,
                  padding: const EdgeInsets.all(24),
                  decoration: BoxDecoration(
                    gradient: LinearGradient(
                      colors: [
                        Theme.of(context).colorScheme.primary.withOpacity(0.1),
                        Theme.of(context).colorScheme.surface,
                      ],
                      begin: Alignment.topCenter,
                      end: Alignment.bottomCenter,
                    ),
                  ),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      // Category chip
                      // ✅ SỬA: Access từ aiAnalysis
                      if (aiAnalysis?.category != null)
                        _buildCategoryChip(context, aiAnalysis!.category!),
                      const SizedBox(height: 16),
                      
                      // Title
                      Text(
                        article.title,
                        style: Theme.of(context).textTheme.headlineSmall?.copyWith(
                          fontWeight: FontWeight.bold,
                          height: 1.3,
                        ),
                      ),
                      const SizedBox(height: 16),
      
                      // Meta info
                      _buildMetaInfo(context, article),
                    ],
                  ),
                ),
      
                Padding(
                  padding: const EdgeInsets.all(24),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      // AI Analysis Section
                      // ✅ SỬA: Kiểm tra aiAnalysis riêng biệt
                      if (aiAnalysis != null) ...[
                        _buildAIAnalysisSection(context, aiAnalysis),
                        const SizedBox(height: 32),
                      ],
      
                      // Summary
                      if (article.summary != null) ...[
                        _buildSectionHeader(context, 'Tóm tắt', Icons.summarize),
                        const SizedBox(height: 12),
                        Container(
                          width: double.infinity,
                          padding: const EdgeInsets.all(20),
                          decoration: BoxDecoration(
                            color: Theme.of(context).colorScheme.surfaceVariant.withOpacity(0.3),
                            borderRadius: BorderRadius.circular(16),
                            border: Border.all(
                              color: Theme.of(context).colorScheme.outline.withOpacity(0.2),
                            ),
                          ),
                          child: Text(
                            article.summary!,
                            style: Theme.of(context).textTheme.bodyLarge?.copyWith(
                              height: 1.6,
                            ),
                          ),
                        ),
                        const SizedBox(height: 32),
                      ],
      
                      // Source section
                      _buildSourceSection(context, article),
                    ],
                  ),
                ),
              ],
            ),
          );
        }),
      ),
    );
  }

  Widget _buildCategoryChip(BuildContext context, String category) {
    final categoryColor = AppConstants.categoryColors[category] ?? 
                         AppConstants.categoryColors['Không liên quan']!;
    
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      decoration: BoxDecoration(
        color: Color(categoryColor).withOpacity(0.1),
        borderRadius: BorderRadius.circular(20),
        border: Border.all(
          color: Color(categoryColor).withOpacity(0.3),
        ),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Container(
            width: 8,
            height: 8,
            decoration: BoxDecoration(
              color: Color(categoryColor),
              shape: BoxShape.circle,
            ),
          ),
          const SizedBox(width: 8),
          Text(
            category,
            style: Theme.of(context).textTheme.labelMedium?.copyWith(
              color: Color(categoryColor),
              fontWeight: FontWeight.w600,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildMetaInfo(BuildContext context, article) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surface,
        borderRadius: BorderRadius.circular(12),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 8,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Column(
        children: [
          Row(
            children: [
              Icon(
                Icons.schedule,
                size: 16,
                color: Theme.of(context).colorScheme.onSurfaceVariant,
              ),
              const SizedBox(width: 8),
              Text(
                // ✅ SỬA: Sử dụng timeAgo thay vì formattedDate
                'Thời gian: ${article.timeAgo}',
                style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                  color: Theme.of(context).colorScheme.onSurfaceVariant,
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          Row(
            children: [
              Icon(
                Icons.source,
                size: 16,
                color: Theme.of(context).colorScheme.onSurfaceVariant,
              ),
              const SizedBox(width: 8),
              Expanded(
                child: Text(
                  'Nguồn: ${article.sourceUrl}',
                  style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                    color: Theme.of(context).colorScheme.onSurfaceVariant,
                  ),
                  overflow: TextOverflow.ellipsis,
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildSectionHeader(BuildContext context, String title, IconData icon) {
    return Row(
      children: [
        Icon(
          icon,
          size: 24,
          color: Theme.of(context).colorScheme.primary,
        ),
        const SizedBox(width: 12),
        Text(
          title,
          style: Theme.of(context).textTheme.titleLarge?.copyWith(
            fontWeight: FontWeight.bold,
          ),
        ),
      ],
    );
  }

  Widget _buildAIAnalysisSection(BuildContext context, aiAnalysis) {
    return Card(
      elevation: 4,
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Container(
                  padding: const EdgeInsets.all(8),
                  decoration: BoxDecoration(
                    color: Theme.of(context).colorScheme.primary.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: Icon(
                    Icons.psychology,
                    color: Theme.of(context).colorScheme.primary,
                    size: 24,
                  ),
                ),
                const SizedBox(width: 12),
                Text(
                  'Phân tích AI',
                  style: Theme.of(context).textTheme.titleLarge?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 20),
            
            // Sentiment and Impact
            Row(
              children: [
                if (aiAnalysis.sentimentScore != null) ...[
                  Expanded(
                    child: _buildAnalysisMetric(
                      context,
                      'Cảm xúc',
                      aiAnalysis.sentimentText,
                      _getSentimentIcon(aiAnalysis.sentimentScore!),
                      _getSentimentColor(aiAnalysis.sentimentScore!),
                    ),
                  ),
                  const SizedBox(width: 16),
                ],
                if (aiAnalysis.impactScore != null)
                  Expanded(
                    child: _buildAnalysisMetric(
                      context,
                      'Tác động',
                      aiAnalysis.impactText,
                      Icons.trending_up,
                      _getImpactColor(aiAnalysis.impactScore!),
                    ),
                  ),
              ],
            ),
            
            if (aiAnalysis.summary != null) ...[
              const SizedBox(height: 20),
              Text(
                'Tóm tắt AI',
                style: Theme.of(context).textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.w600,
                ),
              ),
              const SizedBox(height: 8),
              Container(
                width: double.infinity,
                padding: const EdgeInsets.all(16),
                decoration: BoxDecoration(
                  color: Theme.of(context).colorScheme.primaryContainer.withOpacity(0.3),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Text(
                  aiAnalysis.summary!,
                  style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                    fontStyle: FontStyle.italic,
                  ),
                ),
              ),
            ],
            
            if (aiAnalysis.keywordsExtracted != null && 
                aiAnalysis.keywordsExtracted!.isNotEmpty) ...[
              const SizedBox(height: 20),
              Text(
                'Từ khóa chính',
                style: Theme.of(context).textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.w600,
                ),
              ),
              const SizedBox(height: 12),
              Wrap(
                spacing: 8,
                runSpacing: 8,
                children: aiAnalysis.keywordsExtracted!.map<Widget>((keyword) {
                  return Container(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 12,
                      vertical: 6,
                    ),
                    decoration: BoxDecoration(
                      color: Theme.of(context).colorScheme.secondaryContainer,
                      borderRadius: BorderRadius.circular(16),
                    ),
                    child: Text(
                      keyword,
                      style: Theme.of(context).textTheme.bodySmall?.copyWith(
                        color: Theme.of(context).colorScheme.onSecondaryContainer,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  );
                }).toList(),
              ),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildAnalysisMetric(
    BuildContext context,
    String label,
    String value,
    IconData icon,
    Color color,
  ) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: color.withOpacity(0.1),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: color.withOpacity(0.3),
        ),
      ),
      child: Column(
        children: [
          Icon(icon, color: color, size: 24),
          const SizedBox(height: 8),
          Text(
            value,
            style: Theme.of(context).textTheme.titleMedium?.copyWith(
              color: color,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 4),
          Text(
            label,
            style: Theme.of(context).textTheme.bodySmall?.copyWith(
              color: Theme.of(context).colorScheme.onSurfaceVariant,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildSourceSection(BuildContext context, article) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _buildSectionHeader(context, 'Nguồn bài viết', Icons.link),
            const SizedBox(height: 16),
            Text(
              'Đọc bài viết gốc tại:',
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                color: Theme.of(context).colorScheme.onSurfaceVariant,
              ),
            ),
            const SizedBox(height: 8),
            Text(
              article.sourceUrl,
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                color: Theme.of(context).colorScheme.primary,
                decoration: TextDecoration.underline,
              ),
            ),
            const SizedBox(height: 20),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton.icon(
                onPressed: () => _launchUrl(article.url),
                icon: const Icon(Icons.open_in_new),
                label: const Text('Đọc bài viết đầy đủ'),
                style: ElevatedButton.styleFrom(
                  padding: const EdgeInsets.symmetric(vertical: 16),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  IconData _getSentimentIcon(double sentiment) {
    if (sentiment > 0.1) return Icons.sentiment_very_satisfied;
    if (sentiment < -0.1) return Icons.sentiment_very_dissatisfied;
    return Icons.sentiment_neutral;
  }

  Color _getSentimentColor(double sentiment) {
    if (sentiment > 0.1) return Colors.green;
    if (sentiment < -0.1) return Colors.red;
    return Colors.grey;
  }

  Color _getImpactColor(double impact) {
    if (impact >= 0.7) return Colors.red;
    if (impact >= 0.4) return Colors.orange;
    return Colors.green;
  }

  void _launchUrl(String url) async {
    final uri = Uri.parse(url);
    if (await canLaunchUrl(uri)) {
      await launchUrl(uri, mode: LaunchMode.externalApplication);
    } else {
      Get.snackbar(
        'Lỗi',
        'Không thể mở liên kết',
        snackPosition: SnackPosition.BOTTOM,
      );
    }
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\features\articles\bindings\articles_binding.dart ===== 
import 'package:get/get.dart';
import 'package:stock_tracker_app/src/features/articles/controllers/articles_controller.dart';

class ArticlesBinding implements Bindings {
  @override
  void dependencies() {
    Get.lazyPut(() => ArticlesController());
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\features\articles\bindings\article_detail_binding.dart ===== 
import 'package:get/get.dart';
import 'package:stock_tracker_app/src/features/articles/controllers/article_detail_controller.dart';

class ArticleDetailBinding implements Bindings {
  @override
  void dependencies() {
    Get.lazyPut(() => ArticleDetailController());
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\features\articles\controllers\articles_controller.dart ===== 
import 'package:get/get.dart';
import 'package:stock_tracker_app/src/shared/models/article_with_analysis_model.dart';
import 'package:stock_tracker_app/src/shared/repositories/articles_repository.dart';

class ArticlesController extends GetxController {
  final ArticlesRepository _repository = Get.find<ArticlesRepository>();

  // ✅ SỬA: Sử dụng ArticleWithAnalysis
  final _articles = <ArticleWithAnalysis>[].obs;
  final _isLoading = false.obs;
  final _errorMessage = ''.obs;
  final _hasMore = true.obs;
  
  // Filter states
  final _selectedCategory = Rxn<String>();
  final _showHighImpactOnly = false.obs;
  final _showSearchResult = false.obs;

  // Pagination
  final _currentPage = 0.obs;
  final int _limit = 20;
  final _searchValue = Rxn<String>();

  // Getters
  List<ArticleWithAnalysis> get articles => _articles.value;
  bool get isLoading => _isLoading.value;
  String get errorMessage => _errorMessage.value;
  bool get hasMore => _hasMore.value;
  String? get selectedCategory => _selectedCategory.value;
  bool get showHighImpactOnly => _showHighImpactOnly.value;

  @override
  void onInit() {
    super.onInit();
    loadArticles();
  }

  Future<void> loadArticles({bool refresh = false}) async {
    try {
      if (refresh) {
        _currentPage.value = 0;
        _hasMore.value = true;
      }

      _isLoading.value = true;
      _errorMessage.value = '';

      List<ArticleWithAnalysis> result;

      // Apply filters
      if (_showHighImpactOnly.value) {
        result = await _repository.getHighImpactArticles();
      } else if (_selectedCategory.value != null) {
        result = await _repository.getArticlesByCategory(_selectedCategory.value!);
      } else {
        // ✅ SỬA: Fetch articles with analysis
        result = await _repository.getArticlesWithAnalysis(
          skip: _currentPage.value * _limit,
          limit: _limit,
        );
      }

      if (refresh) {
        _articles.value = result;
      } else {
        _articles.addAll(result);
      }

      // ✅ SỬA: Search trong title của article
      if (_showSearchResult.value) {
        _articles.value = _articles.where((articleWithAnalysis) => 
          articleWithAnalysis.article.title.toLowerCase().contains(_searchValue.value?.toLowerCase() ?? '')
        ).toList();
      }

      _hasMore.value = result.length == _limit;
      _currentPage.value++;
    } catch (e) {
      _errorMessage.value = 'Failed to load articles: $e';
    } finally {
      _isLoading.value = false;
    }
  }

  Future<void> refreshArticles() async {
    await loadArticles(refresh: true);
  }

  Future<void> loadMoreArticles() async {
    if (!_hasMore.value || _isLoading.value) return;
    await loadArticles();
  }

  void filterByCategory(String? category) {
    _selectedCategory.value = category;
    _showHighImpactOnly.value = false;
    _showSearchResult.value = false;
    loadArticles(refresh: true);
  }

  void filterBySearch(String? value) {
    _showSearchResult.value = value != null && value.isNotEmpty;
    _selectedCategory.value = null;
    _showHighImpactOnly.value = false;
    _searchValue.value = value;
    loadArticles(refresh: true);
  }

  void toggleHighImpactFilter() {
    _showHighImpactOnly.value = !_showHighImpactOnly.value;
    _selectedCategory.value = null;
    _showSearchResult.value = false;
    loadArticles(refresh: true);
  }

  void clearFilters() {
    _selectedCategory.value = null;
    _showHighImpactOnly.value = false;
    _showSearchResult.value = false;
    _searchValue.value = null;
    loadArticles(refresh: true);
  }

  // ✅ SỬA: Lấy categories từ AI analysis
  List<String> get availableCategories {
    final categories = articles
        .where((articleWithAnalysis) => articleWithAnalysis.aiAnalysis?.category != null)
        .map((articleWithAnalysis) => articleWithAnalysis.aiAnalysis!.category!)
        .toSet()
        .toList();
    categories.sort();
    return categories;
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\features\articles\controllers\article_detail_controller.dart ===== 
import 'package:get/get.dart';
import 'package:stock_tracker_app/src/shared/models/ai_analysis_model.dart';
import 'package:stock_tracker_app/src/shared/models/article_model.dart';
import 'package:stock_tracker_app/src/shared/models/article_with_analysis_model.dart';
import 'package:stock_tracker_app/src/shared/repositories/articles_repository.dart';

class ArticleDetailController extends GetxController {
  final ArticlesRepository _repository = Get.find<ArticlesRepository>();

  // ✅ SỬA: Sử dụng ArticleWithAnalysis
  final _articleWithAnalysis = Rxn<ArticleWithAnalysis>();
  final _isLoading = false.obs;
  final _errorMessage = ''.obs;

  ArticleWithAnalysis? get articleWithAnalysis => _articleWithAnalysis.value;
  // Convenience getters
  Article? get article => _articleWithAnalysis.value?.article;
  AIAnalysis? get aiAnalysis => _articleWithAnalysis.value?.aiAnalysis;
  bool get isLoading => _isLoading.value;
  String get errorMessage => _errorMessage.value;

  @override
  void onInit() {
    super.onInit();
    final articleIdStr = Get.parameters['id'];
    if (articleIdStr != null) {
      loadArticle(int.parse(articleIdStr));
    }
  }

  Future<void> loadArticle(int id) async {
    try {
      _isLoading.value = true;
      _errorMessage.value = '';

      // ✅ SỬA: Fetch article with analysis từ repository
      final result = await _repository.getArticleWithAnalysis(id);
      _articleWithAnalysis.value = result;
      
    } catch (e) {
      _errorMessage.value = 'Failed to load article: $e';
    } finally {
      _isLoading.value = false;
    }
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\features\companies\companies_list_screen.dart ===== 
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:stock_tracker_app/src/features/companies/controllers/companies_controller.dart';
import 'package:stock_tracker_app/src/shared/widgets/loading_widget.dart';
import 'package:stock_tracker_app/src/shared/widgets/error_widget.dart';
import 'package:stock_tracker_app/src/shared/widgets/empty_widget.dart';
import 'package:stock_tracker_app/src/shared/utils/app_routes.dart';
import 'package:stock_tracker_app/src/shared/widgets/main_navigation.dart';

class CompaniesListScreen extends StatelessWidget {
  const CompaniesListScreen({super.key});

  @override
  Widget build(BuildContext context) {
    final companiesController = Get.find<CompaniesController>();

    return MainNavigation(
      child: Scaffold(
        appBar: AppBar(
          title: const Text('Công ty theo dõi'),
          actions: [
            IconButton(
              icon: const Icon(Icons.refresh),
              onPressed: () => companiesController.refreshCompanies(),
            ),
            PopupMenuButton<String>(
              onSelected: (value) {
                switch (value) {
                  case 'toggle_filter':
                    companiesController.toggleActiveFilter();
                    break;
                  case 'add_company':
                    _showAddCompanyDialog(context, companiesController);
                    break;
                }
              },
              itemBuilder: (context) => [
                PopupMenuItem(
                  value: 'toggle_filter',
                  child: Row(
                    children: [
                      Icon(companiesController.showActiveOnly 
                          ? Icons.visibility_off 
                          : Icons.visibility),
                      const SizedBox(width: 8),
                      Text(companiesController.showActiveOnly 
                          ? 'Hiện tất cả' 
                          : 'Chỉ hiện active'),
                    ],
                  ),
                ),
                const PopupMenuItem(
                  value: 'add_company',
                  child: Row(
                    children: [
                      Icon(Icons.add_business),
                      SizedBox(width: 8),
                      Text('Thêm công ty'),
                    ],
                  ),
                ),
              ],
            ),
          ],
        ),
        body: Column(
          children: [
            // // Filter chips
            // Padding(
            //   padding: const EdgeInsets.all(16),
            //   child: Obx(() => Wrap(
            //     spacing: 8,
            //     children: [
            //       FilterChip(
            //         selected: companiesController.showActiveOnly,
            //         label: Text('Chỉ active (${companiesController.companies.where((c) => c.isActive).length})'),
            //         onSelected: (selected) => companiesController.toggleActiveFilter(),
            //       ),
            //       // Sector filters
            //       ...companiesController.companiesBySector.keys.map((sector) {
            //         final count = companiesController.companiesBySector[sector]!.length;
            //         return FilterChip(
            //           selected: false,
            //           label: Text('$sector ($count)'),
            //           onSelected: (selected) {
            //             // Implement sector filtering if needed
            //           },
            //         );
            //       }).take(3), // Chỉ hiển thị top 3 sectors
            //     ],
            //   )),
            // ),
      
            // Companies List
            Expanded(
              child: Obx(() {
                if (companiesController.isLoading) {
                  return const LoadingWidget(message: 'Đang tải danh sách công ty...');
                }
      
                if (companiesController.errorMessage.isNotEmpty) {
                  return ErrorDisplayWidget(
                    message: companiesController.errorMessage,
                    onRetry: () => companiesController.refreshCompanies(),
                  );
                }
      
                if (companiesController.companies.isEmpty) {
                  return const EmptyWidget(
                    title: 'Chưa có công ty nào',
                    subtitle: 'Thêm công ty để bắt đầu theo dõi',
                    icon: Icons.business_outlined,
                  );
                }
      
                return RefreshIndicator(
                  onRefresh: () => companiesController.refreshCompanies(),
                  child: ListView.builder(
                    padding: const EdgeInsets.symmetric(horizontal: 16),
                    itemCount: companiesController.companies.length,
                    itemBuilder: (context, index) {
                      final company = companiesController.companies[index];
                      return _buildCompanyCard(context, company, companiesController);
                    },
                  ),
                );
              }),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildCompanyCard(BuildContext context, company, CompaniesController controller) {
    return Card(
      margin: const EdgeInsets.only(bottom: 12),
      child: ListTile(
        contentPadding: const EdgeInsets.all(16),
        leading: CircleAvatar(
          backgroundColor: company.isActive ? Colors.green : Colors.grey,
          child: Text(
            company.symbol.length >= 2 ? company.symbol.substring(0, 2) : company.symbol,
            style: const TextStyle(
              color: Colors.white,
              fontWeight: FontWeight.bold,
              fontSize: 14,
            ),
          ),
        ),
        title: Row(
          children: [
            Expanded(
              child: Text(
                company.symbol,
                style: Theme.of(context).textTheme.titleLarge?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
              decoration: BoxDecoration(
                color: company.isActive 
                    ? Colors.green.withOpacity(0.1) 
                    : Colors.grey.withOpacity(0.1),
                borderRadius: BorderRadius.circular(12),
              ),
              child: Text(
                company.isActive ? 'Active' : 'Inactive',
                style: TextStyle(
                  fontSize: 12,
                  color: company.isActive ? Colors.green : Colors.grey,
                  fontWeight: FontWeight.w600,
                ),
              ),
            ),
          ],
        ),
        subtitle: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const SizedBox(height: 8),
            Text(
              company.companyName,
              style: Theme.of(context).textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.w500,
              ),
              maxLines: 1,
              overflow: TextOverflow.ellipsis,
            ),
            const SizedBox(height: 4),
            if (company.sector != null)
              Text(
                '${company.sector} • ${company.industry ?? "N/A"}',
                style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                  color: Theme.of(context).colorScheme.onSurfaceVariant,
                ),
              ),
            const SizedBox(height: 8),
            Row(
              children: [
                Icon(
                  Icons.language,
                  size: 14,
                  color: Theme.of(context).colorScheme.onSurfaceVariant,
                ),
                const SizedBox(width: 4),
                Text(
                  company.country,
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(
                    color: Theme.of(context).colorScheme.onSurfaceVariant,
                  ),
                ),
                const Spacer(),
                IconButton(
                  icon: Icon(
                    company.isActive ? Icons.pause : Icons.play_arrow,
                    color: company.isActive ? Colors.orange : Colors.green,
                  ),
                  onPressed: () => controller.updateCompanyStatus(
                    company.symbol, 
                    !company.isActive
                  ),
                  tooltip: company.isActive ? 'Tạm dừng tracking' : 'Bắt đầu tracking',
                ),
                IconButton(
                  icon: const Icon(Icons.refresh),
                  onPressed: () => controller.fetchMetricsForCompany(company.symbol),
                  tooltip: 'Fetch metrics mới',
                ),
              ],
            ),
          ],
        ),
        onTap: () => Get.toNamed(
          AppRoutes.companyDetail.replaceAll(':symbol', company.symbol),
        ),
      ),
    );
  }

  void _showAddCompanyDialog(BuildContext context, CompaniesController controller) {
    final symbolController = TextEditingController();
    final nameController = TextEditingController();
    final sectorController = TextEditingController();

    Get.dialog(
      AlertDialog(
        title: const Text('Thêm công ty mới'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TextField(
              controller: symbolController,
              decoration: const InputDecoration(
                labelText: 'Symbol (VD: AAPL)',
                border: OutlineInputBorder(),
              ),
              textCapitalization: TextCapitalization.characters,
            ),
            const SizedBox(height: 16),
            TextField(
              controller: nameController,
              decoration: const InputDecoration(
                labelText: 'Tên công ty',
                border: OutlineInputBorder(),
              ),
            ),
            const SizedBox(height: 16),
            TextField(
              controller: sectorController,
              decoration: const InputDecoration(
                labelText: 'Sector (tùy chọn)',
                border: OutlineInputBorder(),
              ),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Get.back(),
            child: const Text('Hủy'),
          ),
          ElevatedButton(
            onPressed: () {
              if (symbolController.text.trim().isNotEmpty &&
                  nameController.text.trim().isNotEmpty) {
                Get.back();
                // TODO: Implement add company functionality
                Get.snackbar(
                  'Thông báo',
                  'Tính năng thêm công ty sẽ có trong phiên bản tới',
                  snackPosition: SnackPosition.BOTTOM,
                );
              }
            },
            child: const Text('Thêm'),
          ),
        ],
      ),
    );
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\features\companies\company_detail_screen.dart ===== 
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:fl_chart/fl_chart.dart';
import 'package:stock_tracker_app/src/features/companies/controllers/company_detail_controller.dart';
import 'package:stock_tracker_app/src/shared/widgets/loading_widget.dart';
import 'package:stock_tracker_app/src/shared/widgets/error_widget.dart';
import 'package:stock_tracker_app/src/shared/widgets/main_navigation.dart';
import 'package:url_launcher/url_launcher.dart';

class CompanyDetailScreen extends StatelessWidget {
  const CompanyDetailScreen({super.key});

  @override
  Widget build(BuildContext context) {
    final controller = Get.find<CompanyDetailController>();

    return MainNavigation(
      child: Scaffold(
        appBar: AppBar(
          title: Obx(() => Text(controller.company?.symbol ?? 'Chi tiết công ty')),
          actions: [
            Obx(() {
              final company = controller.company;
              if (company?.website != null) {
                return IconButton(
                  icon: const Icon(Icons.language),
                  onPressed: () => _launchUrl(company!.website!),
                  tooltip: 'Website công ty',
                );
              }
              return const SizedBox.shrink();
            }),
            IconButton(
              icon: const Icon(Icons.refresh),
              onPressed: () => controller.fetchNewMetrics(),
              tooltip: 'Fetch metrics mới',
            ),
          ],
        ),
        body: Obx(() {
          if (controller.isLoading) {
            return const LoadingWidget(message: 'Đang tải thông tin công ty...');
          }
      
          if (controller.errorMessage.isNotEmpty) {
            return ErrorDisplayWidget(
              message: controller.errorMessage,
              onRetry: () {
                final symbol = Get.parameters['symbol'];
                if (symbol != null) {
                  controller.loadCompanyDetail(symbol);
                }
              },
            );
          }
      
          final company = controller.company;
          if (company == null) {
            return const Center(child: Text('Không tìm thấy thông tin công ty'));
          }
      
          return SingleChildScrollView(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Company Header
                _buildCompanyHeader(context, company, controller),
      
                // Latest Metrics
                if (controller.latestMetrics != null)
                  _buildLatestMetrics(context, controller.latestMetrics!),
      
                // Charts Section
                if (controller.metricsHistory.isNotEmpty) ...[
                  _buildChartsSection(context, controller),
                ],
      
                // Company Info
                _buildCompanyInfo(context, company),
      
                // Actions
                _buildActionButtons(context, company, controller),
              ],
            ),
          );
        }),
      ),
    );
  }

  Widget _buildCompanyHeader(BuildContext context, company, CompanyDetailController controller) {
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.all(24),
      decoration: BoxDecoration(
        gradient: LinearGradient(
          colors: [
            Theme.of(context).colorScheme.primary.withOpacity(0.1),
            Theme.of(context).colorScheme.surface,
          ],
          begin: Alignment.topCenter,
          end: Alignment.bottomCenter,
        ),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              CircleAvatar(
                radius: 30,
                backgroundColor: company.isActive ? Colors.green : Colors.grey,
                child: Text(
                  company.symbol.length >= 2 ? company.symbol.substring(0, 2) : company.symbol,
                  style: const TextStyle(
                    color: Colors.white,
                    fontWeight: FontWeight.bold,
                    fontSize: 18,
                  ),
                ),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      company.symbol,
                      style: Theme.of(context).textTheme.headlineMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 4),
                    Text(
                      company.companyName,
                      style: Theme.of(context).textTheme.titleMedium?.copyWith(
                        color: Theme.of(context).colorScheme.onSurfaceVariant,
                      ),
                    ),
                  ],
                ),
              ),
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                decoration: BoxDecoration(
                  color: company.isActive 
                      ? Colors.green.withOpacity(0.1) 
                      : Colors.grey.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(16),
                ),
                child: Text(
                  company.isActive ? 'ACTIVE' : 'INACTIVE',
                  style: TextStyle(
                    fontSize: 12,
                    color: company.isActive ? Colors.green : Colors.grey,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 16),
          Row(
            children: [
              if (company.sector != null) ...[
                _buildInfoChip(context, 'Sector', company.sector!, Icons.business),
                const SizedBox(width: 12),
              ],
              if (company.country != null)
                _buildInfoChip(context, 'Country', company.country, Icons.flag),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildInfoChip(BuildContext context, String label, String value, IconData icon) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surfaceVariant,
        borderRadius: BorderRadius.circular(12),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon, size: 16, color: Theme.of(context).colorScheme.onSurfaceVariant),
          const SizedBox(width: 6),
          Text(
            '$label: $value',
            style: Theme.of(context).textTheme.bodySmall?.copyWith(
              color: Theme.of(context).colorScheme.onSurfaceVariant,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildLatestMetrics(BuildContext context, metrics) {
    return Padding(
      padding: const EdgeInsets.all(16),
      child: Card(
        child: Padding(
          padding: const EdgeInsets.all(20),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                'Chỉ số tài chính mới nhất',
                style: Theme.of(context).textTheme.titleLarge?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 16),
              GridView.count(
                crossAxisCount: 2,
                shrinkWrap: true,
                physics: const NeverScrollableScrollPhysics(),
                crossAxisSpacing: 16,
                mainAxisSpacing: 16,
                childAspectRatio: 2.5,
                children: [
                  _buildMetricCard(
                    context, 
                    'P/E Ratio', 
                    metrics.peRatio?.toStringAsFixed(2) ?? 'N/A',
                    Icons.trending_up,
                    Colors.blue,
                  ),
                  _buildMetricCard(
                    context, 
                    'Market Cap', 
                    metrics.formattedMarketCap,
                    Icons.account_balance,
                    Colors.green,
                  ),
                  _buildMetricCard(
                    context, 
                    'ROE', 
                    metrics.roe != null ? '${(metrics.roe! * 100).toStringAsFixed(1)}%' : 'N/A',
                    Icons.show_chart,
                    Colors.orange,
                  ),
                  _buildMetricCard(
                    context, 
                    'Revenue', 
                    metrics.formattedRevenue,
                    Icons.monetization_on,
                    Colors.purple,
                  ),
                ],
              ),
              const SizedBox(height: 16),
              Row(
                children: [
                  Icon(
                    Icons.schedule,
                    size: 16,
                    color: Theme.of(context).colorScheme.onSurfaceVariant,
                  ),
                  const SizedBox(width: 4),
                  Text(
                    'Cập nhật: ${_formatDate(metrics.recordedAt)}',
                    style: Theme.of(context).textTheme.bodySmall?.copyWith(
                      color: Theme.of(context).colorScheme.onSurfaceVariant,
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildMetricCard(
    BuildContext context,
    String title,
    String value,
    IconData icon,
    Color color,
  ) {
    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: color.withOpacity(0.1),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: color.withOpacity(0.3)),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(icon, color: color, size: 20),
              const Spacer(),
              Text(
                value,
                style: Theme.of(context).textTheme.titleMedium?.copyWith(
                  color: color,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ],
          ),
          const SizedBox(height: 4),
          Text(
            title,
            style: Theme.of(context).textTheme.bodySmall?.copyWith(
              color: Theme.of(context).colorScheme.onSurfaceVariant,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildChartsSection(BuildContext context, CompanyDetailController controller) {
    return Padding(
      padding: const EdgeInsets.all(16),
      child: Card(
        child: Padding(
          padding: const EdgeInsets.all(20),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                'Biểu đồ xu hướng',
                style: Theme.of(context).textTheme.titleLarge?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 20),
              
              // P/E Ratio Chart
              if (controller.peRatioChartData.isNotEmpty) ...[
                Text(
                  'P/E Ratio',
                  style: Theme.of(context).textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.w600,
                  ),
                ),
                const SizedBox(height: 12),
                SizedBox(
                  height: 200,
                  child: LineChart(
                    _buildLineChartData(
                      controller.peRatioChartData,
                      Colors.blue,
                      'P/E',
                    ),
                  ),
                ),
                const SizedBox(height: 24),
              ],
              
              // ROE Chart
              if (controller.roeChartData.isNotEmpty) ...[
                Text(
                  'ROE (%)',
                  style: Theme.of(context).textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.w600,
                  ),
                ),
                const SizedBox(height: 12),
                SizedBox(
                  height: 200,
                  child: LineChart(
                    _buildLineChartData(
                      controller.roeChartData.map((e) => e * 100).toList(), // Convert to percentage
                      Colors.orange,
                      'ROE %',
                    ),
                  ),
                ),
              ],
            ],
          ),
        ),
      ),
    );
  }

  LineChartData _buildLineChartData(List<double> data, Color color, String label) {
    return LineChartData(
      gridData: FlGridData(
        show: true,
        drawVerticalLine: true,
        horizontalInterval: 1,
        verticalInterval: 1,
        getDrawingHorizontalLine: (value) {
          return FlLine(
            color: Colors.grey.withOpacity(0.3),
            strokeWidth: 1,
          );
        },
        getDrawingVerticalLine: (value) {
          return FlLine(
            color: Colors.grey.withOpacity(0.3),
            strokeWidth: 1,
          );
        },
      ),
      titlesData: FlTitlesData(
        show: true,
        rightTitles: AxisTitles(
          sideTitles: SideTitles(showTitles: false),
        ),
        topTitles: AxisTitles(
          sideTitles: SideTitles(showTitles: false),
        ),
        bottomTitles: AxisTitles(
          sideTitles: SideTitles(
            showTitles: true,
            reservedSize: 30,
            interval: 1,
            getTitlesWidget: (double value, TitleMeta meta) {
              const style = TextStyle(
                fontSize: 10,
                fontWeight: FontWeight.w400,
              );
              if (value.toInt() < data.length) {
                return SideTitleWidget(
                  axisSide: meta.axisSide,
                  child: Text('${value.toInt() + 1}', style: style),
                );
              }
              return const Text('');
            },
          ),
        ),
        leftTitles: AxisTitles(
          sideTitles: SideTitles(
            showTitles: true,
            interval: null,
            getTitlesWidget: (double value, TitleMeta meta) {
              return Text(
                value.toStringAsFixed(1),
                style: const TextStyle(
                  fontSize: 10,
                  fontWeight: FontWeight.w400,
                ),
              );
            },
            reservedSize: 42,
          ),
        ),
      ),
      borderData: FlBorderData(
        show: true,
        border: Border.all(color: const Color(0xff37434d)),
      ),
      minX: 0,
      maxX: data.length.toDouble() - 1,
      minY: data.isNotEmpty ? data.reduce((a, b) => a < b ? a : b) * 0.9 : 0,
      maxY: data.isNotEmpty ? data.reduce((a, b) => a > b ? a : b) * 1.1 : 100,
      lineBarsData: [
        LineChartBarData(
          spots: data.asMap().entries.map((e) {
            return FlSpot(e.key.toDouble(), e.value);
          }).toList(),
          isCurved: true,
          gradient: LinearGradient(
            colors: [
              color,
              color.withOpacity(0.3),
            ],
          ),
          barWidth: 3,
          isStrokeCapRound: true,
          dotData: FlDotData(
            show: false,
          ),
          belowBarData: BarAreaData(
            show: true,
            gradient: LinearGradient(
              colors: [
                color.withOpacity(0.3),
                color.withOpacity(0.1),
              ],
              begin: Alignment.topCenter,
              end: Alignment.bottomCenter,
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildCompanyInfo(BuildContext context, company) {
    return Padding(
      padding: const EdgeInsets.all(16),
      child: Card(
        child: Padding(
          padding: const EdgeInsets.all(20),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                'Thông tin công ty',
                style: Theme.of(context).textTheme.titleLarge?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 16),
              _buildInfoRow(context, 'Symbol', company.symbol),
              _buildInfoRow(context, 'Tên công ty', company.companyName),
              if (company.sector != null)
                _buildInfoRow(context, 'Sector', company.sector!),
              if (company.industry != null)
                _buildInfoRow(context, 'Industry', company.industry!),
              _buildInfoRow(context, 'Quốc gia', company.country),
              if (company.description != null) ...[
                const SizedBox(height: 12),
                Text(
                  'Mô tả',
                  style: Theme.of(context).textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.w600,
                  ),
                ),
                const SizedBox(height: 8),
                Text(
                  company.description!,
                  style: Theme.of(context).textTheme.bodyMedium,
                ),
              ],
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildInfoRow(BuildContext context, String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          SizedBox(
            width: 100,
            child: Text(
              label,
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                color: Theme.of(context).colorScheme.onSurfaceVariant,
              ),
            ),
          ),
          Expanded(
            child: Text(
              value,
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                fontWeight: FontWeight.w500,
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildActionButtons(BuildContext context, company, CompanyDetailController controller) {
    return Padding(
      padding: const EdgeInsets.all(16),
      child: Column(
        children: [
          Row(
            children: [
              Expanded(
                child: ElevatedButton.icon(
                  onPressed: () => controller.fetchNewMetrics(),
                  icon: const Icon(Icons.refresh),
                  label: const Text('Fetch Metrics Mới'),
                ),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: OutlinedButton.icon(
                  onPressed: () => controller.toggleCompanyStatus(),
                  icon: Icon(company.isActive ? Icons.pause : Icons.play_arrow),
                  label: Text(company.isActive ? 'Tạm dừng' : 'Kích hoạt'),
                  style: OutlinedButton.styleFrom(
                    foregroundColor: company.isActive ? Colors.orange : Colors.green,
                  ),
                ),
              ),
            ],
          ),
          if (company.website != null) ...[
            const SizedBox(height: 12),
            SizedBox(
              width: double.infinity,
              child: OutlinedButton.icon(
                onPressed: () => _launchUrl(company.website!),
                icon: const Icon(Icons.language),
                label: const Text('Website công ty'),
              ),
            ),
          ],
        ],
      ),
    );
  }

  String _formatDate(DateTime date) {
    return '${date.day}/${date.month}/${date.year}';
  }

  void _launchUrl(String url) async {
    final uri = Uri.parse(url.startsWith('http') ? url : 'https://$url');
    if (await canLaunchUrl(uri)) {
      await launchUrl(uri, mode: LaunchMode.externalApplication);
    } else {
      Get.snackbar(
        'Lỗi',
        'Không thể mở liên kết',
        snackPosition: SnackPosition.BOTTOM,
      );
    }
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\features\companies\bindings\companies_binding.dart ===== 
import 'package:get/get.dart';
import 'package:stock_tracker_app/src/features/companies/controllers/companies_controller.dart';

class CompaniesBinding implements Bindings {
  @override
  void dependencies() {
    Get.lazyPut(() => CompaniesController());
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\features\companies\bindings\company_detail_binding.dart ===== 
import 'package:get/get.dart';
import 'package:stock_tracker_app/src/features/companies/controllers/company_detail_controller.dart';

class CompanyDetailBinding implements Bindings {
  @override
  void dependencies() {
    Get.lazyPut(() => CompanyDetailController());
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\features\companies\controllers\companies_controller.dart ===== 
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:stock_tracker_app/src/shared/models/company_model.dart';
import 'package:stock_tracker_app/src/shared/repositories/companies_repository.dart';

class CompaniesController extends GetxController {
  final CompaniesRepository _repository = Get.find<CompaniesRepository>();

  final _companies = <Company>[].obs;
  final _isLoading = false.obs;
  final _errorMessage = ''.obs;
  final _showActiveOnly = true.obs;

  List<Company> get companies => _companies.value;
  bool get isLoading => _isLoading.value;
  String get errorMessage => _errorMessage.value;
  bool get showActiveOnly => _showActiveOnly.value;

  @override
  void onInit() {
    super.onInit();
    loadCompanies();
  }

  Future<void> loadCompanies() async {
    try {
      _isLoading.value = true;
      _errorMessage.value = '';

      final result = await _repository.getCompanies(
        activeOnly: _showActiveOnly.value,
        limit: 100, // Load all companies
      );
      _companies.value = result;
    } catch (e) {
      _errorMessage.value = 'Failed to load companies: $e';
    } finally {
      _isLoading.value = false;
    }
  }

  Future<void> refreshCompanies() async {
    await loadCompanies();
  }

  void toggleActiveFilter() {
    _showActiveOnly.value = !_showActiveOnly.value;
    loadCompanies();
  }

  Future<void> updateCompanyStatus(String symbol, bool isActive) async {
    try {
      await _repository.updateCompany(symbol, {'is_active': isActive});
      
      // Update local state
      final index = _companies.indexWhere((c) => c.symbol == symbol);
      if (index != -1) {
        _companies[index] = Company(
          id: _companies[index].id,
          symbol: _companies[index].symbol,
          companyName: _companies[index].companyName,
          sector: _companies[index].sector,
          industry: _companies[index].industry,
          country: _companies[index].country,
          website: _companies[index].website,
          description: _companies[index].description,
          isActive: isActive,
          createdAt: _companies[index].createdAt,
          updatedAt: DateTime.now(),
        );
        _companies.refresh();
      }

      Get.snackbar(
        'Success',
        'Company status updated successfully',
        snackPosition: SnackPosition.BOTTOM,
      );
    } catch (e) {
      Get.snackbar(
        'Error',
        'Failed to update company status: $e',
        snackPosition: SnackPosition.BOTTOM,
      );
    }
  }

  Future<void> fetchMetricsForCompany(String symbol) async {
    try {
      Get.dialog(
        const Center(child: CircularProgressIndicator()),
        barrierDismissible: false,
      );

      final result = await _repository.fetchMetricsForCompany(symbol);
      
      Get.back(); // Close loading dialog
      
      Get.snackbar(
        'Success',
        result['message'] ?? 'Metrics fetched successfully',
        snackPosition: SnackPosition.BOTTOM,
      );
    } catch (e) {
      Get.back(); // Close loading dialog
      Get.snackbar(
        'Error',
        'Failed to fetch metrics: $e',
        snackPosition: SnackPosition.BOTTOM,
      );
    }
  }

  // Lấy companies grouped by sector
  Map<String, List<Company>> get companiesBySector {
    final grouped = <String, List<Company>>{};
    for (final company in companies) {
      final sector = company.sector ?? 'Unknown';
      grouped.putIfAbsent(sector, () => []).add(company);
    }
    return grouped;
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\features\companies\controllers\company_detail_controller.dart ===== 
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:stock_tracker_app/src/shared/models/company_model.dart';
import 'package:stock_tracker_app/src/shared/repositories/companies_repository.dart';

class CompanyDetailController extends GetxController {
  final CompaniesRepository _repository = Get.find<CompaniesRepository>();

  final _company = Rxn<Company>();
  final _latestMetrics = Rxn<CompanyMetrics>();
  final _metricsHistory = <CompanyMetrics>[].obs;
  final _isLoading = false.obs;
  final _isLoadingHistory = false.obs;
  final _errorMessage = ''.obs;

  // Getters
  Company? get company => _company.value;
  CompanyMetrics? get latestMetrics => _latestMetrics.value;
  List<CompanyMetrics> get metricsHistory => _metricsHistory.value;
  bool get isLoading => _isLoading.value;
  bool get isLoadingHistory => _isLoadingHistory.value;
  String get errorMessage => _errorMessage.value;

  @override
  void onInit() {
    super.onInit();
    final symbol = Get.parameters['symbol'];
    if (symbol != null) {
      loadCompanyDetail(symbol);
    }
  }

  Future<void> loadCompanyDetail(String symbol) async {
    try {
      _isLoading.value = true;
      _errorMessage.value = '';

      // Load company info
      final companyResult = await _repository.getCompanyBySymbol(symbol);
      _company.value = companyResult;

      // Load latest metrics
      try {
        final latestResult = await _repository.getLatestMetrics(symbol);
        _latestMetrics.value = latestResult;
      } catch (e) {
        print('No latest metrics found for $symbol: $e');
      }

      // Load metrics history for charts
      await loadMetricsHistory(symbol);

    } catch (e) {
      _errorMessage.value = 'Failed to load company details: $e';
    } finally {
      _isLoading.value = false;
    }
  }

  Future<void> loadMetricsHistory(String symbol, {int limit = 30}) async {
    try {
      _isLoadingHistory.value = true;
      
      final historyResult = await _repository.getCompanyMetricsHistory(
        symbol, 
        limit: limit
      );
      
      // Sắp xếp theo thời gian tăng dần cho chart
      historyResult.sort((a, b) => a.recordedAt.compareTo(b.recordedAt));
      _metricsHistory.value = historyResult;
      
    } catch (e) {
      print('Failed to load metrics history for $symbol: $e');
    } finally {
      _isLoadingHistory.value = false;
    }
  }

  Future<void> fetchNewMetrics() async {
    if (_company.value == null) return;

    try {
      Get.dialog(
        const Center(child: CircularProgressIndicator()),
        barrierDismissible: false,
      );

      final result = await _repository.fetchMetricsForCompany(_company.value!.symbol);
      
      Get.back(); // Close loading dialog
      
      Get.snackbar(
        'Thành công',
        result['message'] ?? 'Đã fetch metrics mới',
        snackPosition: SnackPosition.BOTTOM,
      );

      // Reload data
      await loadCompanyDetail(_company.value!.symbol);
      
    } catch (e) {
      Get.back(); // Close loading dialog
      Get.snackbar(
        'Lỗi',
        'Không thể fetch metrics mới: $e',
        snackPosition: SnackPosition.BOTTOM,
      );
    }
  }

  Future<void> toggleCompanyStatus() async {
    if (_company.value == null) return;

    try {
      final newStatus = !_company.value!.isActive;
      
      await _repository.updateCompany(
        _company.value!.symbol, 
        {'is_active': newStatus}
      );

      // Update local state
      _company.value = Company(
        id: _company.value!.id,
        symbol: _company.value!.symbol,
        companyName: _company.value!.companyName,
        sector: _company.value!.sector,
        industry: _company.value!.industry,
        country: _company.value!.country,
        website: _company.value!.website,
        description: _company.value!.description,
        isActive: newStatus,
        createdAt: _company.value!.createdAt,
        updatedAt: DateTime.now(),
      );

      Get.snackbar(
        'Thành công',
        'Đã ${newStatus ? "kích hoạt" : "tạm dừng"} tracking cho ${_company.value!.symbol}',
        snackPosition: SnackPosition.BOTTOM,
      );
      
    } catch (e) {
      Get.snackbar(
        'Lỗi',
        'Không thể cập nhật trạng thái: $e',
        snackPosition: SnackPosition.BOTTOM,
      );
    }
  }

  // Helper methods cho chart data
  List<double> get peRatioChartData {
    return _metricsHistory
        .where((m) => m.peRatio != null)
        .map((m) => m.peRatio!)
        .toList();
  }

  List<double> get marketCapChartData {
    return _metricsHistory
        .where((m) => m.marketCap != null)
        .map((m) => m.marketCap!.toDouble())
        .toList();
  }

  List<double> get roeChartData {
    return _metricsHistory
        .where((m) => m.roe != null)
        .map((m) => m.roe!)
        .toList();
  }

  List<String> get chartLabels {
    return _metricsHistory
        .map((m) => '${m.recordedAt.day}/${m.recordedAt.month}')
        .toList();
  }

  // Quick metrics comparison
  Map<String, dynamic> get metricsComparison {
    if (_metricsHistory.length < 2) return {};
    
    final latest = _metricsHistory.last;
    final previous = _metricsHistory[_metricsHistory.length - 2];
    
    return {
      'pe_change': _calculateChange(previous.peRatio, latest.peRatio),
      'roe_change': _calculateChange(previous.roe, latest.roe),
      'market_cap_change': _calculateChange(
        previous.marketCap?.toDouble(), 
        latest.marketCap?.toDouble()
      ),
    };
  }

  double? _calculateChange(double? oldValue, double? newValue) {
    if (oldValue == null || newValue == null || oldValue == 0) return null;
    return ((newValue - oldValue) / oldValue) * 100;
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\features\dashboard\dashboard_screen.dart ===== 
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:stock_tracker_app/src/features/dashboard/controllers/dashboard_controller.dart';
import 'package:stock_tracker_app/src/features/dashboard/widgets/quick_stats_section.dart';
import 'package:stock_tracker_app/src/features/dashboard/widgets/recent_articles_section.dart';
import 'package:stock_tracker_app/src/features/dashboard/widgets/company_overview_section.dart';
import 'package:stock_tracker_app/src/features/dashboard/widgets/analytics_preview_section.dart';
import 'package:stock_tracker_app/src/shared/widgets/dashboard_header.dart';
import 'package:stock_tracker_app/src/shared/widgets/loading_widget.dart';
import 'package:stock_tracker_app/src/shared/widgets/error_widget.dart';
import 'package:stock_tracker_app/src/shared/utils/app_routes.dart';
import 'package:stock_tracker_app/src/shared/widgets/main_navigation.dart';

class DashboardScreen extends StatelessWidget {
  const DashboardScreen({super.key});

  @override
  Widget build(BuildContext context) {
    final dashboardController = Get.find<DashboardController>();

    return MainNavigation(
      child: Scaffold(
        appBar: AppBar(
          title: const Text('Dashboard'),
          actions: [
            IconButton(
              icon: const Icon(Icons.refresh),
              onPressed: () => dashboardController.refreshDashboard(),
            ),
          ],
        ),
        body: Obx(() {
          if (dashboardController.isLoading) {
            return const LoadingWidget(message: 'Đang tải dashboard...');
          }
      
          if (dashboardController.errorMessage.isNotEmpty) {
            return ErrorDisplayWidget(
              message: dashboardController.errorMessage,
              onRetry: () => dashboardController.refreshDashboard(),
            );
          }
      
          return RefreshIndicator(
            onRefresh: () => dashboardController.refreshDashboard(),
            child: SingleChildScrollView(
              physics: const AlwaysScrollableScrollPhysics(),
              child: Padding(
                padding: const EdgeInsets.all(16.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Header với thống kê tổng quan
                    const DashboardHeader(),
                    const SizedBox(height: 24),
      
                    // Quick Stats từ API thực tế
                    QuickStatsSection(
                      articlesCount: dashboardController.articlesCount,
                      companiesData: dashboardController.dashboardData,
                      watchlistCount: dashboardController.watchlistItems.length,
                    ),
                    const SizedBox(height: 24),
      
                    // Company Overview từ dashboard API
                    CompanyOverviewSection(
                      dashboardData: dashboardController.dashboardData,
                    ),
                    const SizedBox(height: 24),
      
                    // Recent Articles với AI Analysis
                    Text(
                      'Tin tức gần đây',
                      style: Theme.of(context).textTheme.headlineSmall?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 16),
                    RecentArticlesSection(
                      articles: dashboardController.recentArticles,
                    ),
                    const SizedBox(height: 24),
      
                    // Analytics Preview
                    AnalyticsPreviewSection(
                      articlesByCategory: dashboardController.articlesByCategory,
                      sentimentTrend: dashboardController.sentimentTrend,
                      highImpactCount: dashboardController.highImpactArticles.length,
                    ),
                    const SizedBox(height: 24),
      
                    // Quick Actions
                    _buildQuickActions(context),
                  ],
                ),
              ),
            ),
          );
        }),
      ),
    );
  }

  Widget _buildQuickActions(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Truy cập nhanh',
          style: Theme.of(context).textTheme.headlineSmall?.copyWith(
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: 16),
        GridView.count(
          crossAxisCount: 2,
          shrinkWrap: true,
          physics: const NeverScrollableScrollPhysics(),
          crossAxisSpacing: 16,
          mainAxisSpacing: 16,
          childAspectRatio: 2.5,
          children: [
            _buildQuickActionCard(
              context,
              'Tất cả tin tức',
              Icons.article_outlined,
              () => Get.toNamed(AppRoutes.articles),
            ),
            _buildQuickActionCard(
              context,
              'Công ty',
              Icons.business_outlined,
              () => Get.toNamed(AppRoutes.companies),
            ),
            _buildQuickActionCard(
              context,
              'Watchlist',
              Icons.bookmark_outline,
              () => Get.toNamed(AppRoutes.watchlist),
            ),
            _buildQuickActionCard(
              context,
              'Phân tích',
              Icons.analytics_outlined,
              () => Get.toNamed(AppRoutes.analytics),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildQuickActionCard(
    BuildContext context,
    String title,
    IconData icon,
    VoidCallback onTap,
  ) {
    return Card(
      elevation: 2,
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            children: [
              Icon(
                icon,
                size: 24,
                color: Theme.of(context).colorScheme.primary,
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Text(
                  title,
                  style: Theme.of(context).textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ),
              Icon(
                Icons.arrow_forward_ios,
                size: 16,
                color: Theme.of(context).colorScheme.onSurfaceVariant,
              ),
            ],
          ),
        ),
      ),
    );
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\features\dashboard\bindings\dashboard_binding.dart ===== 
import 'package:get/get.dart';
import 'package:stock_tracker_app/src/features/dashboard/controllers/dashboard_controller.dart';

class DashboardBinding implements Bindings {
  @override
  void dependencies() {
    Get.lazyPut(() => DashboardController());
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\features\dashboard\controllers\dashboard_controller.dart ===== 
import 'package:get/get.dart';
import 'package:stock_tracker_app/src/shared/models/article_model.dart';
import 'package:stock_tracker_app/src/shared/models/article_with_analysis_model.dart';
import 'package:stock_tracker_app/src/shared/models/dashboard_model.dart';
import 'package:stock_tracker_app/src/shared/models/watchlist_model.dart';
import 'package:stock_tracker_app/src/shared/repositories/articles_repository.dart';
import 'package:stock_tracker_app/src/shared/repositories/companies_repository.dart';
import 'package:stock_tracker_app/src/shared/repositories/watchlist_repository.dart';

class DashboardController extends GetxController {
  final ArticlesRepository _articlesRepository = Get.find<ArticlesRepository>();
  final CompaniesRepository _companiesRepository = Get.find<CompaniesRepository>();
  final WatchlistRepository _watchlistRepository = Get.find<WatchlistRepository>();

  // Observable states
  final _recentArticles = <ArticleWithAnalysis>[].obs;
  final _highImpactArticles = <ArticleWithAnalysis>[].obs;
  final _dashboardData = Rxn<DashboardData>();
  final _watchlistItems = <WatchlistItem>[].obs;
  final _articlesCount = 0.obs;
  final _isLoading = false.obs;
  final _errorMessage = ''.obs;

  // Getters
  List<ArticleWithAnalysis> get recentArticles => _recentArticles.value;
  List<ArticleWithAnalysis> get highImpactArticles => _highImpactArticles.value;
  DashboardData? get dashboardData => _dashboardData.value;
  List<WatchlistItem> get watchlistItems => _watchlistItems.value;
  int get articlesCount => _articlesCount.value;
  bool get isLoading => _isLoading.value;
  String get errorMessage => _errorMessage.value;

  @override
  void onInit() {
    super.onInit();
    loadDashboardData();
  }

  Future<void> loadDashboardData() async {
    try {
      _isLoading.value = true;
      _errorMessage.value = '';

      // Load tất cả data song song
      await Future.wait([
        _loadRecentArticles(),
        _loadCompanyDashboard(),
        _loadWatchlistItems(),
        _loadArticlesCount(),
      ]);

    } catch (e) {
      _errorMessage.value = 'Failed to load dashboard data: $e';
    } finally {
      _isLoading.value = false;
    }
  }

  Future<void> _loadRecentArticles() async {
    try {
      // ✅ SỬA: Fetch articles with analysis
      final articles = await _articlesRepository.getArticlesWithAnalysis(skip: 0, limit: 10);
      _recentArticles.value = articles;
    } catch (e) {
      throw e;
    }
  }

  Future<void> _loadHighImpactArticles() async {
    try {
      final articles = await _articlesRepository.getHighImpactArticles(minImpact: 0.7);
      _highImpactArticles.value = articles;
    } catch (e) {
      throw e;
    }
  }

  Future<void> _loadCompanyDashboard() async {
    try {
      final dashboard = await _companiesRepository.getDashboardOverview();
      _dashboardData.value = dashboard;
    } catch (e) {
      print('Failed to load company dashboard: $e');
    }
  }

  Future<void> _loadWatchlistItems() async {
    try {
      final items = await _watchlistRepository.getWatchlist();
      _watchlistItems.value = items;
    } catch (e) {
      print('Failed to load watchlist: $e');
    }
  }

  Future<void> _loadArticlesCount() async {
    try {
      final countData = await _articlesRepository.getArticlesCount();
      _articlesCount.value = countData['total_articles'] ?? 0;
    } catch (e) {
      print('Failed to load articles count: $e');
    }
  }

  Future<void> refreshDashboard() async {
    await loadDashboardData();
  }

  // Analytics getters
  Map<String, int> get articlesByCategory {
    final categoryCount = <String, int>{};
    for (final article in _recentArticles) {
      final category = article.aiAnalysis?.category ?? 'Khác';
      categoryCount[category] = (categoryCount[category] ?? 0) + 1;
    }
    return categoryCount;
  }

  Map<String, int> get articlesBySentiment {
    final sentimentCount = <String, int>{};
    for (final article in _recentArticles) {
      final sentiment = article.aiAnalysis?.sentimentText ?? 'Không rõ';
      sentimentCount[sentiment] = (sentimentCount[sentiment] ?? 0) + 1;
    }
    return sentimentCount;
  }

  double get averageSentiment {
    final articlesWithSentiment = _recentArticles
        .where((article) => article.aiAnalysis?.sentimentScore != null)
        .toList();
    
    if (articlesWithSentiment.isEmpty) return 0.0;
    
    final total = articlesWithSentiment
        .map((article) => article.aiAnalysis!.sentimentScore!)
        .reduce((a, b) => a + b);
    
    return total / articlesWithSentiment.length;
  }

  String get sentimentTrend {
    if (averageSentiment > 0.1) return 'Tích cực';
    if (averageSentiment < -0.1) return 'Tiêu cực';
    return 'Trung tính';
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\features\dashboard\widgets\analytics_preview_section.dart ===== 
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:stock_tracker_app/src/shared/utils/app_routes.dart';

class AnalyticsPreviewSection extends StatelessWidget {
  final Map<String, int> articlesByCategory;
  final String sentimentTrend;
  final int highImpactCount;

  const AnalyticsPreviewSection({
    super.key,
    required this.articlesByCategory,
    required this.sentimentTrend,
    required this.highImpactCount,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text(
              'Phân tích xu hướng',
              style: Theme.of(context).textTheme.headlineSmall?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            TextButton(
              onPressed: () => Get.toNamed(AppRoutes.analytics),
              child: const Text('Xem chi tiết'),
            ),
          ],
        ),
        const SizedBox(height: 16),
        
        Row(
          children: [
            Expanded(
              child: _buildAnalyticsCard(
                context,
                'Xu hướng cảm xúc',
                sentimentTrend,
                _getSentimentIcon(sentimentTrend),
                _getSentimentColor(sentimentTrend),
              ),
            ),
            const SizedBox(width: 16),
            Expanded(
              child: _buildAnalyticsCard(
                context,
                'Tin tác động cao',
                '$highImpactCount tin',
                Icons.priority_high,
                Colors.red,
              ),
            ),
          ],
        ),
        const SizedBox(height: 16),

        // Category distribution
        if (articlesByCategory.isNotEmpty) ...[
          Text(
            'Phân bố theo danh mục',
            style: Theme.of(context).textTheme.titleMedium?.copyWith(
              fontWeight: FontWeight.w600,
            ),
          ),
          const SizedBox(height: 8),
          SizedBox(
            height: 120,
            child: ListView.builder(
              scrollDirection: Axis.horizontal,
              itemCount: articlesByCategory.entries.take(4).length,
              itemBuilder: (context, index) {
                final entry = articlesByCategory.entries.elementAt(index);
                return _buildCategoryChip(context, entry.key, entry.value);
              },
            ),
          ),
        ],
      ],
    );
  }

  Widget _buildAnalyticsCard(
    BuildContext context,
    String title,
    String value,
    IconData icon,
    Color color,
  ) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          children: [
            Icon(
              icon,
              size: 32,
              color: color,
            ),
            const SizedBox(height: 8),
            Text(
              value,
              style: Theme.of(context).textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.bold,
                color: color,
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 4),
            Text(
              title,
              style: Theme.of(context).textTheme.bodyMedium,
              textAlign: TextAlign.center,
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildCategoryChip(BuildContext context, String category, int count) {
    return Container(
      width: 100,
      margin: const EdgeInsets.only(right: 8),
      child: Card(
        child: Padding(
          padding: const EdgeInsets.all(12),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text(
                '$count',
                style: Theme.of(context).textTheme.headlineSmall?.copyWith(
                  fontWeight: FontWeight.bold,
                  color: Theme.of(context).colorScheme.primary,
                ),
              ),
              const SizedBox(height: 4),
              Text(
                category,
                style: Theme.of(context).textTheme.bodySmall,
                textAlign: TextAlign.center,
                maxLines: 2,
                overflow: TextOverflow.ellipsis,
              ),
            ],
          ),
        ),
      ),
    );
  }

  IconData _getSentimentIcon(String sentiment) {
    switch (sentiment) {
      case 'Tích cực':
        return Icons.sentiment_very_satisfied;
      case 'Tiêu cực':
        return Icons.sentiment_very_dissatisfied;
      default:
        return Icons.sentiment_neutral;
    }
  }

  Color _getSentimentColor(String sentiment) {
    switch (sentiment) {
      case 'Tích cực':
        return Colors.green;
      case 'Tiêu cực':
        return Colors.red;
      default:
        return Colors.grey;
    }
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\features\dashboard\widgets\company_overview_section.dart ===== 
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:stock_tracker_app/src/shared/models/dashboard_model.dart';
import 'package:stock_tracker_app/src/shared/utils/app_routes.dart';

class CompanyOverviewSection extends StatelessWidget {
  final DashboardData? dashboardData;

  const CompanyOverviewSection({
    super.key,
    this.dashboardData,
  });

  @override
  Widget build(BuildContext context) {
    if (dashboardData == null) {
      return const SizedBox.shrink();
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text(
              'Tổng quan công ty',
              style: Theme.of(context).textTheme.headlineSmall?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            TextButton(
              onPressed: () => Get.toNamed(AppRoutes.companies),
              child: const Text('Xem tất cả'),
            ),
          ],
        ),
        const SizedBox(height: 16),
        
        // Company stats cards
        Row(
          children: [
            Expanded(
              child: _buildCompanyStatCard(
                context,
                'Có dữ liệu',
                '${dashboardData!.companiesWithData}',
                Colors.green,
              ),
            ),
            const SizedBox(width: 16),
            Expanded(
              child: _buildCompanyStatCard(
                context,
                'Thiếu dữ liệu',
                '${dashboardData!.companiesWithoutData}',
                Colors.orange,
              ),
            ),
          ],
        ),
        const SizedBox(height: 16),

        // Top companies list
        if (dashboardData!.companies.isNotEmpty) ...[
          Text(
            'Top công ty gần đây',
            style: Theme.of(context).textTheme.titleMedium?.copyWith(
              fontWeight: FontWeight.w600,
            ),
          ),
          const SizedBox(height: 8),
          ListView.builder(
            shrinkWrap: true,
            physics: const NeverScrollableScrollPhysics(),
            itemCount: dashboardData!.companies.take(5).length,
            itemBuilder: (context, index) {
              final company = dashboardData!.companies[index];
              return _buildCompanyTile(context, company);
            },
          ),
        ],
      ],
    );
  }

  Widget _buildCompanyStatCard(
    BuildContext context,
    String title,
    String value,
    Color color,
  ) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          children: [
            Text(
              value,
              style: Theme.of(context).textTheme.headlineMedium?.copyWith(
                fontWeight: FontWeight.bold,
                color: color,
              ),
            ),
            const SizedBox(height: 4),
            Text(
              title,
              style: Theme.of(context).textTheme.bodyMedium,
              textAlign: TextAlign.center,
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildCompanyTile(BuildContext context, CompanySummary company) {
    return ListTile(
      dense: true,
      leading: CircleAvatar(
        backgroundColor: company.isActive ? Colors.green : Colors.grey,
        child: Text(
          company.symbol.substring(0, 2),
          style: const TextStyle(
            color: Colors.white,
            fontWeight: FontWeight.bold,
            fontSize: 12,
          ),
        ),
      ),
      title: Text(
        company.symbol,
        style: const TextStyle(fontWeight: FontWeight.w600),
      ),
      subtitle: Text(
        company.sector ?? 'N/A',
        style: Theme.of(context).textTheme.bodySmall,
      ),
      trailing: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        crossAxisAlignment: CrossAxisAlignment.end,
        children: [
          if (company.peRatio != null)
            Text(
              'PE: ${company.peRatio!.toStringAsFixed(1)}',
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                fontWeight: FontWeight.w500,
              ),
            ),
          if (company.marketCap != null)
            Text(
              _formatMarketCap(company.marketCap!),
              style: Theme.of(context).textTheme.bodySmall,
            ),
        ],
      ),
      onTap: () => Get.toNamed(
        AppRoutes.companyDetail.replaceAll(':symbol', company.symbol),
      ),
    );
  }

  String _formatMarketCap(int marketCap) {
    if (marketCap >= 1000000000) {
      return '\$${(marketCap / 1000000000).toStringAsFixed(1)}B';
    } else if (marketCap >= 1000000) {
      return '\$${(marketCap / 1000000).toStringAsFixed(1)}M';
    }
    return '\$${marketCap}';
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\features\dashboard\widgets\quick_stats_section.dart ===== 
import 'package:flutter/material.dart';
import 'package:stock_tracker_app/src/shared/models/dashboard_model.dart';

class QuickStatsSection extends StatelessWidget {
  final int articlesCount;
  final DashboardData? companiesData;
  final int watchlistCount;

  const QuickStatsSection({
    super.key,
    required this.articlesCount,
    this.companiesData,
    required this.watchlistCount,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Thống kê nhanh',
          style: Theme.of(context).textTheme.headlineSmall?.copyWith(
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: 16),
        Row(
          children: [
            Expanded(
              child: _buildStatCard(
                context,
                'Tổng tin tức',
                '$articlesCount',
                Icons.article_outlined,
                Colors.blue,
              ),
            ),
            const SizedBox(width: 16),
            Expanded(
              child: _buildStatCard(
                context,
                'Công ty theo dõi',
                '${companiesData?.totalCompanies ?? 0}',
                Icons.business_outlined,
                Colors.green,
              ),
            ),
          ],
        ),
        const SizedBox(height: 16),
        Row(
          children: [
            Expanded(
              child: _buildStatCard(
                context,
                'Watchlist items',
                '$watchlistCount',
                Icons.bookmark_outline,
                Colors.orange,
              ),
            ),
            const SizedBox(width: 16),
            Expanded(
              child: _buildStatCard(
                context,
                'API Usage',
                '${companiesData?.apiUsageToday ?? 0}/${companiesData?.apiLimit ?? 250}',
                Icons.api_outlined,
                _getApiUsageColor(companiesData?.apiUsagePercentage ?? 0),
              ),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildStatCard(
    BuildContext context,
    String title,
    String value,
    IconData icon,
    Color color,
  ) {
    return Card(
      elevation: 2,
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Icon(
                  icon,
                  color: color,
                  size: 24,
                ),
                Text(
                  value,
                  style: Theme.of(context).textTheme.headlineSmall?.copyWith(
                    fontWeight: FontWeight.bold,
                    color: color,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 8),
            Text(
              title,
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                color: Theme.of(context).colorScheme.onSurfaceVariant,
              ),
            ),
          ],
        ),
      ),
    );
  }

  Color _getApiUsageColor(double percentage) {
    if (percentage >= 80) return Colors.red;
    if (percentage >= 60) return Colors.orange;
    return Colors.green;
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\features\dashboard\widgets\recent_articles_section.dart ===== 
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:stock_tracker_app/src/shared/models/article_with_analysis_model.dart';
import 'package:stock_tracker_app/src/shared/utils/app_constants.dart';
import 'package:stock_tracker_app/src/shared/utils/app_routes.dart';

class RecentArticlesSection extends StatelessWidget {
  final List<ArticleWithAnalysis> articles; // ✅ SỬA: ArticleWithAnalysis

  const RecentArticlesSection({
    super.key,
    required this.articles,
  });

  @override
  Widget build(BuildContext context) {
    if (articles.isEmpty) {
      return Card(
        child: Padding(
          padding: const EdgeInsets.all(24),
          child: Center(
            child: Column(
              children: [
                Icon(
                  Icons.article_outlined,
                  size: 48,
                  color: Theme.of(context).colorScheme.outline,
                ),
                const SizedBox(height: 8),
                Text(
                  'Chưa có tin tức',
                  style: Theme.of(context).textTheme.titleMedium,
                ),
                const SizedBox(height: 4),
                Text(
                  'Hệ thống sẽ tự động cập nhật tin tức mới',
                  style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                    color: Theme.of(context).colorScheme.onSurfaceVariant,
                  ),
                ),
              ],
            ),
          ),
        ),
      );
    }

    return Column(
      children: [
        ListView.builder(
          shrinkWrap: true,
          physics: const NeverScrollableScrollPhysics(),
          itemCount: articles.take(5).length,
          itemBuilder: (context, index) {
            final articleWithAnalysis = articles[index];
            return _buildArticleCard(context, articleWithAnalysis);
          },
        ),
        const SizedBox(height: 16),
        Row(
          children: [
            Expanded(
              child: OutlinedButton(
                onPressed: () => Get.toNamed(AppRoutes.articles),
                child: const Text('Xem tất cả tin tức'),
              ),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildArticleCard(BuildContext context, ArticleWithAnalysis articleWithAnalysis) {
    final article = articleWithAnalysis.article;
    final aiAnalysis = articleWithAnalysis.aiAnalysis;
    
    final categoryColor = aiAnalysis?.category != null 
        ? AppConstants.categoryColors[aiAnalysis!.category!] ?? AppConstants.categoryColors['Không liên quan']!
        : AppConstants.categoryColors['Không liên quan']!;

    return Card(
      margin: const EdgeInsets.only(bottom: 12),
      child: ListTile(
        contentPadding: const EdgeInsets.all(16),
        title: Text(
          article.title,
          style: Theme.of(context).textTheme.titleMedium?.copyWith(
            fontWeight: FontWeight.w600,
          ),
          maxLines: 2,
          overflow: TextOverflow.ellipsis,
        ),
        subtitle: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            if (article.summary != null) ...[
              const SizedBox(height: 8),
              Text(
                article.summary!,
                maxLines: 2,
                overflow: TextOverflow.ellipsis,
                style: Theme.of(context).textTheme.bodyMedium,
              ),
            ],
            const SizedBox(height: 8),
            Row(
              children: [
                Icon(
                  Icons.access_time,
                  size: 14,
                  color: Theme.of(context).colorScheme.onSurfaceVariant,
                ),
                const SizedBox(width: 4),
                Text(
                  article.timeAgo,
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(
                    color: Theme.of(context).colorScheme.onSurfaceVariant,
                  ),
                ),
                const Spacer(),
                if (aiAnalysis?.category != null)
                  Container(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 8,
                      vertical: 4,
                    ),
                    decoration: BoxDecoration(
                      color: Color(categoryColor).withOpacity(0.1),
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Text(
                      aiAnalysis!.category!,
                      style: Theme.of(context).textTheme.bodySmall?.copyWith(
                        color: Color(categoryColor),
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ),
              ],
            ),
            if (aiAnalysis != null) ...[
              const SizedBox(height: 8),
              Row(
                children: [
                  if (aiAnalysis.sentimentScore != null)
                    _buildSentimentChip(context, aiAnalysis.sentimentScore!),
                  const SizedBox(width: 8),
                  if (aiAnalysis.impactScore != null)
                    _buildImpactChip(context, aiAnalysis.impactScore!),
                ],
              ),
            ],
          ],
        ),
        onTap: () => Get.toNamed(
          AppRoutes.articleDetail.replaceAll(':id', article.id.toString()),
        ),
      ),
    );
  }

  Widget _buildSentimentChip(BuildContext context, double sentiment) {
    Color color;
    String text;
    IconData icon;
    
    if (sentiment > 0.1) {
      color = Colors.green;
      text = 'Tích cực';
      icon = Icons.trending_up;
    } else if (sentiment < -0.1) {
      color = Colors.red;
      text = 'Tiêu cực';
      icon = Icons.trending_down;
    } else {
      color = Colors.grey;
      text = 'Trung tính';
      icon = Icons.trending_flat;
    }

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: color.withOpacity(0.1),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon, size: 12, color: color),
          const SizedBox(width: 4),
          Text(
            text,
            style: TextStyle(
              fontSize: 11,
              color: color,
              fontWeight: FontWeight.w500,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildImpactChip(BuildContext context, double impact) {
    Color color;
    String text;
    
    if (impact >= 0.7) {
      color = Colors.red;
      text = 'Tác động cao';
    } else if (impact >= 0.4) {
      color = Colors.orange;
      text = 'Tác động TB';
    } else {
      color = Colors.green;
      text = 'Tác động thấp';
    }

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: color.withOpacity(0.1),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Text(
        text,
        style: TextStyle(
          fontSize: 11,
          color: color,
          fontWeight: FontWeight.w500,
        ),
      ),
    );
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\features\settings\settings_screen.dart ===== 
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:stock_tracker_app/src/features/settings/controllers/settings_controller.dart';
import 'package:stock_tracker_app/src/shared/widgets/loading_widget.dart';
import 'package:stock_tracker_app/src/shared/widgets/error_widget.dart';
import 'package:stock_tracker_app/src/shared/widgets/main_navigation.dart';

class SettingsScreen extends StatelessWidget {
  const SettingsScreen({super.key});

  @override
  Widget build(BuildContext context) {
    final settingsController = Get.put(SettingsController());

    return MainNavigation(
      child: Scaffold(
        appBar: AppBar(
          title: const Text('Cài đặt'),
          actions: [
            IconButton(
              icon: const Icon(Icons.refresh),
              onPressed: () => settingsController.refreshSettings(),
            ),
          ],
        ),
        body: Obx(() {
          if (settingsController.isLoading) {
            return const LoadingWidget(message: 'Đang tải cài đặt...');
          }
      
          if (settingsController.errorMessage.isNotEmpty) {
            return ErrorDisplayWidget(
              message: settingsController.errorMessage,
              onRetry: () => settingsController.refreshSettings(),
            );
          }
      
          return ListView(
            padding: const EdgeInsets.all(16),
            children: [
              // System Health Card
              _buildSystemHealthCard(context, settingsController),
              const SizedBox(height: 16),
      
              // System Statistics
              _buildSystemStatsCard(context, settingsController),
              const SizedBox(height: 16),
      
              // App Preferences
              _buildAppPreferencesCard(context, settingsController),
              const SizedBox(height: 16),
      
              // Crawl Sources Management
              _buildCrawlSourcesCard(context, settingsController),
              const SizedBox(height: 16),
      
              // System Actions
              _buildSystemActionsCard(context, settingsController),
              const SizedBox(height: 16),
      
              // App Info
              _buildAppInfoCard(context),
            ],
          );
        }),
      ),
    );
  }

  Widget _buildSystemHealthCard(BuildContext context, SettingsController controller) {
    final healthStatus = controller.systemHealthStatus;
    final healthColor = _getHealthColor(healthStatus);

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(Icons.health_and_safety, color: healthColor),
                const SizedBox(width: 12),
                Text(
                  'Tình trạng hệ thống',
                  style: Theme.of(context).textTheme.titleLarge?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const Spacer(),
                Container(
                  padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                  decoration: BoxDecoration(
                    color: healthColor.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(16),
                  ),
                  child: Text(
                    healthStatus,
                    style: TextStyle(
                      color: healthColor,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 16),
            
            // API Usage Indicator
            Row(
              children: [
                Text(
                  'API Usage: ${controller.systemStats['api_usage_today']}/${controller.systemStats['api_limit']}',
                  style: Theme.of(context).textTheme.bodyMedium,
                ),
                const Spacer(),
                Text(
                  '${controller.apiUsagePercentage.toStringAsFixed(1)}%',
                  style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 8),
            LinearProgressIndicator(
              value: controller.apiUsagePercentage / 100,
              backgroundColor: Colors.grey.withOpacity(0.3),
              valueColor: AlwaysStoppedAnimation<Color>(
                _getApiUsageColor(controller.apiUsagePercentage),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildSystemStatsCard(BuildContext context, SettingsController controller) {
    final stats = controller.systemStats;

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Thống kê hệ thống',
              style: Theme.of(context).textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            
            GridView.count(
              crossAxisCount: 2,
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              crossAxisSpacing: 16,
              mainAxisSpacing: 16,
              childAspectRatio: 2,
              children: [
                _buildStatItem(
                  context, 
                  'Tổng tin tức', 
                  '${stats['total_articles']}',
                  Icons.article_outlined,
                ),
                _buildStatItem(
                  context, 
                  'Công ty', 
                  '${stats['total_companies']}',
                  Icons.business_outlined,
                ),
                _buildStatItem(
                  context, 
                  'Có dữ liệu', 
                  '${stats['companies_with_data']}',
                  Icons.check_circle_outline,
                ),
                _buildStatItem(
                  context, 
                  'Watchlist', 
                  '${stats['watchlist_items']}',
                  Icons.bookmark_outline,
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildStatItem(BuildContext context, String title, String value, IconData icon) {
    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surfaceVariant.withOpacity(0.5),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(icon, size: 20),
              const Spacer(),
              Text(
                value,
                style: Theme.of(context).textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
              ),
            ],
          ),
          const SizedBox(height: 4),
          Text(
            title,
            style: Theme.of(context).textTheme.bodySmall,
          ),
        ],
      ),
    );
  }

  Widget _buildAppPreferencesCard(BuildContext context, SettingsController controller) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Tùy chọn ứng dụng',
              style: Theme.of(context).textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            
            SwitchListTile(
              title: const Text('Chế độ tối'),
              subtitle: const Text('Sử dụng theme màu tối'),
              value: controller.isDarkMode,
              onChanged: (value) => controller.toggleDarkMode(value),
              secondary: const Icon(Icons.dark_mode),
            ),
            
            SwitchListTile(
              title: const Text('Thông báo'),
              subtitle: const Text('Nhận thông báo khi có tin tức mới'),
              value: controller.enableNotifications,
              onChanged: (value) => controller.toggleNotifications(value),
              secondary: const Icon(Icons.notifications),
            ),
            
            SwitchListTile(
              title: const Text('Tự động cập nhật'),
              subtitle: const Text('Tự động làm mới dữ liệu'),
              value: controller.autoRefresh,
              onChanged: (value) => controller.toggleAutoRefresh(value),
              secondary: const Icon(Icons.refresh),
            ),
            
            ListTile(
              title: const Text('Khoảng cách cập nhật'),
              subtitle: Text('${controller.refreshInterval} phút'),
              leading: const Icon(Icons.timer),
              trailing: DropdownButton<int>(
                value: controller.refreshInterval,
                items: [5, 10, 15, 30, 60].map((minutes) {
                  return DropdownMenuItem(
                    value: minutes,
                    child: Text('$minutes phút'),
                  );
                }).toList(),
                onChanged: (value) {
                  if (value != null) {
                    controller.setRefreshInterval(value);
                  }
                },
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildCrawlSourcesCard(BuildContext context, SettingsController controller) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Quản lý nguồn crawl',
              style: Theme.of(context).textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 8),
            Text(
              '${controller.activeSources.length} hoạt động • ${controller.inactiveSources.length} tạm dừng',
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                color: Theme.of(context).colorScheme.onSurfaceVariant,
              ),
            ),
            const SizedBox(height: 16),
            
            if (controller.crawlSources.isEmpty)
              const Text('Chưa có nguồn crawl nào')
            else
              ListView.builder(
                shrinkWrap: true,
                physics: const NeverScrollableScrollPhysics(),
                itemCount: controller.crawlSources.take(5).length, // Chỉ hiển thị 5 nguồn đầu
                itemBuilder: (context, index) {
                  final source = controller.crawlSources[index];
                  return ListTile(
                    dense: true,
                    title: Text(
                      source.name,
                      style: const TextStyle(fontSize: 14),
                    ),
                    subtitle: Text(
                      'Crawl cuối: ${source.lastCrawledText}',
                      style: const TextStyle(fontSize: 12),
                    ),
                    trailing: Switch(
                      value: source.isActive,
                      onChanged: (value) => controller.toggleCrawlSource(
                        source.id, 
                        value,
                      ),
                    ),
                  );
                },
              ),
          ],
        ),
      ),
    );
  }

  Widget _buildSystemActionsCard(BuildContext context, SettingsController controller) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Thao tác hệ thống',
              style: Theme.of(context).textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            
            ListTile(
              title: const Text('Xóa cache'),
              subtitle: const Text('Xóa dữ liệu cache tạm thời'),
              leading: const Icon(Icons.clear_all),
              trailing: const Icon(Icons.arrow_forward_ios),
              onTap: () => controller.clearCache(),
            ),
            
            ListTile(
              title: const Text('Xuất dữ liệu'),
              subtitle: const Text('Xuất dữ liệu ra file'),
              leading: const Icon(Icons.download),
              trailing: const Icon(Icons.arrow_forward_ios),
              onTap: () => controller.exportData(),
            ),
            
            ListTile(
              title: const Text('Làm mới toàn bộ'),
              subtitle: const Text('Tải lại tất cả dữ liệu'),
              leading: const Icon(Icons.refresh),
              trailing: const Icon(Icons.arrow_forward_ios),
              onTap: () => controller.refreshSettings(),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildAppInfoCard(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Thông tin ứng dụng',
              style: Theme.of(context).textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            
            ListTile(
              title: const Text('Phiên bản'),
              subtitle: const Text('1.0.0'),
              leading: const Icon(Icons.info_outline),
            ),
            
            ListTile(
              title: const Text('Nhà phát triển'),
              subtitle: const Text('Nguyễn Văn Khuê'),
              leading: const Icon(Icons.person_outline),
            ),
            
            ListTile(
              title: const Text('Backend API'),
              subtitle: const Text('FastAPI + SQLite + AI'),
              leading: const Icon(Icons.api),
            ),
            
            ListTile(
              title: const Text('Liên hệ'),
              subtitle: const Text('khuengv332007@gmail.com'),
              leading: const Icon(Icons.email_outlined),
            ),
          ],
        ),
      ),
    );
  }

  Color _getHealthColor(String status) {
    switch (status) {
      case 'Tốt':
        return Colors.green;
      case 'Cảnh báo':
        return Colors.orange;
      case 'Lỗi':
        return Colors.red;
      default:
        return Colors.grey;
    }
  }

  Color _getApiUsageColor(double percentage) {
    if (percentage >= 90) return Colors.red;
    if (percentage >= 70) return Colors.orange;
    return Colors.green;
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\features\settings\bindings\settings_binding.dart ===== 
import 'package:get/get.dart';
import 'package:stock_tracker_app/src/features/settings/controllers/settings_controller.dart';

class SettingsBinding implements Bindings {
  @override
  void dependencies() {
    Get.lazyPut(() => SettingsController());
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\features\settings\controllers\settings_controller.dart ===== 
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:stock_tracker_app/src/shared/models/article_model.dart';
import 'package:stock_tracker_app/src/shared/models/watchlist_model.dart';
import 'package:stock_tracker_app/src/shared/repositories/articles_repository.dart';
import 'package:stock_tracker_app/src/shared/repositories/companies_repository.dart';
import 'package:stock_tracker_app/src/shared/repositories/watchlist_repository.dart';

class SettingsController extends GetxController {
  final ArticlesRepository _articlesRepository = Get.find<ArticlesRepository>();
  final CompaniesRepository _companiesRepository = Get.find<CompaniesRepository>();
  final WatchlistRepository _watchlistRepository = Get.find<WatchlistRepository>();

  final _isLoading = false.obs;
  final _errorMessage = ''.obs;

  // System stats
  final _systemStats = <String, dynamic>{}.obs;
  final _crawlSources = <CrawlSource>[].obs;

  // App preferences
  final _isDarkMode = false.obs;
  final _enableNotifications = true.obs;
  final _autoRefresh = true.obs;
  final _refreshInterval = 15.obs; // minutes

  // Getters
  bool get isLoading => _isLoading.value;
  String get errorMessage => _errorMessage.value;
  Map<String, dynamic> get systemStats => _systemStats.value;
  List<CrawlSource> get crawlSources => _crawlSources.value;
  bool get isDarkMode => _isDarkMode.value;
  bool get enableNotifications => _enableNotifications.value;
  bool get autoRefresh => _autoRefresh.value;
  int get refreshInterval => _refreshInterval.value;

  @override
  void onInit() {
    super.onInit();
    loadSettingsData();
  }

  Future<void> loadSettingsData() async {
    try {
      _isLoading.value = true;
      _errorMessage.value = '';

      await Future.wait([
        _loadSystemStats(),
        _loadCrawlSources(),
      ]);

    } catch (e) {
      _errorMessage.value = 'Failed to load settings: $e';
    } finally {
      _isLoading.value = false;
    }
  }

  Future<void> _loadSystemStats() async {
    try {
      // Load các thống kê hệ thống
      final articlesCount = await _articlesRepository.getArticlesCount();
      final dashboardData = await _companiesRepository.getDashboardOverview();
      final watchlistItems = await _watchlistRepository.getWatchlist();

      _systemStats.value = {
        'total_articles': articlesCount['total_articles'] ?? 0,
        'total_companies': dashboardData.totalCompanies,
        'companies_with_data': dashboardData.companiesWithData,
        'api_usage_today': dashboardData.apiUsageToday,
        'api_limit': dashboardData.apiLimit,
        'watchlist_items': watchlistItems.length,
        'last_updated': DateTime.now(),
      };
    } catch (e) {
      print('Error loading system stats: $e');
    }
  }

  Future<void> _loadCrawlSources() async {
    try {
      final sources = await _watchlistRepository.getCrawlSources();
      _crawlSources.value = sources;
    } catch (e) {
      print('Error loading crawl sources: $e');
    }
  }

  // App preferences methods
  void toggleDarkMode(bool value) {
    _isDarkMode.value = value;
    // Implement theme switching logic
    Get.changeThemeMode(value ? ThemeMode.dark : ThemeMode.light);
  }

  void toggleNotifications(bool value) {
    _enableNotifications.value = value;
    // Implement notification toggle logic
  }

  void toggleAutoRefresh(bool value) {
    _autoRefresh.value = value;
    // Implement auto refresh logic
  }

  void setRefreshInterval(int minutes) {
    _refreshInterval.value = minutes;
    // Implement refresh interval logic
  }

  // Crawl source management
  Future<void> toggleCrawlSource(int sourceId, bool isActive) async {
    try {
      await _watchlistRepository.updateCrawlSource(
        sourceId, 
        {'is_active': isActive}
      );
      
      // Update local state
      final index = _crawlSources.indexWhere((source) => source.id == sourceId);
      if (index != -1) {
        _crawlSources[index] = CrawlSource(
          id: _crawlSources[index].id,
          name: _crawlSources[index].name,
          url: _crawlSources[index].url,
          articleContainerSelector: _crawlSources[index].articleContainerSelector,
          titleSelector: _crawlSources[index].titleSelector,
          linkSelector: _crawlSources[index].linkSelector,
          summarySelector: _crawlSources[index].summarySelector,
          dateSelector: _crawlSources[index].dateSelector,
          isActive: isActive,
          lastCrawledAt: _crawlSources[index].lastCrawledAt,
          createdAt: _crawlSources[index].createdAt,
          updatedAt: DateTime.now(),
        );
        _crawlSources.refresh();
      }

      Get.snackbar(
        'Thành công',
        'Đã ${isActive ? "kích hoạt" : "tạm dừng"} nguồn crawl',
        snackPosition: SnackPosition.BOTTOM,
      );

    } catch (e) {
      Get.snackbar(
        'Lỗi',
        'Không thể cập nhật nguồn crawl: $e',
        snackPosition: SnackPosition.BOTTOM,
      );
    }
  }

  // System actions
  Future<void> clearCache() async {
    try {
      // Implement cache clearing logic
      Get.snackbar(
        'Thành công',
        'Đã xóa cache hệ thống',
        snackPosition: SnackPosition.BOTTOM,
      );
    } catch (e) {
      Get.snackbar(
        'Lỗi',
        'Không thể xóa cache: $e',
        snackPosition: SnackPosition.BOTTOM,
      );
    }
  }

  Future<void> exportData() async {
    try {
      // Implement data export logic
      Get.snackbar(
        'Thông báo',
        'Tính năng xuất dữ liệu sẽ có trong phiên bản tới',
        snackPosition: SnackPosition.BOTTOM,
      );
    } catch (e) {
      Get.snackbar(
        'Lỗi',
        'Không thể xuất dữ liệu: $e',
        snackPosition: SnackPosition.BOTTOM,
      );
    }
  }

  Future<void> refreshSettings() async {
    await loadSettingsData();
  }

  // Computed properties
  List<CrawlSource> get activeSources {
    return _crawlSources.where((source) => source.isActive).toList();
  }

  List<CrawlSource> get inactiveSources {
    return _crawlSources.where((source) => !source.isActive).toList();
  }

  double get apiUsagePercentage {
    final usage = _systemStats['api_usage_today'] ?? 0;
    final limit = _systemStats['api_limit'] ?? 250;
    return limit > 0 ? (usage / limit) * 100 : 0;
  }

  String get systemHealthStatus {
    final apiUsage = apiUsagePercentage;
    final activeSourcesCount = activeSources.length;
    
    if (apiUsage > 90) return 'Cảnh báo';
    if (activeSourcesCount == 0) return 'Lỗi';
    return 'Tốt';
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\features\watchlist\watchlist_screen.dart ===== 
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:stock_tracker_app/src/features/watchlist/controllers/watchlist_controller.dart';
import 'package:stock_tracker_app/src/shared/widgets/loading_widget.dart';
import 'package:stock_tracker_app/src/shared/widgets/error_widget.dart';
import 'package:stock_tracker_app/src/shared/widgets/empty_widget.dart';
import 'package:stock_tracker_app/src/shared/widgets/main_navigation.dart';

class WatchlistScreen extends StatelessWidget {
  const WatchlistScreen({super.key});

  @override
  Widget build(BuildContext context) {
    final watchlistController = Get.find<WatchlistController>();

    return MainNavigation(
      child: Scaffold(
        appBar: AppBar(
          title: const Text('Watchlist & Nguồn'),
          actions: [
            IconButton(
              icon: const Icon(Icons.add),
              onPressed: () => watchlistController.showAddItemDialog(),
              tooltip: 'Thêm item mới',
            ),
            IconButton(
              icon: const Icon(Icons.refresh),
              onPressed: () => watchlistController.loadWatchlistData(),
            ),
          ],
        ),
        body: Obx(() {
          if (watchlistController.isLoading) {
            return const LoadingWidget(message: 'Đang tải watchlist...');
          }
      
          if (watchlistController.errorMessage.isNotEmpty) {
            return ErrorDisplayWidget(
              message: watchlistController.errorMessage,
              onRetry: () => watchlistController.loadWatchlistData(),
            );
          }
      
          return RefreshIndicator(
            onRefresh: () => watchlistController.loadWatchlistData(),
            child: SingleChildScrollView(
              physics: const AlwaysScrollableScrollPhysics(),
              child: Padding(
                padding: const EdgeInsets.all(16),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Watchlist Summary
                    _buildWatchlistSummary(context, watchlistController),
                    const SizedBox(height: 24),
      
                    // Watchlist Items
                    _buildWatchlistSection(context, watchlistController),
                    const SizedBox(height: 24),
      
                    // Crawl Sources
                    _buildCrawlSourcesSection(context, watchlistController),
                  ],
                ),
              ),
            ),
          );
        }),
      ),
    );
  }

  Widget _buildWatchlistSummary(BuildContext context, WatchlistController controller) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Tổng quan Watchlist',
              style: Theme.of(context).textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            Row(
              children: [
                Expanded(
                  child: _buildSummaryCard(
                    context,
                    'Từ khóa',
                    '${controller.keywordItems.length}',
                    Icons.search,
                    Colors.blue,
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: _buildSummaryCard(
                    context,
                    'Mã CK',
                    '${controller.stockSymbolItems.length}',
                    Icons.show_chart,
                    Colors.green,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 16),
            Row(
              children: [
                Expanded(
                  child: _buildSummaryCard(
                    context,
                    'Nguồn active',
                    '${controller.activeSources.length}',
                    Icons.source,
                    Colors.orange,
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: _buildSummaryCard(
                    context,
                    'Nguồn inactive',
                    '${controller.inactiveSources.length}',
                    Icons.pause_circle,
                    Colors.grey,
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildSummaryCard(
    BuildContext context,
    String title,
    String value,
    IconData icon,
    Color color,
  ) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: color.withOpacity(0.1),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: color.withOpacity(0.3)),
      ),
      child: Column(
        children: [
          Icon(icon, color: color, size: 24),
          const SizedBox(height: 8),
          Text(
            value,
            style: Theme.of(context).textTheme.headlineSmall?.copyWith(
              color: color,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 4),
          Text(
            title,
            style: Theme.of(context).textTheme.bodySmall?.copyWith(
              color: Theme.of(context).colorScheme.onSurfaceVariant,
            ),
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }

  Widget _buildWatchlistSection(BuildContext context, WatchlistController controller) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text(
              'Watchlist Items (${controller.watchlistItems.length})',
              style: Theme.of(context).textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            TextButton.icon(
              onPressed: () => controller.showAddItemDialog(),
              icon: const Icon(Icons.add),
              label: const Text('Thêm'),
            ),
          ],
        ),
        const SizedBox(height: 16),
        
        if (controller.watchlistItems.isEmpty)
          const EmptyWidget(
            title: 'Chưa có item nào',
            subtitle: 'Thêm từ khóa hoặc mã chứng khoán để theo dõi',
            icon: Icons.bookmark_outline,
          )
        else
          ListView.builder(
            shrinkWrap: true,
            physics: const NeverScrollableScrollPhysics(),
            itemCount: controller.watchlistItems.length,
            itemBuilder: (context, index) {
              final item = controller.watchlistItems[index];
              return _buildWatchlistItem(context, item, controller);
            },
          ),
      ],
    );
  }

  Widget _buildWatchlistItem(BuildContext context, item, WatchlistController controller) {
    final isKeyword = item.isKeyword;
    final color = isKeyword ? Colors.blue : Colors.green;
    
    return Card(
      margin: const EdgeInsets.only(bottom: 8),
      child: ListTile(
        leading: CircleAvatar(
          backgroundColor: color.withOpacity(0.1),
          child: Icon(
            isKeyword ? Icons.search : Icons.show_chart,
            color: color,
          ),
        ),
        title: Text(
          item.itemValue,
          style: Theme.of(context).textTheme.titleMedium?.copyWith(
            fontWeight: FontWeight.w600,
          ),
        ),
        subtitle: Text(
          isKeyword ? 'Từ khóa' : 'Mã chứng khoán',
          style: Theme.of(context).textTheme.bodySmall?.copyWith(
            color: color,
          ),
        ),
        trailing: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(
              _formatDate(item.createdAt),
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                color: Theme.of(context).colorScheme.onSurfaceVariant,
              ),
            ),
            const SizedBox(width: 8),
            IconButton(
              icon: const Icon(Icons.delete_outline, color: Colors.red),
              onPressed: () => _showDeleteConfirmation(
                context, 
                item, 
                controller,
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildCrawlSourcesSection(BuildContext context, WatchlistController controller) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Nguồn Crawl (${controller.crawlSources.length})',
          style: Theme.of(context).textTheme.titleLarge?.copyWith(
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: 16),
        
        if (controller.crawlSources.isEmpty)
          const EmptyWidget(
            title: 'Chưa có nguồn crawl',
            subtitle: 'Cần cấu hình nguồn crawl trong hệ thống',
            icon: Icons.source,
          )
        else
          ListView.builder(
            shrinkWrap: true,
            physics: const NeverScrollableScrollPhysics(),
            itemCount: controller.crawlSources.length,
            itemBuilder: (context, index) {
              final source = controller.crawlSources[index];
              return _buildCrawlSourceItem(context, source, controller);
            },
          ),
      ],
    );
  }

  Widget _buildCrawlSourceItem(BuildContext context, source, WatchlistController controller) {
    return Card(
      margin: const EdgeInsets.only(bottom: 8),
      child: ListTile(
        leading: CircleAvatar(
          backgroundColor: source.isActive 
              ? Colors.green.withOpacity(0.1) 
              : Colors.grey.withOpacity(0.1),
          child: Icon(
            source.isActive ? Icons.play_arrow : Icons.pause,
            color: source.isActive ? Colors.green : Colors.grey,
          ),
        ),
        title: Text(
          source.name,
          style: Theme.of(context).textTheme.titleMedium?.copyWith(
            fontWeight: FontWeight.w600,
          ),
        ),
        subtitle: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              source.url,
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                color: Theme.of(context).colorScheme.onSurfaceVariant,
              ),
              maxLines: 1,
              overflow: TextOverflow.ellipsis,
            ),
            const SizedBox(height: 4),
            Text(
              'Crawl cuối: ${source.lastCrawledText}',
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                color: Theme.of(context).colorScheme.onSurfaceVariant,
              ),
            ),
          ],
        ),
        trailing: Switch(
          value: source.isActive,
          onChanged: (value) => controller.updateCrawlSourceStatus(
            source.id, 
            value,
          ),
        ),
        isThreeLine: true,
      ),
    );
  }

  void _showDeleteConfirmation(
    BuildContext context, 
    item, 
    WatchlistController controller,
  ) {
    Get.dialog(
      AlertDialog(
        title: const Text('Xác nhận xóa'),
        content: Text('Bạn có chắc muốn xóa "${item.itemValue}" khỏi watchlist?'),
        actions: [
          TextButton(
            onPressed: () => Get.back(),
            child: const Text('Hủy'),
          ),
          ElevatedButton(
            onPressed: () {
              Get.back();
              controller.deleteWatchlistItem(item.id);
            },
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.red,
              foregroundColor: Colors.white,
            ),
            child: const Text('Xóa'),
          ),
        ],
      ),
    );
  }

  String _formatDate(DateTime date) {
    return '${date.day}/${date.month}/${date.year}';
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\features\watchlist\bindings\watchlist_binding.dart ===== 
import 'package:get/get.dart';
import 'package:stock_tracker_app/src/features/watchlist/controllers/watchlist_controller.dart';

class WatchlistBinding implements Bindings {
  @override
  void dependencies() {
    Get.lazyPut(() => WatchlistController());
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\features\watchlist\controllers\watchlist_controller.dart ===== 
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:stock_tracker_app/src/shared/models/watchlist_model.dart';
import 'package:stock_tracker_app/src/shared/repositories/watchlist_repository.dart';
import 'package:stock_tracker_app/src/shared/utils/app_constants.dart';

class WatchlistController extends GetxController {
  final WatchlistRepository _repository = Get.find<WatchlistRepository>();

  final _watchlistItems = <WatchlistItem>[].obs;
  final _crawlSources = <CrawlSource>[].obs;
  final _isLoading = false.obs;
  final _errorMessage = ''.obs;

  // Getters
  List<WatchlistItem> get watchlistItems => _watchlistItems.value;
  List<CrawlSource> get crawlSources => _crawlSources.value;
  bool get isLoading => _isLoading.value;
  String get errorMessage => _errorMessage.value;

  @override
  void onInit() {
    super.onInit();
    loadWatchlistData();
  }

  Future<void> loadWatchlistData() async {
    try {
      _isLoading.value = true;
      _errorMessage.value = '';

      // Load watchlist và crawl sources song song
      await Future.wait([
        _loadWatchlistItems(),
        _loadCrawlSources(),
      ]);

    } catch (e) {
      _errorMessage.value = 'Failed to load watchlist data: $e';
    } finally {
      _isLoading.value = false;
    }
  }

  Future<void> _loadWatchlistItems() async {
    try {
      final items = await _repository.getWatchlist();
      _watchlistItems.value = items;
    } catch (e) {
      print('Failed to load watchlist items: $e');
    }
  }

  Future<void> _loadCrawlSources() async {
    try {
      final sources = await _repository.getCrawlSources();
      _crawlSources.value = sources;
    } catch (e) {
      print('Failed to load crawl sources: $e');
    }
  }

  Future<void> addWatchlistItem({
    required String itemType,
    required String itemValue,
  }) async {
    try {
      // Validate input
      if (itemValue.trim().isEmpty) {
        Get.snackbar('Lỗi', 'Vui lòng nhập giá trị');
        return;
      }

      // Check duplicate
      final isDuplicate = _watchlistItems.any((item) =>
          item.itemType == itemType && 
          item.itemValue.toLowerCase() == itemValue.toLowerCase());

      if (isDuplicate) {
        Get.snackbar('Cảnh báo', 'Item này đã có trong watchlist');
        return;
      }

      final newItem = WatchlistItem(
        id: 0, // Will be set by backend
        userId: AppConstants.userId,
        itemType: itemType,
        itemValue: itemValue.trim(),
        createdAt: DateTime.now(),
      );

      final createdItem = await _repository.addWatchlistItem(newItem);
      
      // Add to local list
      _watchlistItems.add(createdItem);
      
      Get.snackbar(
        'Thành công', 
        'Đã thêm "${itemValue}" vào watchlist',
        snackPosition: SnackPosition.BOTTOM,
      );

    } catch (e) {
      Get.snackbar(
        'Lỗi', 
        'Không thể thêm item: $e',
        snackPosition: SnackPosition.BOTTOM,
      );
    }
  }

  Future<void> deleteWatchlistItem(int itemId) async {
    try {
      await _repository.deleteWatchlistItem(itemId);
      
      // Remove from local list
      _watchlistItems.removeWhere((item) => item.id == itemId);
      
      Get.snackbar(
        'Thành công', 
        'Đã xóa item khỏi watchlist',
        snackPosition: SnackPosition.BOTTOM,
      );

    } catch (e) {
      Get.snackbar(
        'Lỗi', 
        'Không thể xóa item: $e',
        snackPosition: SnackPosition.BOTTOM,
      );
    }
  }

  Future<void> updateCrawlSourceStatus(int sourceId, bool isActive) async {
    try {
      await _repository.updateCrawlSource(sourceId, {'is_active': isActive});
      
      // Update local state
      final index = _crawlSources.indexWhere((source) => source.id == sourceId);
      if (index != -1) {
        _crawlSources[index] = CrawlSource(
          id: _crawlSources[index].id,
          name: _crawlSources[index].name,
          url: _crawlSources[index].url,
          articleContainerSelector: _crawlSources[index].articleContainerSelector,
          titleSelector: _crawlSources[index].titleSelector,
          linkSelector: _crawlSources[index].linkSelector,
          summarySelector: _crawlSources[index].summarySelector,
          dateSelector: _crawlSources[index].dateSelector,
          isActive: isActive,
          lastCrawledAt: _crawlSources[index].lastCrawledAt,
          createdAt: _crawlSources[index].createdAt,
          updatedAt: DateTime.now(),
        );
        _crawlSources.refresh();
      }

      Get.snackbar(
        'Thành công', 
        'Đã ${isActive ? "kích hoạt" : "tạm dừng"} nguồn crawl',
        snackPosition: SnackPosition.BOTTOM,
      );

    } catch (e) {
      Get.snackbar(
        'Lỗi', 
        'Không thể cập nhật trạng thái: $e',
        snackPosition: SnackPosition.BOTTOM,
      );
    }
  }

  void showAddItemDialog() {
    final typeController = TextEditingController();
    final valueController = TextEditingController();
    String selectedType = 'KEYWORD';

    Get.dialog(
      AlertDialog(
        title: const Text('Thêm Watchlist Item'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            DropdownButtonFormField<String>(
              value: selectedType,
              decoration: const InputDecoration(
                labelText: 'Loại',
                border: OutlineInputBorder(),
              ),
              items: const [
                DropdownMenuItem(value: 'KEYWORD', child: Text('Từ khóa')),
                DropdownMenuItem(value: 'STOCK_SYMBOL', child: Text('Mã cổ phiếu')),
              ],
              onChanged: (value) {
                selectedType = value!;
              },
            ),
            const SizedBox(height: 16),
            TextField(
              controller: valueController,
              decoration: const InputDecoration(
                labelText: 'Giá trị',
                hintText: 'VD: AAPL hoặc "lãi suất"',
                border: OutlineInputBorder(),
              ),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Get.back(),
            child: const Text('Hủy'),
          ),
          ElevatedButton(
            onPressed: () {
              Get.back();
              addWatchlistItem(
                itemType: selectedType,
                itemValue: valueController.text,
              );
            },
            child: const Text('Thêm'),
          ),
        ],
      ),
    );
  }

  // Analytics getters
  List<WatchlistItem> get keywordItems {
    return _watchlistItems.where((item) => item.isKeyword).toList();
  }

  List<WatchlistItem> get stockSymbolItems {
    return _watchlistItems.where((item) => item.isStockSymbol).toList();
  }

  List<CrawlSource> get activeSources {
    return _crawlSources.where((source) => source.isActive).toList();
  }

  List<CrawlSource> get inactiveSources {
    return _crawlSources.where((source) => !source.isActive).toList();
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\shared\bindings\initial_binding.dart ===== 
import 'package:get/get.dart';
import 'package:stock_tracker_app/src/shared/services/dio_client.dart';
import 'package:stock_tracker_app/src/shared/services/articles_api_service.dart';
import 'package:stock_tracker_app/src/shared/services/ai_analysis_api_service.dart'; // ✅ THÊM
import 'package:stock_tracker_app/src/shared/services/companies_api_service.dart';
import 'package:stock_tracker_app/src/shared/services/watchlist_api_service.dart';
import 'package:stock_tracker_app/src/shared/repositories/articles_repository.dart';
import 'package:stock_tracker_app/src/shared/repositories/companies_repository.dart';
import 'package:stock_tracker_app/src/shared/repositories/watchlist_repository.dart';
import 'package:stock_tracker_app/src/shared/controllers/navigation_controller.dart';

class InitialBinding implements Bindings {
  @override
  void dependencies() {
    // 🎯 Core UI Controllers
    Get.lazyPut(() => NavigationController(), fenix: true);
    
    // 🔧 Core Dependencies
    Get.lazyPut(() => DioClient.createDio(), fenix: true);

    // 🌐 API Services
    Get.lazyPut(() => ArticlesApiService(Get.find()), fenix: true);
    Get.lazyPut(() => AIAnalysisApiService(Get.find()), fenix: true); // ✅ THÊM
    Get.lazyPut(() => CompaniesApiService(Get.find()), fenix: true);
    Get.lazyPut(() => WatchlistApiService(Get.find()), fenix: true);

    // 📁 Repositories
    Get.lazyPut(() => ArticlesRepository(Get.find(), Get.find()), fenix: true); // ✅ SỬA: 2 services
    Get.lazyPut(() => CompaniesRepository(Get.find()), fenix: true);
    Get.lazyPut(() => WatchlistRepository(Get.find()), fenix: true);

    print("✅ InitialBinding: Tất cả dependencies đã được inject");
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\shared\controllers\navigation_controller.dart ===== 
import 'package:get/get.dart';
import 'package:stock_tracker_app/src/shared/utils/app_routes.dart';

class NavigationController extends GetxController {
  final _selectedIndex = 0.obs;
  
  int get selectedIndex => _selectedIndex.value;
  
  void updateIndex(int index) {
    _selectedIndex.value = index;
    _navigateToRoute(index);
  }
  
  void _navigateToRoute(int index) {
    switch (index) {
      case 0:
        Get.offAllNamed(AppRoutes.dashboard);
        break;
      case 1:
        Get.offAllNamed(AppRoutes.articles);
        break;
      case 2:
        Get.offAllNamed(AppRoutes.companies);
        break;
      case 3:
        Get.offAllNamed(AppRoutes.watchlist);
        break;
      case 4:
        Get.offAllNamed(AppRoutes.analytics);
        break;
    }
  }
  
  void setSelectedIndexByRoute(String route) {
    if (route.startsWith(AppRoutes.dashboard)) {
      _selectedIndex.value = 0;
    } else if (route.startsWith(AppRoutes.articles)) {
      _selectedIndex.value = 1;
    } else if (route.startsWith(AppRoutes.companies)) {
      _selectedIndex.value = 2;
    } else if (route.startsWith(AppRoutes.watchlist)) {
      _selectedIndex.value = 3;
    } else if (route.startsWith(AppRoutes.analytics)) {
      _selectedIndex.value = 4;
    } else {
      _selectedIndex.value = 0;
    }
  }
  
  @override
  void onInit() {
    super.onInit();
    // Set initial index based on current route
    setSelectedIndexByRoute(Get.currentRoute);
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\shared\models\ai_analysis_model.dart ===== 
import 'dart:convert';

class AIAnalysis {
  final int id;
  final int articleId;
  final String? summary;
  final String? category;
  final double? sentimentScore;
  final double? impactScore;
  final List<String>? keywordsExtracted;
  final Map<String, dynamic>? analysisMetadata;
  final DateTime createdAt;
  final DateTime updatedAt;

  AIAnalysis({
    required this.id,
    required this.articleId,
    this.summary,
    this.category,
    this.sentimentScore,
    this.impactScore,
    this.keywordsExtracted,
    this.analysisMetadata,
    required this.createdAt,
    required this.updatedAt,
  });

  factory AIAnalysis.fromJson(Map<String, dynamic> json) {
    // ✅ SỬA: Handle keywords_extracted
    List<String>? keywords;
    if (json['keywords_extracted'] != null) {
      if (json['keywords_extracted'] is List) {
        keywords = List<String>.from(json['keywords_extracted']);
      }
    }

    // ✅ SỬA: Handle analysis_metadata - có thể là string JSON hoặc object
    Map<String, dynamic>? analysisMetadata;
    if (json['analysis_metadata'] != null) {
      if (json['analysis_metadata'] is String) {
        // Nếu là string JSON, parse nó
        try {
          analysisMetadata = jsonDecode(json['analysis_metadata']) as Map<String, dynamic>;
        } catch (e) {
          print('Error parsing analysis_metadata: $e');
          analysisMetadata = null;
        }
      } else if (json['analysis_metadata'] is Map<String, dynamic>) {
        // Nếu đã là object, sử dụng trực tiếp
        analysisMetadata = json['analysis_metadata'] as Map<String, dynamic>;
      }
    }

    return AIAnalysis(
      id: json['id'],
      articleId: json['article_id'],
      summary: json['summary'],
      category: json['category'],
      sentimentScore: json['sentiment_score']?.toDouble(),
      impactScore: json['impact_score']?.toDouble(),
      keywordsExtracted: keywords,
      analysisMetadata: analysisMetadata,
      createdAt: DateTime.parse(json['created_at']),
      updatedAt: DateTime.parse(json['updated_at']),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'article_id': articleId,
      'summary': summary,
      'category': category,
      'sentiment_score': sentimentScore,
      'impact_score': impactScore,
      'keywords_extracted': keywordsExtracted,
      'analysis_metadata': analysisMetadata != null 
          ? jsonEncode(analysisMetadata) 
          : null,
      'created_at': createdAt.toIso8601String(),
      'updated_at': updatedAt.toIso8601String(),
    };
  }

  // Helper getters
  String get sentimentText {
    if (sentimentScore == null) return 'N/A';
    if (sentimentScore! > 0.1) return 'Tích cực';
    if (sentimentScore! < -0.1) return 'Tiêu cực';
    return 'Trung tính';
  }

  String get impactText {
    if (impactScore == null) return 'N/A';
    if (impactScore! >= 0.7) return 'Cao';
    if (impactScore! >= 0.4) return 'Trung bình';
    return 'Thấp';
  }

  // ✅ THÊM: Getters để access analysis_metadata dễ dàng
  String? get sentimentFromMetadata {
    return analysisMetadata?['sentiment'] as String?;
  }

  String? get impactLevelFromMetadata {
    return analysisMetadata?['impact_level'] as String?;
  }

  List<String>? get keyEntitiesFromMetadata {
    final entities = analysisMetadata?['key_entities'];
    if (entities is List) {
      return List<String>.from(entities);
    }
    return null;
  }

  String? get analysisSummaryFromMetadata {
    return analysisMetadata?['analysis_summary'] as String?;
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\shared\models\article_model.dart ===== 
import 'package:intl/intl.dart';

class Article {
  final int id;
  final String title;
  final String url;
  final String? summary;
  final String? publishedDateStr;
  final String sourceUrl;
  final String? contentHash;
  final DateTime createdAt;
  final DateTime updatedAt;

  Article({
    required this.id,
    required this.title,
    required this.url,
    this.summary,
    this.publishedDateStr,
    required this.sourceUrl,
    this.contentHash,
    required this.createdAt,
    required this.updatedAt,
  });

  factory Article.fromJson(Map<String, dynamic> json) {
    return Article(
      id: json['id'],
      title: json['title'],
      url: json['url'],
      summary: json['summary'],
      publishedDateStr: json['published_date_str'],
      sourceUrl: json['source_url'],
      contentHash: json['content_hash'],
      createdAt: DateTime.parse(json['created_at']),
      updatedAt: DateTime.parse(json['updated_at']),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'title': title,
      'url': url,
      'summary': summary,
      'published_date_str': publishedDateStr,
      'source_url': sourceUrl,
      'content_hash': contentHash,
      'created_at': createdAt.toIso8601String(),
      'updated_at': updatedAt.toIso8601String(),
    };
  }

  // ✅ THÊM: Helper getter cho time ago
  String get timeAgo {
    final now = DateTime.now();
    final difference = now.difference(createdAt);

    if (difference.inDays > 0) {
      return '${difference.inDays} ngày trước';
    } else if (difference.inHours > 0) {
      return '${difference.inHours} giờ trước';
    } else if (difference.inMinutes > 0) {
      return '${difference.inMinutes} phút trước';
    } else {
      return 'Vừa xong';
    }
  }

  // ✅ THÊM: Helper getter cho formatted date
  String get formattedDate {
    final formatter = DateFormat('dd/MM/yyyy HH:mm');
    return formatter.format(createdAt);
  }
}.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\shared\models\article_with_analysis_model.dart ===== 
import 'article_model.dart';
import 'ai_analysis_model.dart';

class ArticleWithAnalysis {
  final Article article;
  final AIAnalysis? aiAnalysis;

  ArticleWithAnalysis({
    required this.article,
    this.aiAnalysis,
  });

  factory ArticleWithAnalysis.fromJson(Map<String, dynamic> json) {
    return ArticleWithAnalysis(
      article: Article.fromJson(json),
      aiAnalysis: json['ai_analysis'] != null 
          ? AIAnalysis.fromJson(json['ai_analysis']) 
          : null,
    );
  }

  // Convenience getters
  String? get category => aiAnalysis?.category;
  double? get sentimentScore => aiAnalysis?.sentimentScore;
  double? get impactScore => aiAnalysis?.impactScore;
  String get sentimentText => aiAnalysis?.sentimentText ?? 'N/A';
  String get impactText => aiAnalysis?.impactText ?? 'N/A';
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\shared\models\company_model.dart ===== 
class Company {
  final int id;
  final String symbol;
  final String companyName;
  final String? sector;
  final String? industry;
  final String country;
  final String? website;
  final String? description;
  final bool isActive;
  final DateTime createdAt;
  final DateTime updatedAt;

  Company({
    required this.id,
    required this.symbol,
    required this.companyName,
    this.sector,
    this.industry,
    this.country = 'US',
    this.website,
    this.description,
    required this.isActive,
    required this.createdAt,
    required this.updatedAt,
  });

  factory Company.fromJson(Map<String, dynamic> json) {
    return Company(
      id: json['id'],
      symbol: json['symbol'],
      companyName: json['company_name'],
      sector: json['sector'],
      industry: json['industry'],
      country: json['country'] ?? 'US',
      website: json['website'],
      description: json['description'],
      isActive: json['is_active'],
      createdAt: DateTime.parse(json['created_at']),
      updatedAt: DateTime.parse(json['updated_at']),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'symbol': symbol,
      'company_name': companyName,
      'sector': sector,
      'industry': industry,
      'country': country,
      'website': website,
      'description': description,
      'is_active': isActive,
      'created_at': createdAt.toIso8601String(),
      'updated_at': updatedAt.toIso8601String(),
    };
  }
}

class CompanyMetrics {
  final int id;
  final int companyId;
  final String symbol;
  final double? peRatio;
  final double? pbRatio;
  final double? priceToSalesRatio;
  final int? marketCap;
  final double? eps;
  final int? revenue;
  final int? netIncome;
  final double? roe;
  final double? roa;
  final int? grossProfit;
  final int? operatingIncome;
  final int? ebitda;
  final double? debtToEquity;
  final double? currentRatio;
  final double? quickRatio;
  final double? cashRatio;
  final double? debtRatio;
  final double? grossProfitMargin;
  final double? operatingProfitMargin;
  final double? netProfitMargin;
  final double? operatingCashFlowRatio;
  final int? sharesOutstanding;
  final double? revenuePerShare;
  final double? netIncomePerShare;
  final String dataSource;
  final DateTime recordedAt;
  final DateTime createdAt;

  CompanyMetrics({
    required this.id,
    required this.companyId,
    required this.symbol,
    this.peRatio,
    this.pbRatio,
    this.priceToSalesRatio,
    this.marketCap,
    this.eps,
    this.revenue,
    this.netIncome,
    this.roe,
    this.roa,
    this.grossProfit,
    this.operatingIncome,
    this.ebitda,
    this.debtToEquity,
    this.currentRatio,
    this.quickRatio,
    this.cashRatio,
    this.debtRatio,
    this.grossProfitMargin,
    this.operatingProfitMargin,
    this.netProfitMargin,
    this.operatingCashFlowRatio,
    this.sharesOutstanding,
    this.revenuePerShare,
    this.netIncomePerShare,
    this.dataSource = 'FMP',
    required this.recordedAt,
    required this.createdAt,
  });

  factory CompanyMetrics.fromJson(Map<String, dynamic> json) {
    return CompanyMetrics(
      id: json['id'],
      companyId: json['company_id'],
      symbol: json['symbol'],
      peRatio: json['pe_ratio']?.toDouble(),
      pbRatio: json['pb_ratio']?.toDouble(),
      priceToSalesRatio: json['price_to_sales_ratio']?.toDouble(),
      marketCap: json['market_cap'],
      eps: json['eps']?.toDouble(),
      revenue: json['revenue'],
      netIncome: json['net_income'],
      roe: json['roe']?.toDouble(),
      roa: json['roa']?.toDouble(),
      grossProfit: json['gross_profit'],
      operatingIncome: json['operating_income'],
      ebitda: json['ebitda'],
      debtToEquity: json['debt_to_equity']?.toDouble(),
      currentRatio: json['current_ratio']?.toDouble(),
      quickRatio: json['quick_ratio']?.toDouble(),
      cashRatio: json['cash_ratio']?.toDouble(),
      debtRatio: json['debt_ratio']?.toDouble(),
      grossProfitMargin: json['gross_profit_margin']?.toDouble(),
      operatingProfitMargin: json['operating_profit_margin']?.toDouble(),
      netProfitMargin: json['net_profit_margin']?.toDouble(),
      operatingCashFlowRatio: json['operating_cash_flow_ratio']?.toDouble(),
      sharesOutstanding: json['shares_outstanding'],
      revenuePerShare: json['revenue_per_share']?.toDouble(),
      netIncomePerShare: json['net_income_per_share']?.toDouble(),
      dataSource: json['data_source'] ?? 'FMP',
      recordedAt: DateTime.parse(json['recorded_at']),
      createdAt: DateTime.parse(json['created_at']),
    );
  }

  String get formattedMarketCap {
    if (marketCap == null) return 'N/A';
    if (marketCap! >= 1000000000) {
      return '\$${(marketCap! / 1000000000).toStringAsFixed(1)}B';
    } else if (marketCap! >= 1000000) {
      return '\$${(marketCap! / 1000000).toStringAsFixed(1)}M';
    }
    return '\$${marketCap}';
  }

  String get formattedRevenue {
    if (revenue == null) return 'N/A';
    if (revenue! >= 1000000000) {
      return '\$${(revenue! / 1000000000).toStringAsFixed(1)}B';
    } else if (revenue! >= 1000000) {
      return '\$${(revenue! / 1000000).toStringAsFixed(1)}M';
    }
    return '\$${revenue}';
  }
}

// Data class để combine company với latest metrics (từ dashboard API)
class CompanyWithMetrics {
  final Company company;
  final CompanyMetrics? latestMetrics;

  CompanyWithMetrics({
    required this.company,
    this.latestMetrics,
  });

  factory CompanyWithMetrics.fromJson(Map<String, dynamic> json) {
    return CompanyWithMetrics(
      company: Company.fromJson(json['company']),
      latestMetrics: json['latest_metrics'] != null 
          ? CompanyMetrics.fromJson(json['latest_metrics'])
          : null,
    );
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\shared\models\dashboard_model.dart ===== 
// Model cho dashboard overview API
class DashboardData {
  final int totalCompanies;
  final int companiesWithData;
  final int companiesWithoutData;
  final int apiUsageToday;
  final int apiLimit;
  final List<CompanySummary> companies;

  DashboardData({
    required this.totalCompanies,
    required this.companiesWithData,
    required this.companiesWithoutData,
    required this.apiUsageToday,
    required this.apiLimit,
    required this.companies,
  });

  factory DashboardData.fromJson(Map<String, dynamic> json) {
    return DashboardData(
      totalCompanies: json['total_companies'],
      companiesWithData: json['companies_with_data'],
      companiesWithoutData: json['companies_without_data'],
      apiUsageToday: json['api_usage_today'],
      apiLimit: json['api_limit'],
      companies: (json['companies'] as List)
          .map((e) => CompanySummary.fromJson(e))
          .toList(),
    );
  }

  double get apiUsagePercentage => 
      apiLimit > 0 ? (apiUsageToday / apiLimit) * 100 : 0;
}

class CompanySummary {
  final String symbol;
  final String companyName;
  final String? sector;
  final bool isActive;
  final DateTime? lastUpdated;
  final double? peRatio;
  final int? marketCap;

  CompanySummary({
    required this.symbol,
    required this.companyName,
    this.sector,
    required this.isActive,
    this.lastUpdated,
    this.peRatio,
    this.marketCap,
  });

  factory CompanySummary.fromJson(Map<String, dynamic> json) {
    return CompanySummary(
      symbol: json['symbol'],
      companyName: json['company_name'],
      sector: json['sector'],
      isActive: json['is_active'],
      lastUpdated: json['last_updated'] != null
          ? DateTime.parse(json['last_updated'])
          : null,
      peRatio: json['pe_ratio']?.toDouble(),
      marketCap: json['market_cap'],
    );
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\shared\models\watchlist_model.dart ===== 
class WatchlistItem {
  final int id;
  final String userId;
  final String itemType; // 'STOCK_SYMBOL' hoặc 'KEYWORD'
  final String itemValue;
  final DateTime createdAt;

  WatchlistItem({
    required this.id,
    required this.userId,
    required this.itemType,
    required this.itemValue,
    required this.createdAt,
  });

  factory WatchlistItem.fromJson(Map<String, dynamic> json) {
    return WatchlistItem(
      id: json['id'],
      userId: json['user_id'],
      itemType: json['item_type'],
      itemValue: json['item_value'],
      createdAt: DateTime.parse(json['created_at']),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'user_id': userId,
      'item_type': itemType,
      'item_value': itemValue,
      'created_at': createdAt.toIso8601String(),
    };
  }

  Map<String, dynamic> toCreateJson() {
    return {
      'item_type': itemType,
      'item_value': itemValue,
    };
  }

  bool get isKeyword => itemType == 'KEYWORD';
  bool get isStockSymbol => itemType == 'STOCK_SYMBOL';

  String get displayText {
    if (isKeyword) {
      return '🔍 $itemValue';
    } else {
      return '📈 $itemValue';
    }
  }
}

class CrawlSource {
  final int id;
  final String name;
  final String url;
  final String articleContainerSelector;
  final String titleSelector;
  final String linkSelector;
  final String? summarySelector;
  final String? dateSelector;
  final bool isActive;
  final DateTime? lastCrawledAt;
  final DateTime createdAt;
  final DateTime updatedAt;

  CrawlSource({
    required this.id,
    required this.name,
    required this.url,
    required this.articleContainerSelector,
    required this.titleSelector,
    required this.linkSelector,
    this.summarySelector,
    this.dateSelector,
    required this.isActive,
    this.lastCrawledAt,
    required this.createdAt,
    required this.updatedAt,
  });

  factory CrawlSource.fromJson(Map<String, dynamic> json) {
    return CrawlSource(
      id: json['id'],
      name: json['name'],
      url: json['url'],
      articleContainerSelector: json['article_container_selector'],
      titleSelector: json['title_selector'],
      linkSelector: json['link_selector'],
      summarySelector: json['summary_selector'],
      dateSelector: json['date_selector'],
      isActive: json['is_active'],
      lastCrawledAt: json['last_crawled_at'] != null
          ? DateTime.parse(json['last_crawled_at'])
          : null,
      createdAt: DateTime.parse(json['created_at']),
      updatedAt: DateTime.parse(json['updated_at']),
    );
  }

  String get statusText => isActive ? 'Hoạt động' : 'Tạm dừng';
  String get lastCrawledText {
    if (lastCrawledAt == null) return 'Chưa crawl';
    final now = DateTime.now();
    final difference = now.difference(lastCrawledAt!);
    
    if (difference.inDays > 0) {
      return '${difference.inDays} ngày trước';
    } else if (difference.inHours > 0) {
      return '${difference.inHours} giờ trước';
    } else if (difference.inMinutes > 0) {
      return '${difference.inMinutes} phút trước';
    } else {
      return 'Vừa xong';
    }
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\shared\repositories\articles_repository.dart ===== 
import 'package:stock_tracker_app/src/shared/models/article_model.dart';
import 'package:stock_tracker_app/src/shared/models/ai_analysis_model.dart';
import 'package:stock_tracker_app/src/shared/models/article_with_analysis_model.dart';
import 'package:stock_tracker_app/src/shared/services/articles_api_service.dart';
import 'package:stock_tracker_app/src/shared/services/ai_analysis_api_service.dart';

class ArticlesRepository {
  final ArticlesApiService _articlesApiService;
  final AIAnalysisApiService _aiAnalysisApiService;

  ArticlesRepository(this._articlesApiService, this._aiAnalysisApiService);

  // ✅ SỬA: Method fetch articles with analysis
  Future<List<ArticleWithAnalysis>> getArticlesWithAnalysis({
    int skip = 0, 
    int limit = 20
  }) async {
    // 1. Fetch articles first - trả về List<Article>
    final articles = await _articlesApiService.fetchArticles(skip: skip, limit: limit);
    
    // 2. Fetch AI analysis for each article
    List<ArticleWithAnalysis> articlesWithAnalysis = [];
    
    // ✅ SỬA: articles đã là List<Article>, không cần Article.fromJson
    for (final article in articles) {
      try {
        final aiAnalysis = await _aiAnalysisApiService.getAIAnalysisForArticle(article.id);
        articlesWithAnalysis.add(ArticleWithAnalysis(
          article: article,
          aiAnalysis: aiAnalysis,
        ));
      } catch (e) {
        // Nếu không fetch được AI analysis, vẫn thêm article
        articlesWithAnalysis.add(ArticleWithAnalysis(
          article: article,
          aiAnalysis: null,
        ));
      }
    }
    
    return articlesWithAnalysis;
  }

  Future<List<ArticleWithAnalysis>> getHighImpactArticles({
    double minImpact = 0.7,
  }) async {
    return await _aiAnalysisApiService.getHighImpactArticles(minImpact: minImpact);
  }

  // ✅ SỬA: Method fetch by category
  Future<List<ArticleWithAnalysis>> getArticlesByCategory(String category) async {
    return await _aiAnalysisApiService.getArticlesByCategory(category);
  }

  // ✅ SỬA: Method fetch single article with analysis
  Future<ArticleWithAnalysis?> getArticleWithAnalysis(int articleId) async {
    try {
      // fetchArticleById trả về Article, không phải Map
      final article = await _articlesApiService.fetchArticleById(articleId);
      
      final aiAnalysis = await _aiAnalysisApiService.getAIAnalysisForArticle(articleId);
      
      return ArticleWithAnalysis(
        article: article, // ✅ SỬA: Không cần Article.fromJson
        aiAnalysis: aiAnalysis,
      );
    } catch (e) {
      throw Exception('Failed to load article with analysis: $e');
    }
  }

  // ✅ SỬA: Basic methods - sửa kiểu trả về cho đúng với service
  Future<List<Article>> getArticles({int skip = 0, int limit = 20}) async {
    return await _articlesApiService.fetchArticles(skip: skip, limit: limit);
  }

  Future<Article> getArticleById(int id) async {
    return await _articlesApiService.fetchArticleById(id);
  }

  Future<Map<String, dynamic>> getArticlesCount() async {
    return await _articlesApiService.fetchArticlesCount();
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\shared\repositories\companies_repository.dart ===== 
import 'package:stock_tracker_app/src/shared/models/company_model.dart';
import 'package:stock_tracker_app/src/shared/models/dashboard_model.dart';
import 'package:stock_tracker_app/src/shared/services/companies_api_service.dart';

class CompaniesRepository {
  final CompaniesApiService _apiService;

  CompaniesRepository(this._apiService);

  Future<List<Company>> getCompanies({
    int skip = 0,
    int limit = 50,
    bool activeOnly = true,
  }) async {
    return await _apiService.fetchCompanies(
      skip: skip,
      limit: limit,
      activeOnly: activeOnly,
    );
  }

  Future<Company> getCompanyBySymbol(String symbol) async {
    return await _apiService.fetchCompanyBySymbol(symbol);
  }

  Future<List<CompanyMetrics>> getCompanyMetricsHistory(
    String symbol, {
    int limit = 10,
  }) async {
    return await _apiService.fetchCompanyMetricsHistory(symbol, limit: limit);
  }

  Future<CompanyMetrics> getLatestMetrics(String symbol) async {
    return await _apiService.fetchLatestMetrics(symbol);
  }

  Future<Map<String, dynamic>> fetchMetricsForCompany(String symbol) async {
    return await _apiService.fetchMetricsForCompany(symbol);
  }

  Future<DashboardData> getDashboardOverview() async {
    return await _apiService.fetchDashboardOverview();
  }

  Future<Company> createCompany(Map<String, dynamic> companyData) async {
    return await _apiService.createCompany(companyData);
  }

  Future<Company> updateCompany(String symbol, Map<String, dynamic> updateData) async {
    return await _apiService.updateCompany(symbol, updateData);
  }

  Future<void> deleteCompany(String symbol) async {
    return await _apiService.deleteCompany(symbol);
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\shared\repositories\watchlist_repository.dart ===== 
import 'package:stock_tracker_app/src/shared/models/watchlist_model.dart';
import 'package:stock_tracker_app/src/shared/services/watchlist_api_service.dart';

class WatchlistRepository {
  final WatchlistApiService _apiService;

  WatchlistRepository(this._apiService);

  Future<List<WatchlistItem>> getWatchlist() async {
    return await _apiService.fetchWatchlist();
  }

  Future<WatchlistItem> addWatchlistItem(WatchlistItem item) async {
    return await _apiService.addWatchlistItem(item);
  }

  Future<void> deleteWatchlistItem(int itemId) async {
    return await _apiService.deleteWatchlistItem(itemId);
  }

  Future<List<CrawlSource>> getCrawlSources({bool? isActive}) async {
    return await _apiService.fetchCrawlSources(isActive: isActive);
  }

  Future<CrawlSource> updateCrawlSource(int sourceId, Map<String, dynamic> updateData) async {
    return await _apiService.updateCrawlSource(sourceId, updateData);
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\shared\services\ai_analysis_api_service.dart ===== 
import 'package:dio/dio.dart';
import 'package:stock_tracker_app/src/shared/models/ai_analysis_model.dart';
import 'package:stock_tracker_app/src/shared/models/article_with_analysis_model.dart';
import 'package:stock_tracker_app/src/shared/utils/app_constants.dart';

class AIAnalysisApiService {
  final Dio _dio;
  
  AIAnalysisApiService(this._dio);

  Future<AIAnalysis?> getAIAnalysisForArticle(int articleId) async {
    try {
      final response = await _dio.get('${AppConstants.aiAnalysisEndpoint}/article/$articleId');
      
      if (response.statusCode == 200) {
        return AIAnalysis.fromJson(response.data);
      }
      return null;
    } catch (e) {
      if (e is DioException && e.response?.statusCode == 404) {
        // Không có AI analysis cho article này
        return null;
      }
      throw Exception('Failed to load AI analysis: $e');
    }
  }

  Future<List<ArticleWithAnalysis>> getHighImpactArticles({
    double minImpact = 0.7,
  }) async {
    try {
      final response = await _dio.get(
        '${AppConstants.aiAnalysisEndpoint}/high-impact',
        queryParameters: {'min_impact': minImpact},
      );

      if (response.statusCode == 200) {
        final List<dynamic> data = response.data;
        return data.map((json) => ArticleWithAnalysis.fromJson(json)).toList();
      }
      throw Exception('Failed to load high impact articles');
    } catch (e) {
      throw Exception('Failed to load high impact articles: $e');
    }
  }

  Future<List<ArticleWithAnalysis>> getArticlesByCategory(String category) async {
    try {
      final response = await _dio.get('${AppConstants.aiAnalysisEndpoint}/category/$category');

      if (response.statusCode == 200) {
        final List<dynamic> data = response.data;
        return data.map((json) => ArticleWithAnalysis.fromJson(json)).toList();
      }
      throw Exception('Failed to load articles by category');
    } catch (e) {
      throw Exception('Failed to load articles by category: $e');
    }
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\shared\services\articles_api_service.dart ===== 
import 'package:dio/dio.dart';
import 'package:stock_tracker_app/src/shared/models/ai_analysis_model.dart';
import 'package:stock_tracker_app/src/shared/models/article_model.dart';
import 'package:stock_tracker_app/src/shared/utils/app_constants.dart';

class ArticlesApiService {
  final Dio _dio;

  ArticlesApiService(this._dio);

  Future<List<Article>> fetchArticles({
    int skip = AppConstants.defaultSkip,
    int limit = AppConstants.defaultLimit,
  }) async {
    try {
      final response = await _dio.get(
        AppConstants.articlesEndpoint,
        queryParameters: {
          'skip': skip,
          'limit': limit,
        },
      );

      if (response.statusCode == 200) {
        final List<dynamic> data = response.data;
        return data.map((json) => Article.fromJson(json)).toList();
      } else {
        throw Exception('Failed to load articles: ${response.statusCode}');
      }
    } on DioException catch (e) {
      throw Exception('Network error: ${e.message}');
    } catch (e) {
      throw Exception('Unexpected error: $e');
    }
  }

  Future<Article> fetchArticleById(int id) async {
    try {
      final response = await _dio.get('${AppConstants.articlesEndpoint}/$id');
      
      if (response.statusCode == 200) {
        return Article.fromJson(response.data);
      } else {
        throw Exception('Failed to load article: ${response.statusCode}');
      }
    } on DioException catch (e) {
      throw Exception('Network error: ${e.message}');
    } catch (e) {
      throw Exception('Unexpected error: $e');
    }
  }

  Future<Map<String, dynamic>> fetchArticlesCount() async {
    try {
      final response = await _dio.get(AppConstants.articlesCountEndpoint);
      
      if (response.statusCode == 200) {
        return response.data;
      } else {
        throw Exception('Failed to load articles count: ${response.statusCode}');
      }
    } on DioException catch (e) {
      throw Exception('Network error: ${e.message}');
    } catch (e) {
      throw Exception('Unexpected error: $e');
    }
  }

  Future<List<Article>> fetchArticlesByCategory(String category) async {
    try {
      final response = await _dio.get(
        '${AppConstants.aiAnalysisEndpoint}/category/$category'
      );
      
      if (response.statusCode == 200) {
        final List<dynamic> data = response.data;
        return data.map((json) => Article.fromJson(json)).toList();
      } else {
        throw Exception('Failed to load articles by category: ${response.statusCode}');
      }
    } on DioException catch (e) {
      throw Exception('Network error: ${e.message}');
    } catch (e) {
      throw Exception('Unexpected error: $e');
    }
  }

  Future<List<Article>> fetchHighImpactArticles({double minImpact = 0.7}) async {
    try {
      final response = await _dio.get(
        '${AppConstants.aiAnalysisEndpoint}/high-impact',
        queryParameters: {'min_impact': minImpact},
      );
      
      if (response.statusCode == 200) {
        final List<dynamic> data = response.data;
        return data.map((json) => Article.fromJson(json)).toList();
      } else {
        throw Exception('Failed to load high impact articles: ${response.statusCode}');
      }
    } on DioException catch (e) {
      throw Exception('Network error: ${e.message}');
    } catch (e) {
      throw Exception('Unexpected error: $e');
    }
  }

  Future<AIAnalysis> fetchAIAnalysis(int articleId) async {
    try {
      final response = await _dio.get(
        '${AppConstants.aiAnalysisEndpoint}/article/$articleId'
      );
      
      if (response.statusCode == 200) {
        return AIAnalysis.fromJson(response.data);
      } else {
        throw Exception('Failed to load AI analysis: ${response.statusCode}');
      }
    } on DioException catch (e) {
      throw Exception('Network error: ${e.message}');
    } catch (e) {
      throw Exception('Unexpected error: $e');
    }
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\shared\services\companies_api_service.dart ===== 
import 'package:dio/dio.dart';
import 'package:stock_tracker_app/src/shared/models/company_model.dart';
import 'package:stock_tracker_app/src/shared/models/dashboard_model.dart';
import 'package:stock_tracker_app/src/shared/utils/app_constants.dart';

class CompaniesApiService {
  final Dio _dio;

  CompaniesApiService(this._dio);

  Future<List<Company>> fetchCompanies({
    int skip = 0,
    int limit = 50,
    bool activeOnly = true,
  }) async {
    try {
      final response = await _dio.get(
        AppConstants.companiesEndpoint,
        queryParameters: {
          'skip': skip,
          'limit': limit,
          'active_only': activeOnly,
        },
      );

      if (response.statusCode == 200) {
        final List<dynamic> data = response.data;
        return data.map((json) => Company.fromJson(json)).toList();
      } else {
        throw Exception('Failed to load companies: ${response.statusCode}');
      }
    } on DioException catch (e) {
      throw Exception('Network error: ${e.message}');
    } catch (e) {
      throw Exception('Unexpected error: $e');
    }
  }

  Future<Company> fetchCompanyBySymbol(String symbol) async {
    try {
      final response = await _dio.get('${AppConstants.companiesEndpoint}/$symbol');
      
      if (response.statusCode == 200) {
        return Company.fromJson(response.data);
      } else {
        throw Exception('Failed to load company: ${response.statusCode}');
      }
    } on DioException catch (e) {
      throw Exception('Network error: ${e.message}');
    } catch (e) {
      throw Exception('Unexpected error: $e');
    }
  }

  Future<List<CompanyMetrics>> fetchCompanyMetricsHistory(
    String symbol, {
    int limit = 10,
  }) async {
    try {
      final response = await _dio.get(
        '${AppConstants.companiesEndpoint}/$symbol/metrics',
        queryParameters: {'limit': limit},
      );
      
      if (response.statusCode == 200) {
        final List<dynamic> data = response.data;
        return data.map((json) => CompanyMetrics.fromJson(json)).toList();
      } else {
        throw Exception('Failed to load company metrics: ${response.statusCode}');
      }
    } on DioException catch (e) {
      throw Exception('Network error: ${e.message}');
    } catch (e) {
      throw Exception('Unexpected error: $e');
    }
  }

  Future<CompanyMetrics> fetchLatestMetrics(String symbol) async {
    try {
      final response = await _dio.get(
        '${AppConstants.companiesEndpoint}/$symbol/metrics/latest'
      );
      
      if (response.statusCode == 200) {
        return CompanyMetrics.fromJson(response.data);
      } else {
        throw Exception('Failed to load latest metrics: ${response.statusCode}');
      }
    } on DioException catch (e) {
      throw Exception('Network error: ${e.message}');
    } catch (e) {
      throw Exception('Unexpected error: $e');
    }
  }

  Future<Map<String, dynamic>> fetchMetricsForCompany(String symbol) async {
    try {
      final response = await _dio.post(
        '${AppConstants.companiesEndpoint}/$symbol/fetch-metrics'
      );
      
      if (response.statusCode == 200) {
        return response.data;
      } else {
        throw Exception('Failed to fetch metrics: ${response.statusCode}');
      }
    } on DioException catch (e) {
      throw Exception('Network error: ${e.message}');
    } catch (e) {
      throw Exception('Unexpected error: $e');
    }
  }

  Future<DashboardData> fetchDashboardOverview() async {
    try {
      final response = await _dio.get(AppConstants.companiesDashboardEndpoint);
      
      if (response.statusCode == 200) {
        return DashboardData.fromJson(response.data);
      } else {
        throw Exception('Failed to load dashboard data: ${response.statusCode}');
      }
    } on DioException catch (e) {
      throw Exception('Network error: ${e.message}');
    } catch (e) {
      throw Exception('Unexpected error: $e');
    }
  }

  Future<Company> createCompany(Map<String, dynamic> companyData) async {
    try {
      final response = await _dio.post(
        AppConstants.companiesEndpoint,
        data: companyData,
      );
      
      if (response.statusCode == 201) {
        return Company.fromJson(response.data);
      } else {
        throw Exception('Failed to create company: ${response.statusCode}');
      }
    } on DioException catch (e) {
      throw Exception('Network error: ${e.message}');
    } catch (e) {
      throw Exception('Unexpected error: $e');
    }
  }

  Future<Company> updateCompany(String symbol, Map<String, dynamic> updateData) async {
    try {
      final response = await _dio.put(
        '${AppConstants.companiesEndpoint}/$symbol',
        data: updateData,
      );
      
      if (response.statusCode == 200) {
        return Company.fromJson(response.data);
      } else {
        throw Exception('Failed to update company: ${response.statusCode}');
      }
    } on DioException catch (e) {
      throw Exception('Network error: ${e.message}');
    } catch (e) {
      throw Exception('Unexpected error: $e');
    }
  }

  Future<void> deleteCompany(String symbol) async {
    try {
      final response = await _dio.delete('${AppConstants.companiesEndpoint}/$symbol');
      
      if (response.statusCode != 200) {
        throw Exception('Failed to delete company: ${response.statusCode}');
      }
    } on DioException catch (e) {
      throw Exception('Network error: ${e.message}');
    } catch (e) {
      throw Exception('Unexpected error: $e');
    }
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\shared\services\dio_client.dart ===== 
import 'package:dio/dio.dart';
import 'package:dio_smart_retry/dio_smart_retry.dart';
import 'package:stock_tracker_app/src/shared/utils/app_constants.dart';
import 'package:stock_tracker_app/src/shared/utils/config.dart';
import 'package:stock_tracker_app/src/shared/utils/debug_helper.dart';

class DioClient {
  static Dio createDio() {
    final dio = Dio(BaseOptions(
      baseUrl: Config.baseUrl,
      connectTimeout: Config.apiTimeout,
      receiveTimeout: Config.apiTimeout,
      sendTimeout: Config.apiTimeout,
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    ));

    // Only add logging interceptor in development
    if (Config.enableLogging) {
      dio.interceptors.add(LogInterceptor(
        requestBody: true,
        responseBody: false,
        logPrint: (object) {
          DebugHelper.log(object.toString(), tag: 'DIO');
        },
      ));
    }

    // Error handling interceptor
    dio.interceptors.add(InterceptorsWrapper(
      onError: (error, handler) {
        DebugHelper.logError('Dio Error: ${error.message}', tag: 'DIO');
        return handler.next(error);
      },
    ));

    dio.interceptors.add(RetryInterceptor(
      dio: dio,
      logPrint: print,
      retries: 3,
      retryDelays: const [
        Duration(seconds: 1),
        Duration(seconds: 2),
        Duration(seconds: 3),
      ],
    ));

    return dio;
  }
}.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\shared\services\watchlist_api_service.dart ===== 
import 'package:dio/dio.dart';
import 'package:stock_tracker_app/src/shared/models/watchlist_model.dart';
import 'package:stock_tracker_app/src/shared/utils/app_constants.dart';

class WatchlistApiService {
  final Dio _dio;

  WatchlistApiService(this._dio);

  Future<List<WatchlistItem>> fetchWatchlist() async {
    try {
      final response = await _dio.get(AppConstants.watchlistEndpoint);
      
      if (response.statusCode == 200) {
        final List<dynamic> data = response.data;
        return data.map((json) => WatchlistItem.fromJson(json)).toList();
      } else {
        throw Exception('Failed to load watchlist: ${response.statusCode}');
      }
    } on DioException catch (e) {
      throw Exception('Network error: ${e.message}');
    } catch (e) {
      throw Exception('Unexpected error: $e');
    }
  }

  Future<WatchlistItem> addWatchlistItem(WatchlistItem item) async {
    try {
      final response = await _dio.post(
        AppConstants.watchlistEndpoint,
        data: item.toCreateJson(),
      );
      
      if (response.statusCode == 201) {
        return WatchlistItem.fromJson(response.data);
      } else {
        throw Exception('Failed to add watchlist item: ${response.statusCode}');
      }
    } on DioException catch (e) {
      throw Exception('Network error: ${e.message}');
    } catch (e) {
      throw Exception('Unexpected error: $e');
    }
  }

  Future<void> deleteWatchlistItem(int itemId) async {
    try {
      final response = await _dio.delete('${AppConstants.watchlistEndpoint}/$itemId');
      
      if (response.statusCode != 200) {
        throw Exception('Failed to delete watchlist item: ${response.statusCode}');
      }
    } on DioException catch (e) {
      throw Exception('Network error: ${e.message}');
    } catch (e) {
      throw Exception('Unexpected error: $e');
    }
  }

  Future<List<CrawlSource>> fetchCrawlSources({bool? isActive}) async {
    try {
      final queryParams = <String, dynamic>{};
      if (isActive != null) {
        queryParams['is_active'] = isActive;
      }
      
      final response = await _dio.get(
        AppConstants.crawlSourcesEndpoint,
        queryParameters: queryParams,
      );
      
      if (response.statusCode == 200) {
        final List<dynamic> data = response.data;
        return data.map((json) => CrawlSource.fromJson(json)).toList();
      } else {
        throw Exception('Failed to load crawl sources: ${response.statusCode}');
      }
    } on DioException catch (e) {
      throw Exception('Network error: ${e.message}');
    } catch (e) {
      throw Exception('Unexpected error: $e');
    }
  }

  Future<CrawlSource> updateCrawlSource(int sourceId, Map<String, dynamic> updateData) async {
    try {
      final response = await _dio.put(
        '${AppConstants.crawlSourcesEndpoint}/$sourceId',
        data: updateData,
      );
      
      if (response.statusCode == 200) {
        return CrawlSource.fromJson(response.data);
      } else {
        throw Exception('Failed to update crawl source: ${response.statusCode}');
      }
    } on DioException catch (e) {
      throw Exception('Network error: ${e.message}');
    } catch (e) {
      throw Exception('Unexpected error: $e');
    }
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\shared\utils\api_helper.dart ===== 
import 'package:dio/dio.dart';
import 'package:get/get.dart';

class ApiException implements Exception {
  final String message;
  final int? statusCode;
  final String? errorCode;

  ApiException({
    required this.message,
    this.statusCode,
    this.errorCode,
  });

  @override
  String toString() => 'ApiException: $message';
}

class ApiHelper {
  static void handleError(dynamic error) {
    String message = 'Đã xảy ra lỗi không xác định';
    
    if (error is DioException) {
      switch (error.type) {
        case DioExceptionType.connectionTimeout:
        case DioExceptionType.sendTimeout:
        case DioExceptionType.receiveTimeout:
          message = 'Kết nối timeout. Vui lòng thử lại.';
          break;
        case DioExceptionType.badResponse:
          if (error.response?.statusCode == 404) {
            message = 'Không tìm thấy dữ liệu.';
          } else if (error.response?.statusCode == 500) {
            message = 'Lỗi server. Vui lòng thử lại sau.';
          } else {
            message = 'Lỗi HTTP ${error.response?.statusCode}';
          }
          break;
        case DioExceptionType.connectionError:
          message = 'Không thể kết nối đến server. Kiểm tra kết nối mạng.';
          break;
        default:
          message = error.message ?? 'Lỗi không xác định';
      }
    } else if (error is ApiException) {
      message = error.message;
    } else {
      message = error.toString();
    }

    Get.snackbar(
      'Lỗi',
      message,
      snackPosition: SnackPosition.BOTTOM,
      backgroundColor: Get.theme.colorScheme.error.withOpacity(0.1),
      colorText: Get.theme.colorScheme.error,
      duration: const Duration(seconds: 5),
    );
  }

  static void showSuccess(String message) {
    Get.snackbar(
      'Thành công',
      message,
      snackPosition: SnackPosition.BOTTOM,
      backgroundColor: Get.theme.colorScheme.primary.withOpacity(0.1),
      colorText: Get.theme.colorScheme.primary,
      duration: const Duration(seconds: 3),
    );
  }

  static void showInfo(String message) {
    Get.snackbar(
      'Thông tin',
      message,
      snackPosition: SnackPosition.BOTTOM,
      backgroundColor: Get.theme.colorScheme.surfaceVariant,
      colorText: Get.theme.colorScheme.onSurfaceVariant,
      duration: const Duration(seconds: 3),
    );
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\shared\utils\app_constants.dart ===== 
class AppConstants {
  static const String appName = 'Stock News Tracking System';
  
  static const String baseUrl = 'http://stock-news.local:8082/api/v1';

  static const String devBaseUrl = 'http://stock-news.local:8082/api/v1';

  static String get apiBaseUrl {
    const bool isProduction = bool.fromEnvironment('dart.vm.product');
    return isProduction ? baseUrl : devBaseUrl;
  } 
  
  // User ID cố định (như backend)
  static const String userId = 'ong_x';
  
  // API Endpoints (dựa trên backend thực tế)
  static const String articlesEndpoint = '/articles';
  static const String articlesCountEndpoint = '/articles/count';
  static const String companiesEndpoint = '/companies';
  static const String companiesDashboardEndpoint = '/companies/overview/dashboard';
  static const String watchlistEndpoint = '/users/${userId}/watchlist';
  static const String crawlSourcesEndpoint = '/crawl-sources';
  static const String aiAnalysisEndpoint = '/ai-analysis';
  
  // Pagination
  static const int defaultLimit = 20;
  static const int defaultSkip = 0;
  
  // Colors
  static const primaryColor = 0xFF2196F3;
  static const secondaryColor = 0xFF03DAC6;
  static const errorColor = 0xFFB00020;
  static const successColor = 0xFF4CAF50;
  
  // Category colors (cho AI analysis)
  static const Map<String, int> categoryColors = {
    'Địa chính trị': 0xFFE57373,
    'Chính sách tiền tệ': 0xFF81C784,
    'Chính sách tài khóa': 0xFF64B5F6,
    'Giá vàng': 0xFFFFD54F,
    'Tỷ giá USD': 0xFFBA68C8,
    'Tin tức doanh nghiệp': 0xFF4DB6AC,
    'Thị trường chung': 0xFF90A4AE,
    'Không liên quan': 0xFFBCBCBC,
  };
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\shared\utils\app_pages.dart ===== 
import 'package:get/get.dart';
import 'package:stock_tracker_app/src/features/dashboard/dashboard_screen.dart';
import 'package:stock_tracker_app/src/features/articles/articles_list_screen.dart';
import 'package:stock_tracker_app/src/features/articles/article_detail_screen.dart';
import 'package:stock_tracker_app/src/features/companies/companies_list_screen.dart';
import 'package:stock_tracker_app/src/features/companies/company_detail_screen.dart';
import 'package:stock_tracker_app/src/features/watchlist/watchlist_screen.dart';
import 'package:stock_tracker_app/src/features/analytics/analytics_screen.dart';
import 'package:stock_tracker_app/src/features/settings/settings_screen.dart';

// Bindings
import 'package:stock_tracker_app/src/features/dashboard/bindings/dashboard_binding.dart';
import 'package:stock_tracker_app/src/features/articles/bindings/articles_binding.dart';
import 'package:stock_tracker_app/src/features/articles/bindings/article_detail_binding.dart';
import 'package:stock_tracker_app/src/features/companies/bindings/companies_binding.dart';
import 'package:stock_tracker_app/src/features/companies/bindings/company_detail_binding.dart';
import 'package:stock_tracker_app/src/features/watchlist/bindings/watchlist_binding.dart';
import 'package:stock_tracker_app/src/features/analytics/bindings/analytics_binding.dart';
import 'package:stock_tracker_app/src/features/settings/bindings/settings_binding.dart';

import 'package:stock_tracker_app/src/shared/utils/app_routes.dart';

class AppPages {
  static const initial = AppRoutes.dashboard;

  static final routes = [
    GetPage(
      name: AppRoutes.dashboard,
      page: () => const DashboardScreen(),
      binding: DashboardBinding(),
    ),
    GetPage(
      name: AppRoutes.articles,
      page: () => const ArticlesListScreen(),
      binding: ArticlesBinding(),
    ),
    GetPage(
      name: AppRoutes.articleDetail,
      page: () => const ArticleDetailScreen(),
      binding: ArticleDetailBinding(),
    ),
    GetPage(
      name: AppRoutes.companies,
      page: () => const CompaniesListScreen(),
      binding: CompaniesBinding(),
    ),
    GetPage(
      name: AppRoutes.companyDetail,
      page: () => const CompanyDetailScreen(),
      binding: CompanyDetailBinding(),
    ),
    GetPage(
      name: AppRoutes.watchlist,
      page: () => const WatchlistScreen(),
      binding: WatchlistBinding(),
    ),
    GetPage(
      name: AppRoutes.analytics,
      page: () => const AnalyticsScreen(),
      binding: AnalyticsBinding(),
    ),
    GetPage(
      name: AppRoutes.settings,
      page: () => const SettingsScreen(),
      binding: SettingsBinding(),
    ),
  ];
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\shared\utils\app_routes.dart ===== 
class AppRoutes {
  static const String dashboard = '/dashboard';
  static const String articles = '/articles';
  static const String articleDetail = '/articles/:id';
  static const String companies = '/companies';
  static const String companyDetail = '/companies/:symbol';
  static const String watchlist = '/watchlist';
  static const String analytics = '/analytics';
  static const String settings = '/settings';
}.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\shared\utils\cache_helper.dart ===== 
import 'dart:convert';
import 'package:shared_preferences/shared_preferences.dart';

class CacheHelper {
  static SharedPreferences? _prefs;
  
  static Future<void> init() async {
    _prefs = await SharedPreferences.getInstance();
  }

  // Cache data với expiration time
  static Future<void> cacheData(String key, dynamic data, {Duration? expiration}) async {
    if (_prefs == null) await init();
    
    final jsonString = jsonEncode(data);
    await _prefs!.setString(key, jsonString);
    
    // Lưu timestamp
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    await _prefs!.setInt('${key}_timestamp', timestamp);
    
    // Lưu expiration nếu có
    if (expiration != null) {
      final expirationTime = timestamp + expiration.inMilliseconds;
      await _prefs!.setInt('${key}_expiration', expirationTime);
    }
  }

  // Get cached data với auto expiration check
  static T? getCachedData<T>(
    String key, 
    T Function(Map<String, dynamic>) fromJson, {
    Duration? maxAge,
  }) {
    if (_prefs == null) return null;
    
    final jsonString = _prefs!.getString(key);
    if (jsonString == null) return null;
    
    // Check expiration từ cache
    final expirationTime = _prefs!.getInt('${key}_expiration');
    if (expirationTime != null && DateTime.now().millisecondsSinceEpoch > expirationTime) {
      clearCache(key);
      return null;
    }
    
    // Check max age nếu được specify
    if (maxAge != null) {
      final timestamp = _prefs!.getInt('${key}_timestamp') ?? 0;
      final age = DateTime.now().millisecondsSinceEpoch - timestamp;
      if (age > maxAge.inMilliseconds) {
        clearCache(key);
        return null;
      }
    }
    
    try {
      final jsonData = jsonDecode(jsonString);
      if (jsonData is Map<String, dynamic>) {
        return fromJson(jsonData);
      } else if (jsonData is List) {
        // Handle list data
        return jsonData as T;
      }
      return null;
    } catch (e) {
      clearCache(key);
      return null;
    }
  }

  // Get cached list data
  static List<T>? getCachedListData<T>(
    String key, 
    T Function(Map<String, dynamic>) fromJson, {
    Duration? maxAge,
  }) {
    if (_prefs == null) return null;
    
    final jsonString = _prefs!.getString(key);
    if (jsonString == null) return null;
    
    // Check expiration
    if (maxAge != null) {
      final timestamp = _prefs!.getInt('${key}_timestamp') ?? 0;
      final age = DateTime.now().millisecondsSinceEpoch - timestamp;
      if (age > maxAge.inMilliseconds) {
        clearCache(key);
        return null;
      }
    }
    
    try {
      final jsonData = jsonDecode(jsonString);
      if (jsonData is List) {
        return jsonData
            .map((item) => fromJson(item as Map<String, dynamic>))
            .toList();
      }
      return null;
    } catch (e) {
      clearCache(key);
      return null;
    }
  }

  // Cache simple values
  static Future<void> cacheString(String key, String value) async {
    if (_prefs == null) await init();
    await _prefs!.setString(key, value);
  }

  static Future<void> cacheInt(String key, int value) async {
    if (_prefs == null) await init();
    await _prefs!.setInt(key, value);
  }

  static Future<void> cacheBool(String key, bool value) async {
    if (_prefs == null) await init();
    await _prefs!.setBool(key, value);
  }

  static Future<void> cacheDouble(String key, double value) async {
    if (_prefs == null) await init();
    await _prefs!.setDouble(key, value);
  }

  // Get simple values
  static String? getString(String key) {
    return _prefs?.getString(key);
  }

  static int? getInt(String key) {
    return _prefs?.getInt(key);
  }

  static bool? getBool(String key) {
    return _prefs?.getBool(key);
  }

  static double? getDouble(String key) {
    return _prefs?.getDouble(key);
  }

  // Clear specific cache
  static Future<void> clearCache(String key) async {
    if (_prefs == null) await init();
    await _prefs!.remove(key);
    await _prefs!.remove('${key}_timestamp');
    await _prefs!.remove('${key}_expiration');
  }

  // Clear all cache
  static Future<void> clearAllCache() async {
    if (_prefs == null) await init();
    await _prefs!.clear();
  }

  // Check if cache exists and is valid
  static bool isCacheValid(String key, {Duration? maxAge}) {
    if (_prefs == null) return false;
    
    final jsonString = _prefs!.getString(key);
    if (jsonString == null) return false;
    
    if (maxAge != null) {
      final timestamp = _prefs!.getInt('${key}_timestamp') ?? 0;
      final age = DateTime.now().millisecondsSinceEpoch - timestamp;
      return age <= maxAge.inMilliseconds;
    }
    
    return true;
  }

  // Get cache age
  static Duration? getCacheAge(String key) {
    if (_prefs == null) return null;
    
    final timestamp = _prefs!.getInt('${key}_timestamp');
    if (timestamp == null) return null;
    
    final age = DateTime.now().millisecondsSinceEpoch - timestamp;
    return Duration(milliseconds: age);
  }

  // Cache size estimation
  static int getCacheSize() {
    if (_prefs == null) return 0;
    
    int totalSize = 0;
    for (String key in _prefs!.getKeys()) {
      final value = _prefs!.get(key);
      if (value is String) {
        totalSize += value.length;
      }
    }
    return totalSize;
  }

  // Cache statistics
  static Map<String, dynamic> getCacheStats() {
    if (_prefs == null) return {};
    
    final keys = _prefs!.getKeys();
    final dataKeys = keys.where((key) => 
        !key.endsWith('_timestamp') && !key.endsWith('_expiration')).toList();
    
    return {
      'total_keys': keys.length,
      'data_keys': dataKeys.length,
      'cache_size_bytes': getCacheSize(),
      'cache_keys': dataKeys,
    };
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\shared\utils\config.dart ===== 
enum Environment { development, staging, production }

class Config {
  static const Environment _environment = Environment.development;

  static Environment get environment => _environment;
  
  static String get baseUrl {
    switch (_environment) {
      case Environment.development:
        return "http://stock-news.local:8082/api/v1";
      case Environment.staging:
        return "http://stock-news.local:8082/api/v1";
      case Environment.production:
        return "http://stock-news.local:8082/api/v1";
    }
  }

  static bool get isProduction => _environment == Environment.production;
  static bool get isDevelopment => _environment == Environment.development;
  static bool get enableLogging => !isProduction;
  
  static Duration get apiTimeout {
    return isProduction 
        ? const Duration(seconds: 60)
        : const Duration(seconds: 10);
  }

  static int get paginationLimit => 20;
  static Duration get cacheMaxAge => const Duration(hours: 1);
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\shared\utils\date_formatter.dart ===== 
import 'package:intl/intl.dart';

class DateFormatter {
  /// Parses a date string safely, returning null if the format is invalid.
  static DateTime? safeParse(String? dateString) {
    if (dateString == null || dateString.isEmpty) {
      return null;
    }
    try {
      return DateTime.parse(dateString);
    } catch (e) {
      print('Error parsing date: $dateString, Error: $e');
      return null;
    }
  }

  /// Formats a DateTime object into a display-friendly string.
  /// Returns 'N/A' if the date is null.
  static String formatDateTime(DateTime? date) {
    if (date == null) {
      return 'Không xác định';
    }
    final formatter = DateFormat('dd/MM/yyyy HH:mm');
    return formatter.format(date);
  }

  /// Calculates the time elapsed since the given date.
  /// Returns a relative time string like "5 phút trước".
  static String timeAgo(DateTime? date) {
    if (date == null) {
      return 'Không xác định';
    }
    final now = DateTime.now();
    final difference = now.difference(date);

    if (difference.inDays > 7) {
      return formatDateTime(date);
    } else if (difference.inDays > 0) {
      return '${difference.inDays} ngày trước';
    } else if (difference.inHours > 0) {
      return '${difference.inHours} giờ trước';
    } else if (difference.inMinutes > 0) {
      return '${difference.inMinutes} phút trước';
    } else {
      return 'Vừa xong';
    }
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\shared\utils\debug_helper.dart ===== 
import 'package:flutter/foundation.dart';

class DebugHelper {
  static void log(String message, {String? tag}) {
    if (kDebugMode) {
      final timestamp = DateTime.now().toIso8601String();
      print('[$timestamp] ${tag ?? 'DEBUG'}: $message');
    }
  }

  static void logError(String error, {StackTrace? stackTrace, String? tag}) {
    if (kDebugMode) {
      final timestamp = DateTime.now().toIso8601String();
      print('[$timestamp] ${tag ?? 'ERROR'}: $error');
      if (stackTrace != null) {
        print('StackTrace: $stackTrace');
      }
    }
  }

  static void logApiCall(String method, String url, {Map<String, dynamic>? data}) {
    if (kDebugMode) {
      log('API $method: $url', tag: 'API');
      if (data != null) {
        log('Data: $data', tag: 'API');
      }
    }
  }

  static void logNavigation(String from, String to) {
    log('Navigation: $from -> $to', tag: 'NAV');
  }

  static Map<String, dynamic> getSystemInfo() {
    return {
      'isDebug': kDebugMode,
      'isWeb': kIsWeb,
      'platform': defaultTargetPlatform.toString(),
      'timestamp': DateTime.now().toIso8601String(),
    };
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\shared\utils\responsive_helper.dart ===== 
import 'package:flutter/material.dart';
import 'package:get/get.dart';

class ResponsiveHelper {
  static bool isMobile() => Get.width < 600;
  static bool isTablet() => Get.width >= 600 && Get.width < 1200;
  static bool isDesktop() => Get.width >= 1200;

  static double getResponsiveFontSize(double baseFontSize) {
    if (isMobile()) return baseFontSize;
    if (isTablet()) return baseFontSize * 1.1;
    return baseFontSize * 1.2;
  }

  static EdgeInsets getResponsivePadding() {
    if (isMobile()) return const EdgeInsets.all(16);
    if (isTablet()) return const EdgeInsets.all(24);
    return const EdgeInsets.all(32);
  }

  static int getResponsiveGridCount() {
    if (isMobile()) return 1;
    if (isTablet()) return 2;
    return 3;
  }

  static double getResponsiveCardWidth() {
    if (isMobile()) return Get.width - 32;
    if (isTablet()) return (Get.width - 64) / 2;
    return (Get.width - 96) / 3;
  }
}

class ResponsiveWidget extends StatelessWidget {
  final Widget mobile;
  final Widget? tablet;
  final Widget? desktop;

  const ResponsiveWidget({
    super.key,
    required this.mobile,
    this.tablet,
    this.desktop,
  });

  @override
  Widget build(BuildContext context) {
    if (ResponsiveHelper.isDesktop()) {
      return desktop ?? tablet ?? mobile;
    } else if (ResponsiveHelper.isTablet()) {
      return tablet ?? mobile;
    } else {
      return mobile;
    }
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\shared\utils\theme_helper.dart ===== 
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';

class ThemeHelper {
  static ThemeData getLightTheme() {
    const primaryColor = Color(0xFF2196F3);
    const secondaryColor = Color(0xFF03DAC6);

    return ThemeData(
      useMaterial3: true,
      colorScheme: ColorScheme.fromSeed(
        seedColor: primaryColor,
        brightness: Brightness.light,
      ),
      textTheme: GoogleFonts.robotoTextTheme(),
      appBarTheme: const AppBarTheme(
        centerTitle: false,
        elevation: 0,
        scrolledUnderElevation: 2,
      ),
      cardTheme: CardThemeData(
        elevation: 2,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(12),
        ),
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          elevation: 2,
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(8),
          ),
        ),
      ),
      inputDecorationTheme: InputDecorationTheme(
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(8),
        ),
        contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      ),
    );
  }

  static ThemeData getDarkTheme() {
    const primaryColor = Color(0xFF2196F3);

    return ThemeData(
      useMaterial3: true,
      colorScheme: ColorScheme.fromSeed(
        seedColor: primaryColor,
        brightness: Brightness.dark,
      ),
      textTheme: GoogleFonts.robotoTextTheme(ThemeData.dark().textTheme),
      appBarTheme: const AppBarTheme(
        centerTitle: false,
        elevation: 0,
        scrolledUnderElevation: 2,
      ),
      cardTheme: CardThemeData(
        elevation: 2,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(12),
        ),
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          elevation: 2,
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(8),
          ),
        ),
      ),
      inputDecorationTheme: InputDecorationTheme(
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(8),
        ),
        contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      ),
    );
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\shared\widgets\dashboard_header.dart ===== 
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:intl/intl.dart';
import 'package:stock_tracker_app/src/features/dashboard/controllers/dashboard_controller.dart';

class DashboardHeader extends StatelessWidget {
  const DashboardHeader({super.key});

  @override
  Widget build(BuildContext context) {
    final dashboardController = Get.find<DashboardController>();
    final now = DateTime.now();
    final dateFormat = DateFormat('EEEE, dd MMMM yyyy', 'vi_VN');
    final timeFormat = DateFormat('HH:mm');
    
    return Obx(() {
      // Lấy dữ liệu thống kê từ dashboard controller
      final dashboardData = dashboardController.dashboardData;
      final articlesCount = dashboardController.articlesCount;
      final watchlistCount = dashboardController.watchlistItems.length;
      
      return Container(
        width: double.infinity,
        padding: const EdgeInsets.all(24),
        decoration: BoxDecoration(
          gradient: LinearGradient(
            colors: [
              Theme.of(context).colorScheme.primary,
              Theme.of(context).colorScheme.primary.withOpacity(0.8),
              Theme.of(context).colorScheme.primaryContainer,
            ],
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
            stops: const [0.0, 0.7, 1.0],
          ),
          borderRadius: BorderRadius.circular(16),
          boxShadow: [
            BoxShadow(
              color: Theme.of(context).colorScheme.primary.withOpacity(0.3),
              blurRadius: 12,
              offset: const Offset(0, 4),
            ),
          ],
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Header Row với greeting và thời gian
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        _getGreeting(),
                        style: Theme.of(context).textTheme.headlineSmall?.copyWith(
                          color: Theme.of(context).colorScheme.onPrimary,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      const SizedBox(height: 4),
                      Text(
                        'Chào mừng đến với Stock News Tracker',
                        style: Theme.of(context).textTheme.bodyLarge?.copyWith(
                          color: Theme.of(context).colorScheme.onPrimary.withOpacity(0.9),
                        ),
                      ),
                    ],
                  ),
                ),
                Column(
                  crossAxisAlignment: CrossAxisAlignment.end,
                  children: [
                    Container(
                      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                      decoration: BoxDecoration(
                        color: Theme.of(context).colorScheme.onPrimary.withOpacity(0.2),
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: Text(
                        timeFormat.format(now),
                        style: Theme.of(context).textTheme.titleMedium?.copyWith(
                          color: Theme.of(context).colorScheme.onPrimary,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ),
                    const SizedBox(height: 4),
                    Text(
                      dateFormat.format(now),
                      style: Theme.of(context).textTheme.bodySmall?.copyWith(
                        color: Theme.of(context).colorScheme.onPrimary.withOpacity(0.8),
                      ),
                    ),
                  ],
                ),
              ],
            ),
            
            const SizedBox(height: 20),
            
            // Statistics Row
            Row(
              children: [
                Expanded(
                  child: _buildStatItem(
                    context,
                    'Tin tức',
                    '$articlesCount',
                    Icons.article_outlined,
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: _buildStatItem(
                    context,
                    'Công ty',
                    '${dashboardData?.totalCompanies ?? 0}',
                    Icons.business_outlined,
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: _buildStatItem(
                    context,
                    'Watchlist',
                    '$watchlistCount',
                    Icons.bookmark_outline,
                  ),
                ),
              ],
            ),
            
            const SizedBox(height: 16),
            
            // API Usage Progress nếu có data
            if (dashboardData != null) ...[
              _buildApiUsageIndicator(context, dashboardData),
            ],
            
            const SizedBox(height: 12),
            
            // Quick insights
            Row(
              children: [
                Icon(
                  Icons.trending_up,
                  size: 16,
                  color: Theme.of(context).colorScheme.onPrimary.withOpacity(0.8),
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: Text(
                    _getQuickInsight(dashboardController),
                    style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                      color: Theme.of(context).colorScheme.onPrimary.withOpacity(0.9),
                      fontStyle: FontStyle.italic,
                    ),
                  ),
                ),
              ],
            ),
          ],
        ),
      );
    });
  }

  Widget _buildStatItem(
    BuildContext context,
    String label,
    String value,
    IconData icon,
  ) {
    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.onPrimary.withOpacity(0.15),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: Theme.of(context).colorScheme.onPrimary.withOpacity(0.2),
          width: 1,
        ),
      ),
      child: Column(
        children: [
          Icon(
            icon,
            color: Theme.of(context).colorScheme.onPrimary,
            size: 24,
          ),
          const SizedBox(height: 8),
          Text(
            value,
            style: Theme.of(context).textTheme.titleLarge?.copyWith(
              color: Theme.of(context).colorScheme.onPrimary,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 4),
          Text(
            label,
            style: Theme.of(context).textTheme.bodySmall?.copyWith(
              color: Theme.of(context).colorScheme.onPrimary.withOpacity(0.8),
            ),
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }

  Widget _buildApiUsageIndicator(BuildContext context, dashboardData) {
    final usage = dashboardData.apiUsageToday ?? 0;
    final limit = dashboardData.apiLimit ?? 250;
    final percentage = limit > 0 ? (usage / limit) : 0.0;
    
    Color progressColor;
    String statusText;
    
    if (percentage >= 0.9) {
      progressColor = Colors.red;
      statusText = 'Gần đạt giới hạn';
    } else if (percentage >= 0.7) {
      progressColor = Colors.orange;
      statusText = 'Sử dụng nhiều';
    } else {
      progressColor = Colors.green;
      statusText = 'Bình thường';
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text(
              'API Usage hôm nay',
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                color: Theme.of(context).colorScheme.onPrimary.withOpacity(0.9),
                fontWeight: FontWeight.w500,
              ),
            ),
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
              decoration: BoxDecoration(
                color: progressColor.withOpacity(0.2),
                borderRadius: BorderRadius.circular(8),
              ),
              child: Text(
                statusText,
                style: TextStyle(
                  fontSize: 11,
                  color: progressColor,
                  fontWeight: FontWeight.w600,
                ),
              ),
            ),
          ],
        ),
        const SizedBox(height: 8),
        Row(
          children: [
            Expanded(
              child: LinearProgressIndicator(
                value: percentage,
                backgroundColor: Theme.of(context).colorScheme.onPrimary.withOpacity(0.3),
                valueColor: AlwaysStoppedAnimation<Color>(progressColor),
                borderRadius: BorderRadius.circular(4),
                minHeight: 6,
              ),
            ),
            const SizedBox(width: 12),
            Text(
              '$usage/$limit',
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                color: Theme.of(context).colorScheme.onPrimary.withOpacity(0.8),
                fontWeight: FontWeight.w600,
              ),
            ),
          ],
        ),
      ],
    );
  }

  String _getGreeting() {
    final hour = DateTime.now().hour;
    if (hour < 12) {
      return 'Chào buổi sáng! 🌅';
    } else if (hour < 17) {
      return 'Chào buổi chiều! ☀️';
    } else {
      return 'Chào buổi tối! 🌙';
    }
  }

  String _getQuickInsight(DashboardController controller) {
    final highImpactCount = controller.highImpactArticles.length;
    final sentimentTrend = controller.sentimentTrend;
    final articlesCount = controller.recentArticles.length;
    
    if (highImpactCount > 0) {
      return 'Có $highImpactCount tin tức tác động cao cần theo dõi';
    } else if (articlesCount > 0) {
      return 'Xu hướng cảm xúc thị trường: $sentimentTrend';
    } else {
      return 'Hệ thống đang thu thập và phân tích tin tức mới';
    }
  }
}

// Widget riêng cho responsive header nếu cần
class CompactDashboardHeader extends StatelessWidget {
  const CompactDashboardHeader({super.key});

  @override
  Widget build(BuildContext context) {
    final dashboardController = Get.find<DashboardController>();
    
    return Obx(() {
      return Container(
        width: double.infinity,
        padding: const EdgeInsets.all(16),
        decoration: BoxDecoration(
          color: Theme.of(context).colorScheme.primaryContainer,
          borderRadius: BorderRadius.circular(12),
        ),
        child: Row(
          children: [
            Icon(
              Icons.dashboard,
              color: Theme.of(context).colorScheme.onPrimaryContainer,
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'Stock News Tracker',
                    style: Theme.of(context).textTheme.titleMedium?.copyWith(
                      color: Theme.of(context).colorScheme.onPrimaryContainer,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  Text(
                    '${dashboardController.articlesCount} tin tức • ${dashboardController.dashboardData?.totalCompanies ?? 0} công ty',
                    style: Theme.of(context).textTheme.bodySmall?.copyWith(
                      color: Theme.of(context).colorScheme.onPrimaryContainer.withOpacity(0.8),
                    ),
                  ),
                ],
              ),
            ),
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
              decoration: BoxDecoration(
                color: Theme.of(context).colorScheme.primary,
                borderRadius: BorderRadius.circular(8),
              ),
              child: Text(
                DateFormat('HH:mm').format(DateTime.now()),
                style: Theme.of(context).textTheme.bodySmall?.copyWith(
                  color: Theme.of(context).colorScheme.onPrimary,
                  fontWeight: FontWeight.w600,
                ),
              ),
            ),
          ],
        ),
      );
    });
  }
}

// Widget cho loading state của header
class DashboardHeaderSkeleton extends StatelessWidget {
  const DashboardHeaderSkeleton({super.key});

  @override
  Widget build(BuildContext context) {
    return Container(
      width: double.infinity,
      height: 180,
      padding: const EdgeInsets.all(24),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surfaceVariant,
        borderRadius: BorderRadius.circular(16),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Skeleton cho text
          Container(
            width: 200,
            height: 24,
            decoration: BoxDecoration(
              color: Theme.of(context).colorScheme.outline.withOpacity(0.3),
              borderRadius: BorderRadius.circular(4),
            ),
          ),
          const SizedBox(height: 8),
          Container(
            width: 300,
            height: 16,
            decoration: BoxDecoration(
              color: Theme.of(context).colorScheme.outline.withOpacity(0.2),
              borderRadius: BorderRadius.circular(4),
            ),
          ),
          const SizedBox(height: 20),
          
          // Skeleton cho stats
          Row(
            children: [
              for (int i = 0; i < 3; i++) ...[
                Expanded(
                  child: Container(
                    height: 80,
                    decoration: BoxDecoration(
                      color: Theme.of(context).colorScheme.outline.withOpacity(0.2),
                      borderRadius: BorderRadius.circular(12),
                    ),
                  ),
                ),
                if (i < 2) const SizedBox(width: 16),
              ],
            ],
          ),
        ],
      ),
    );
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\shared\widgets\empty_widget.dart ===== 
import 'package:flutter/material.dart';

class EmptyWidget extends StatelessWidget {
  final String title;
  final String? subtitle;
  final IconData? icon;
  final VoidCallback? onAction;
  final String? actionText;
  final Widget? customIcon;
  final Color? iconColor;
  final IconData? iconForButton;
  
  const EmptyWidget({
    super.key,
    required this.title,
    this.subtitle,
    this.icon,
    this.onAction,
    this.actionText,
    this.customIcon,
    this.iconColor, this.iconForButton,
  });

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          mainAxisSize: MainAxisSize.min,
          children: [
            if (customIcon != null)
              customIcon!
            else
              Icon(
                icon ?? Icons.inbox_outlined,
                size: 80,
                color: iconColor ?? Theme.of(context).colorScheme.outline,
              ),
            const SizedBox(height: 16),
            Text(
              title,
              style: Theme.of(context).textTheme.headlineSmall?.copyWith(
                fontWeight: FontWeight.w600,
                color: Theme.of(context).colorScheme.onSurface,
              ),
              textAlign: TextAlign.center,
            ),
            if (subtitle != null) ...[
              const SizedBox(height: 8),
              Text(
                subtitle!,
                style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                  color: Theme.of(context).colorScheme.onSurfaceVariant,
                ),
                textAlign: TextAlign.center,
              ),
            ],
            if (onAction != null) ...[
              const SizedBox(height: 24),
              ElevatedButton.icon(
                onPressed: onAction,
                icon:  Icon(iconForButton ?? Icons.add),
                label: Text(actionText ?? 'Thêm mới'),
                style: ElevatedButton.styleFrom(
                  padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }
}

class EmptyNewsWidget extends StatelessWidget {
  final VoidCallback? onRefresh;
  
  const EmptyNewsWidget({super.key, this.onRefresh});

  @override
  Widget build(BuildContext context) {
    return EmptyWidget(
      title: 'Chưa có tin tức',
      subtitle: 'Không có tin tức nào được tìm thấy.\nHệ thống sẽ tự động cập nhật tin tức mới.',
      icon: Icons.article_outlined,
      onAction: onRefresh,
      actionText: 'Làm mới',
    );
  }
}

class EmptySearchWidget extends StatelessWidget {
  final String? searchQuery;
  final VoidCallback? onClearSearch;
  
  const EmptySearchWidget({
    super.key, 
    this.searchQuery,
    this.onClearSearch,
  });

  @override
  Widget build(BuildContext context) {
    return EmptyWidget(
      title: 'Không tìm thấy kết quả',
      subtitle: searchQuery != null 
          ? 'Không có kết quả nào cho "$searchQuery".\nThử tìm kiếm với từ khóa khác.'
          : 'Thử tìm kiếm với từ khóa khác.',
      icon: Icons.search_off,
      onAction: onClearSearch,
      actionText: 'Xóa tìm kiếm',
    );
  }
}

class EmptyCompaniesWidget extends StatelessWidget {
  final VoidCallback? onAddCompany;
  
  const EmptyCompaniesWidget({super.key, this.onAddCompany});

  @override
  Widget build(BuildContext context) {
    return EmptyWidget(
      title: 'Chưa có công ty nào',
      subtitle: 'Thêm công ty để bắt đầu theo dõi chỉ số tài chính và tin tức.',
      icon: Icons.business_outlined,
      onAction: onAddCompany,
      actionText: 'Thêm công ty',
    );
  }
}

class EmptyWatchlistWidget extends StatelessWidget {
  final VoidCallback? onAddItem;
  
  const EmptyWatchlistWidget({super.key, this.onAddItem});

  @override
  Widget build(BuildContext context) {
    return EmptyWidget(
      title: 'Watchlist trống',
      subtitle: 'Thêm từ khóa hoặc mã cổ phiếu để nhận thông báo tin tức liên quan.',
      icon: Icons.bookmark_outline,
      onAction: onAddItem,
      actionText: 'Thêm item',
    );
  }
}

class EmptyAnalyticsWidget extends StatelessWidget {
  final VoidCallback? onRefresh;
  
  const EmptyAnalyticsWidget({super.key, this.onRefresh});

  @override
  Widget build(BuildContext context) {
    return EmptyWidget(
      title: 'Chưa có dữ liệu phân tích',
      subtitle: 'Cần có dữ liệu tin tức để thực hiện phân tích.\nVui lòng quay lại sau.',
      icon: Icons.analytics_outlined,
      onAction: onRefresh,
      actionText: 'Kiểm tra lại',
    );
  }
}

class EmptyMetricsWidget extends StatelessWidget {
  final VoidCallback? onFetchMetrics;
  
  const EmptyMetricsWidget({super.key, this.onFetchMetrics});

  @override
  Widget build(BuildContext context) {
    return EmptyWidget(
      title: 'Chưa có dữ liệu tài chính',
      subtitle: 'Chưa có dữ liệu tài chính cho công ty này.\nHãy fetch metrics mới.',
      icon: Icons.trending_up,
      onAction: onFetchMetrics,
      actionText: 'Fetch metrics',
    );
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\shared\widgets\error_widget.dart ===== 
import 'package:flutter/material.dart';

class ErrorDisplayWidget extends StatelessWidget {
  final String message;
  final VoidCallback? onRetry;
  final String? title;
  final IconData? icon;
  final String? retryText;
  
  const ErrorDisplayWidget({
    super.key,
    required this.message,
    this.onRetry,
    this.title,
    this.icon,
    this.retryText,
  });

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              icon ?? Icons.error_outline,
              size: 80,
              color: Theme.of(context).colorScheme.error,
            ),
            const SizedBox(height: 16),
            Text(
              title ?? 'Oops! Có lỗi xảy ra',
              style: Theme.of(context).textTheme.headlineSmall?.copyWith(
                fontWeight: FontWeight.bold,
                color: Theme.of(context).colorScheme.error,
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 8),
            Text(
              message,
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                color: Theme.of(context).colorScheme.onSurfaceVariant,
              ),
              textAlign: TextAlign.center,
            ),
            if (onRetry != null) ...[
              const SizedBox(height: 24),
              ElevatedButton.icon(
                onPressed: onRetry,
                icon: const Icon(Icons.refresh),
                label: Text(retryText ?? 'Thử lại'),
                style: ElevatedButton.styleFrom(
                  padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }
}

class NetworkErrorWidget extends StatelessWidget {
  final VoidCallback? onRetry;
  
  const NetworkErrorWidget({super.key, this.onRetry});

  @override
  Widget build(BuildContext context) {
    return ErrorDisplayWidget(
      title: 'Lỗi kết nối',
      message: 'Không thể kết nối đến server.\nVui lòng kiểm tra kết nối mạng và thử lại.',
      icon: Icons.wifi_off,
      onRetry: onRetry,
      retryText: 'Kết nối lại',
    );
  }
}

class ServerErrorWidget extends StatelessWidget {
  final VoidCallback? onRetry;
  final String? errorCode;
  
  const ServerErrorWidget({super.key, this.onRetry, this.errorCode});

  @override
  Widget build(BuildContext context) {
    return ErrorDisplayWidget(
      title: 'Lỗi server',
      message: 'Server đang gặp sự cố.\nVui lòng thử lại sau ít phút.'
          '${errorCode != null ? '\n\nMã lỗi: $errorCode' : ''}',
      icon: Icons.dns,
      onRetry: onRetry,
    );
  }
}

class TimeoutErrorWidget extends StatelessWidget {
  final VoidCallback? onRetry;
  
  const TimeoutErrorWidget({super.key, this.onRetry});

  @override
  Widget build(BuildContext context) {
    return ErrorDisplayWidget(
      title: 'Timeout',
      message: 'Kết nối bị timeout.\nVui lòng thử lại.',
      icon: Icons.hourglass_empty,
      onRetry: onRetry,
    );
  }
}

class NotFoundErrorWidget extends StatelessWidget {
  final String? itemType;
  final VoidCallback? onGoBack;
  
  const NotFoundErrorWidget({
    super.key, 
    this.itemType,
    this.onGoBack,
  });

  @override
  Widget build(BuildContext context) {
    return ErrorDisplayWidget(
      title: 'Không tìm thấy',
      message: 'Không tìm thấy ${itemType ?? 'dữ liệu'} bạn yêu cầu.',
      icon: Icons.search_off,
      onRetry: onGoBack,
      retryText: 'Quay lại',
    );
  }
}

class UnauthorizedErrorWidget extends StatelessWidget {
  final VoidCallback? onLogin;
  
  const UnauthorizedErrorWidget({super.key, this.onLogin});

  @override
  Widget build(BuildContext context) {
    return ErrorDisplayWidget(
      title: 'Không có quyền truy cập',
      message: 'Bạn cần đăng nhập để xem nội dung này.',
      icon: Icons.lock_outline,
      onRetry: onLogin,
      retryText: 'Đăng nhập',
    );
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\shared\widgets\loading_widget.dart ===== 
import 'package:flutter/material.dart';

class LoadingWidget extends StatelessWidget {
  final String? message;
  final double? size;
  final Color? color;
  
  const LoadingWidget({
    super.key, 
    this.message,
    this.size,
    this.color,
  });

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        mainAxisSize: MainAxisSize.min,
        children: [
          SizedBox(
            width: size ?? 40,
            height: size ?? 40,
            child: CircularProgressIndicator(
              strokeWidth: 3,
              valueColor: AlwaysStoppedAnimation<Color>(
                color ?? Theme.of(context).colorScheme.primary,
              ),
            ),
          ),
          if (message != null) ...[
            const SizedBox(height: 16),
            Text(
              message!,
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                color: Theme.of(context).colorScheme.onSurfaceVariant,
              ),
              textAlign: TextAlign.center,
            ),
          ],
        ],
      ),
    );
  }
}

class LoadingOverlay extends StatelessWidget {
  final Widget child;
  final bool isLoading;
  final String? message;

  const LoadingOverlay({
    super.key,
    required this.child,
    required this.isLoading,
    this.message,
  });

  @override
  Widget build(BuildContext context) {
    return Stack(
      children: [
        child,
        if (isLoading)
          Container(
            color: Colors.black.withOpacity(0.5),
            child: LoadingWidget(message: message),
          ),
      ],
    );
  }
}

class ShimmerLoading extends StatefulWidget {
  final Widget child;
  final Duration period;

  const ShimmerLoading({
    super.key,
    required this.child,
    this.period = const Duration(milliseconds: 1500),
  });

  @override
  State<ShimmerLoading> createState() => _ShimmerLoadingState();
}

class _ShimmerLoadingState extends State<ShimmerLoading>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _animation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: widget.period,
      vsync: this,
    )..repeat();
    _animation = Tween<double>(begin: -1.0, end: 1.0).animate(
      CurvedAnimation(parent: _controller, curve: Curves.easeInOut),
    );
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: _animation,
      builder: (context, child) {
        return ShaderMask(
          shaderCallback: (bounds) {
            return LinearGradient(
              colors: [
                Colors.grey[300]!,
                Colors.grey[100]!,
                Colors.grey[300]!,
              ],
              stops: const [0.0, 0.5, 1.0],
              begin: Alignment.centerLeft,
              end: Alignment.centerRight,
              transform: GradientRotation(_animation.value * 0.5),
            ).createShader(bounds);
          },
          child: widget.child,
        );
      },
    );
  }
}

class ListItemShimmer extends StatelessWidget {
  const ListItemShimmer({super.key});

  @override
  Widget build(BuildContext context) {
    return ShimmerLoading(
      child: Card(
        margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Container(
                width: double.infinity,
                height: 20,
                decoration: BoxDecoration(
                  color: Colors.grey[300],
                  borderRadius: BorderRadius.circular(4),
                ),
              ),
              const SizedBox(height: 8),
              Container(
                width: double.infinity * 0.7,
                height: 16,
                decoration: BoxDecoration(
                  color: Colors.grey[300],
                  borderRadius: BorderRadius.circular(4),
                ),
              ),
              const SizedBox(height: 8),
              Container(
                width: double.infinity * 0.5,
                height: 14,
                decoration: BoxDecoration(
                  color: Colors.grey[300],
                  borderRadius: BorderRadius.circular(4),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\lib\src\shared\widgets\main_navigation.dart ===== 
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:stock_tracker_app/src/shared/controllers/navigation_controller.dart';

class MainNavigation extends StatelessWidget {
  final Widget child;
  
  const MainNavigation({super.key, required this.child});

  @override
  Widget build(BuildContext context) {
    // Khởi tạo NavigationController
    final navigationController = Get.put(NavigationController());
    
    return Scaffold(
      body: child,
      bottomNavigationBar: Obx(() {
        // ✅ BÂY GIỜ CÓ OBSERVABLE VARIABLE!
        return NavigationBar(
          selectedIndex: navigationController.selectedIndex, // ✅ Observable!
          onDestinationSelected: (index) => navigationController.updateIndex(index),
          destinations: const [
            NavigationDestination(
              icon: Icon(Icons.dashboard_outlined),
              selectedIcon: Icon(Icons.dashboard),
              label: 'Dashboard',
            ),
            NavigationDestination(
              icon: Icon(Icons.article_outlined),
              selectedIcon: Icon(Icons.article),
              label: 'Tin tức',
            ),
            NavigationDestination(
              icon: Icon(Icons.business_outlined),
              selectedIcon: Icon(Icons.business),
              label: 'Công ty',
            ),
            NavigationDestination(
              icon: Icon(Icons.bookmark_outline),
              selectedIcon: Icon(Icons.bookmark),
              label: 'Watchlist',
            ),
            NavigationDestination(
              icon: Icon(Icons.analytics_outlined),
              selectedIcon: Icon(Icons.analytics),
              label: 'Phân tích',
            ),
          ],
        );
      }),
    );
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\linux\flutter\ephemeral\.plugin_symlinks\path_provider_linux\example\integration_test\path_provider_test.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:io';
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:path_provider_linux/path_provider_linux.dart';

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  testWidgets('getTemporaryDirectory', (WidgetTester tester) async {
    final PathProviderLinux provider = PathProviderLinux();
    final String? result = await provider.getTemporaryPath();
    _verifySampleFile(result, 'temporaryDirectory');
  });

  testWidgets('getDownloadDirectory', (WidgetTester tester) async {
    if (!Platform.isLinux) {
      return;
    }
    final PathProviderLinux provider = PathProviderLinux();
    final String? result = await provider.getDownloadsPath();
    _verifySampleFile(result, 'downloadDirectory');
  });

  testWidgets('getApplicationDocumentsDirectory', (WidgetTester tester) async {
    final PathProviderLinux provider = PathProviderLinux();
    final String? result = await provider.getApplicationDocumentsPath();
    _verifySampleFile(result, 'applicationDocuments');
  });

  testWidgets('getApplicationSupportDirectory', (WidgetTester tester) async {
    final PathProviderLinux provider = PathProviderLinux();
    final String? result = await provider.getApplicationSupportPath();
    _verifySampleFile(result, 'applicationSupport');
  });

  testWidgets('getApplicationCacheDirectory', (WidgetTester tester) async {
    final PathProviderLinux provider = PathProviderLinux();
    final String? result = await provider.getApplicationCachePath();
    _verifySampleFile(result, 'applicationCache');
  });
}

/// Verify a file called [name] in [directoryPath] by recreating it with test
/// contents when necessary.
void _verifySampleFile(String? directoryPath, String name) {
  expect(directoryPath, isNotNull);
  if (directoryPath == null) {
    return;
  }
  final Directory directory = Directory(directoryPath);
  final File file = File('${directory.path}${Platform.pathSeparator}$name');

  if (file.existsSync()) {
    file.deleteSync();
    expect(file.existsSync(), isFalse);
  }

  file.writeAsStringSync('Hello world!');
  expect(file.readAsStringSync(), 'Hello world!');
  expect(directory.listSync(), isNotEmpty);
  file.deleteSync();
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\linux\flutter\ephemeral\.plugin_symlinks\path_provider_linux\example\lib\main.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:path_provider_linux/path_provider_linux.dart';

void main() {
  runApp(const MyApp());
}

/// Sample app
class MyApp extends StatefulWidget {
  /// Default Constructor
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  String? _tempDirectory = 'Unknown';
  String? _downloadsDirectory = 'Unknown';
  String? _appSupportDirectory = 'Unknown';
  String? _appCacheDirectory = 'Unknown';
  String? _documentsDirectory = 'Unknown';
  final PathProviderLinux _provider = PathProviderLinux();

  @override
  void initState() {
    super.initState();
    initDirectories();
  }

  // Platform messages are asynchronous, so we initialize in an async method.
  Future<void> initDirectories() async {
    String? tempDirectory;
    String? downloadsDirectory;
    String? appSupportDirectory;
    String? appCacheDirectory;
    String? documentsDirectory;
    // Platform messages may fail, so we use a try/catch PlatformException.
    try {
      tempDirectory = await _provider.getTemporaryPath();
    } on PlatformException {
      tempDirectory = 'Failed to get temp directory.';
    }
    try {
      downloadsDirectory = await _provider.getDownloadsPath();
    } on PlatformException {
      downloadsDirectory = 'Failed to get downloads directory.';
    }

    try {
      documentsDirectory = await _provider.getApplicationDocumentsPath();
    } on PlatformException {
      documentsDirectory = 'Failed to get documents directory.';
    }

    try {
      appSupportDirectory = await _provider.getApplicationSupportPath();
    } on PlatformException {
      appSupportDirectory = 'Failed to get documents directory.';
    }

    try {
      appCacheDirectory = await _provider.getApplicationCachePath();
    } on PlatformException {
      appCacheDirectory = 'Failed to get cache directory.';
    }
    // If the widget was removed from the tree while the asynchronous platform
    // message was in flight, we want to discard the reply rather than calling
    // setState to update our non-existent appearance.
    if (!mounted) {
      return;
    }

    setState(() {
      _tempDirectory = tempDirectory;
      _downloadsDirectory = downloadsDirectory;
      _appSupportDirectory = appSupportDirectory;
      _appCacheDirectory = appCacheDirectory;
      _documentsDirectory = documentsDirectory;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        appBar: AppBar(
          title: const Text('Path Provider Linux example app'),
        ),
        body: Center(
          child: Column(
            children: <Widget>[
              Text('Temp Directory: $_tempDirectory\n'),
              Text('Documents Directory: $_documentsDirectory\n'),
              Text('Downloads Directory: $_downloadsDirectory\n'),
              Text('Application Support Directory: $_appSupportDirectory\n'),
              Text('Application Cache Directory: $_appCacheDirectory\n'),
            ],
          ),
        ),
      ),
    );
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\linux\flutter\ephemeral\.plugin_symlinks\path_provider_linux\example\test_driver\integration_test.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:integration_test/integration_test_driver.dart';

Future<void> main() => integrationDriver();
.
===== D:\Computer Science\flutter project\stock_tracker_app\linux\flutter\ephemeral\.plugin_symlinks\path_provider_linux\lib\path_provider_linux.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

export 'src/path_provider_linux.dart';
.
===== D:\Computer Science\flutter project\stock_tracker_app\linux\flutter\ephemeral\.plugin_symlinks\path_provider_linux\lib\src\get_application_id.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// getApplicationId() is implemented using FFI; export a stub for platforms
// that don't support FFI (e.g., web) to avoid having transitive dependencies
// break web compilation.
export 'get_application_id_stub.dart'
    if (dart.library.ffi) 'get_application_id_real.dart';
.
===== D:\Computer Science\flutter project\stock_tracker_app\linux\flutter\ephemeral\.plugin_symlinks\path_provider_linux\lib\src\get_application_id_real.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:ffi';
import 'package:ffi/ffi.dart';
import 'package:flutter/foundation.dart' show visibleForTesting;

// GApplication* g_application_get_default();
typedef _GApplicationGetDefaultC = IntPtr Function();
typedef _GApplicationGetDefaultDart = int Function();

// const gchar* g_application_get_application_id(GApplication* application);
typedef _GApplicationGetApplicationIdC = Pointer<Utf8> Function(IntPtr);
typedef _GApplicationGetApplicationIdDart = Pointer<Utf8> Function(int);

/// Interface for interacting with libgio.
@visibleForTesting
class GioUtils {
  /// Creates a default instance that uses the real libgio.
  GioUtils() {
    try {
      _gio = DynamicLibrary.open('libgio-2.0.so');
    } on ArgumentError {
      _gio = null;
    }
  }

  DynamicLibrary? _gio;

  /// True if libgio was opened successfully.
  bool get libraryIsPresent => _gio != null;

  /// Wraps `g_application_get_default`.
  int gApplicationGetDefault() {
    if (_gio == null) {
      return 0;
    }
    final _GApplicationGetDefaultDart getDefault = _gio!
        .lookupFunction<_GApplicationGetDefaultC, _GApplicationGetDefaultDart>(
            'g_application_get_default');
    return getDefault();
  }

  /// Wraps g_application_get_application_id.
  Pointer<Utf8> gApplicationGetApplicationId(int app) {
    if (_gio == null) {
      return nullptr;
    }
    final _GApplicationGetApplicationIdDart gApplicationGetApplicationId = _gio!
        .lookupFunction<_GApplicationGetApplicationIdC,
                _GApplicationGetApplicationIdDart>(
            'g_application_get_application_id');
    return gApplicationGetApplicationId(app);
  }
}

/// Allows overriding the default GioUtils instance with a fake for testing.
@visibleForTesting
GioUtils? gioUtilsOverride;

/// Gets the application ID for this app.
String? getApplicationId() {
  final GioUtils gio = gioUtilsOverride ?? GioUtils();
  if (!gio.libraryIsPresent) {
    return null;
  }

  final int app = gio.gApplicationGetDefault();
  if (app == 0) {
    return null;
  }
  final Pointer<Utf8> appId = gio.gApplicationGetApplicationId(app);
  if (appId == nullptr) {
    return null;
  }
  return appId.toDartString();
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\linux\flutter\ephemeral\.plugin_symlinks\path_provider_linux\lib\src\get_application_id_stub.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// Gets the application ID for this app.
String? getApplicationId() => null;
.
===== D:\Computer Science\flutter project\stock_tracker_app\linux\flutter\ephemeral\.plugin_symlinks\path_provider_linux\lib\src\path_provider_linux.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:io';

import 'package:flutter/foundation.dart';
import 'package:path/path.dart' as path;
import 'package:path_provider_platform_interface/path_provider_platform_interface.dart';
import 'package:xdg_directories/xdg_directories.dart' as xdg;

import 'get_application_id.dart';

/// The linux implementation of [PathProviderPlatform]
///
/// This class implements the `package:path_provider` functionality for Linux.
class PathProviderLinux extends PathProviderPlatform {
  /// Constructs an instance of [PathProviderLinux]
  PathProviderLinux() : _environment = Platform.environment;

  /// Constructs an instance of [PathProviderLinux] with the given [environment]
  @visibleForTesting
  PathProviderLinux.private(
      {Map<String, String> environment = const <String, String>{},
      String? executableName,
      String? applicationId})
      : _environment = environment,
        _executableName = executableName,
        _applicationId = applicationId;

  final Map<String, String> _environment;
  String? _executableName;
  String? _applicationId;

  /// Registers this class as the default instance of [PathProviderPlatform]
  static void registerWith() {
    PathProviderPlatform.instance = PathProviderLinux();
  }

  @override
  Future<String?> getTemporaryPath() {
    final String environmentTmpDir = _environment['TMPDIR'] ?? '';
    return Future<String?>.value(
      environmentTmpDir.isEmpty ? '/tmp' : environmentTmpDir,
    );
  }

  @override
  Future<String?> getApplicationSupportPath() async {
    final Directory directory =
        Directory(path.join(xdg.dataHome.path, await _getId()));
    if (directory.existsSync()) {
      return directory.path;
    }

    // This plugin originally used the executable name as a directory.
    // Use that if it exists for backwards compatibility.
    final Directory legacyDirectory =
        Directory(path.join(xdg.dataHome.path, await _getExecutableName()));
    if (legacyDirectory.existsSync()) {
      return legacyDirectory.path;
    }

    // Create the directory, because mobile implementations assume the directory exists.
    await directory.create(recursive: true);
    return directory.path;
  }

  @override
  Future<String?> getApplicationDocumentsPath() {
    return Future<String?>.value(xdg.getUserDirectory('DOCUMENTS')?.path);
  }

  @override
  Future<String?> getApplicationCachePath() async {
    final Directory directory =
        Directory(path.join(xdg.cacheHome.path, await _getId()));
    if (!directory.existsSync()) {
      await directory.create(recursive: true);
    }
    return directory.path;
  }

  @override
  Future<String?> getDownloadsPath() {
    return Future<String?>.value(xdg.getUserDirectory('DOWNLOAD')?.path);
  }

  // Gets the name of this executable.
  Future<String> _getExecutableName() async {
    _executableName ??= path.basenameWithoutExtension(
        await File('/proc/self/exe').resolveSymbolicLinks());
    return _executableName!;
  }

  // Gets the unique ID for this application.
  Future<String> _getId() async {
    _applicationId ??= getApplicationId();
    // If no application ID then fall back to using the executable name.
    return _applicationId ?? await _getExecutableName();
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\linux\flutter\ephemeral\.plugin_symlinks\path_provider_linux\test\get_application_id_test.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
import 'dart:ffi';

import 'package:ffi/ffi.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:path_provider_linux/src/get_application_id_real.dart';

class _FakeGioUtils implements GioUtils {
  int? application;
  Pointer<Utf8>? applicationId;

  @override
  bool libraryIsPresent = false;

  @override
  int gApplicationGetDefault() => application!;

  @override
  Pointer<Utf8> gApplicationGetApplicationId(int app) => applicationId!;
}

void main() {
  late _FakeGioUtils fakeGio;

  setUp(() {
    fakeGio = _FakeGioUtils();
    gioUtilsOverride = fakeGio;
  });

  tearDown(() {
    gioUtilsOverride = null;
  });

  test('returns null if libgio is not available', () {
    expect(getApplicationId(), null);
  });

  test('returns null if g_paplication_get_default returns 0', () {
    fakeGio.libraryIsPresent = true;
    fakeGio.application = 0;
    expect(getApplicationId(), null);
  });

  test('returns null if g_application_get_application_id returns nullptr', () {
    fakeGio.libraryIsPresent = true;
    fakeGio.application = 1;
    fakeGio.applicationId = nullptr;
    expect(getApplicationId(), null);
  });

  test('returns value if g_application_get_application_id returns a value', () {
    fakeGio.libraryIsPresent = true;
    fakeGio.application = 1;
    const String id = 'foo';
    final Pointer<Utf8> idPtr = id.toNativeUtf8();
    fakeGio.applicationId = idPtr;
    expect(getApplicationId(), id);
    calloc.free(idPtr);
  });
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\linux\flutter\ephemeral\.plugin_symlinks\path_provider_linux\test\path_provider_linux_test.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
import 'package:flutter_test/flutter_test.dart';
import 'package:path_provider_linux/path_provider_linux.dart';
import 'package:path_provider_platform_interface/path_provider_platform_interface.dart';
import 'package:xdg_directories/xdg_directories.dart' as xdg;

void main() {
  TestWidgetsFlutterBinding.ensureInitialized();
  PathProviderLinux.registerWith();

  test('registered instance', () {
    expect(PathProviderPlatform.instance, isA<PathProviderLinux>());
  });

  test('getTemporaryPath defaults to TMPDIR', () async {
    final PathProviderPlatform plugin = PathProviderLinux.private(
      environment: <String, String>{'TMPDIR': '/run/user/0/tmp'},
    );
    expect(await plugin.getTemporaryPath(), '/run/user/0/tmp');
  });

  test('getTemporaryPath uses fallback if TMPDIR is empty', () async {
    final PathProviderPlatform plugin = PathProviderLinux.private(
      environment: <String, String>{'TMPDIR': ''},
    );
    expect(await plugin.getTemporaryPath(), '/tmp');
  });

  test('getTemporaryPath uses fallback if TMPDIR is unset', () async {
    final PathProviderPlatform plugin = PathProviderLinux.private(
      environment: <String, String>{},
    );
    expect(await plugin.getTemporaryPath(), '/tmp');
  });

  test('getApplicationSupportPath', () async {
    final PathProviderPlatform plugin = PathProviderLinux.private(
        executableName: 'path_provider_linux_test_binary',
        applicationId: 'com.example.Test');
    // Note this will fail if ${xdg.dataHome.path}/path_provider_linux_test_binary exists on the local filesystem.
    expect(await plugin.getApplicationSupportPath(),
        '${xdg.dataHome.path}/com.example.Test');
  });

  test('getApplicationSupportPath uses executable name if no application Id',
      () async {
    final PathProviderPlatform plugin = PathProviderLinux.private(
        executableName: 'path_provider_linux_test_binary');
    expect(await plugin.getApplicationSupportPath(),
        '${xdg.dataHome.path}/path_provider_linux_test_binary');
  });

  test('getApplicationDocumentsPath', () async {
    final PathProviderPlatform plugin = PathProviderPlatform.instance;
    expect(await plugin.getApplicationDocumentsPath(), startsWith('/'));
  });

  test('getApplicationCachePath', () async {
    final PathProviderPlatform plugin = PathProviderLinux.private(
        executableName: 'path_provider_linux_test_binary');
    expect(await plugin.getApplicationCachePath(),
        '${xdg.cacheHome.path}/path_provider_linux_test_binary');
  });

  test('getDownloadsPath', () async {
    final PathProviderPlatform plugin = PathProviderPlatform.instance;
    expect(await plugin.getDownloadsPath(), startsWith('/'));
  });
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\linux\flutter\ephemeral\.plugin_symlinks\shared_preferences_linux\example\integration_test\shared_preferences_test.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:shared_preferences_linux/shared_preferences_linux.dart';
import 'package:shared_preferences_platform_interface/shared_preferences_async_platform_interface.dart';
import 'package:shared_preferences_platform_interface/types.dart';

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  group('SharedPreferencesLinux', () {
    late SharedPreferencesLinux preferences;

    const Map<String, Object> flutterTestValues = <String, Object>{
      'flutter.String': 'hello world',
      'flutter.Bool': true,
      'flutter.Int': 42,
      'flutter.Double': 3.14159,
      'flutter.StringList': <String>['foo', 'bar'],
    };

    const Map<String, Object> prefixTestValues = <String, Object>{
      'prefix.String': 'hello world',
      'prefix.Bool': true,
      'prefix.Int': 42,
      'prefix.Double': 3.14159,
      'prefix.StringList': <String>['foo', 'bar'],
    };

    const Map<String, Object> nonPrefixTestValues = <String, Object>{
      'String': 'hello world',
      'Bool': true,
      'Int': 42,
      'Double': 3.14159,
      'StringList': <String>['foo', 'bar'],
    };

    final Map<String, Object> allTestValues = <String, Object>{};

    allTestValues.addAll(flutterTestValues);
    allTestValues.addAll(prefixTestValues);
    allTestValues.addAll(nonPrefixTestValues);

    Future<void> addData() async {
      await preferences.setValue('String', 'String', allTestValues['String']!);
      await preferences.setValue('Bool', 'Bool', allTestValues['Bool']!);
      await preferences.setValue('Int', 'Int', allTestValues['Int']!);
      await preferences.setValue('Double', 'Double', allTestValues['Double']!);
      await preferences.setValue(
          'StringList', 'StringList', allTestValues['StringList']!);
      await preferences.setValue(
          'String', 'prefix.String', allTestValues['prefix.String']!);
      await preferences.setValue(
          'Bool', 'prefix.Bool', allTestValues['prefix.Bool']!);
      await preferences.setValue(
          'Int', 'prefix.Int', allTestValues['prefix.Int']!);
      await preferences.setValue(
          'Double', 'prefix.Double', allTestValues['prefix.Double']!);
      await preferences.setValue('StringList', 'prefix.StringList',
          allTestValues['prefix.StringList']!);
      await preferences.setValue(
          'String', 'flutter.String', allTestValues['flutter.String']!);
      await preferences.setValue(
          'Bool', 'flutter.Bool', allTestValues['flutter.Bool']!);
      await preferences.setValue(
          'Int', 'flutter.Int', allTestValues['flutter.Int']!);
      await preferences.setValue(
          'Double', 'flutter.Double', allTestValues['flutter.Double']!);
      await preferences.setValue('StringList', 'flutter.StringList',
          allTestValues['flutter.StringList']!);
    }

    setUp(() async {
      preferences = SharedPreferencesLinux();
      await addData();
    });

    tearDown(() async {
      await preferences.clearWithParameters(
        ClearParameters(
          filter: PreferencesFilter(prefix: ''),
        ),
      );
    });

    testWidgets('getAll', (WidgetTester _) async {
      final Map<String, Object> values = await preferences.getAll();
      expect(values['flutter.String'], allTestValues['flutter.String']);
      expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
      expect(values['flutter.Int'], allTestValues['flutter.Int']);
      expect(values['flutter.Double'], allTestValues['flutter.Double']);
      expect(values['flutter.StringList'], allTestValues['flutter.StringList']);
    });

    group('withPrefix', () {
      testWidgets('remove', (WidgetTester _) async {
        const String key = 'flutter.String';
        await preferences.remove(key);
        final Map<String, Object> values =
            await preferences.getAllWithPrefix('');
        expect(values[key], isNull);
      });

      testWidgets('clear', (WidgetTester _) async {
        await preferences.clear();
        final Map<String, Object> values = await preferences.getAll();
        expect(values['flutter.String'], null);
        expect(values['flutter.Bool'], null);
        expect(values['flutter.Int'], null);
        expect(values['flutter.Double'], null);
        expect(values['flutter.StringList'], null);
      });

      testWidgets('get all with prefix', (WidgetTester _) async {
        final Map<String, Object> values =
            await preferences.getAllWithPrefix('prefix.');
        expect(values['prefix.String'], allTestValues['prefix.String']);
        expect(values['prefix.Bool'], allTestValues['prefix.Bool']);
        expect(values['prefix.Int'], allTestValues['prefix.Int']);
        expect(values['prefix.Double'], allTestValues['prefix.Double']);
        expect(values['prefix.StringList'], allTestValues['prefix.StringList']);
      });

      testWidgets('getAllWithNoPrefix', (WidgetTester _) async {
        final Map<String, Object> values =
            await preferences.getAllWithPrefix('');
        expect(values['String'], allTestValues['String']);
        expect(values['Bool'], allTestValues['Bool']);
        expect(values['Int'], allTestValues['Int']);
        expect(values['Double'], allTestValues['Double']);
        expect(values['StringList'], allTestValues['StringList']);
        expect(values['flutter.String'], allTestValues['flutter.String']);
        expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
        expect(values['flutter.Int'], allTestValues['flutter.Int']);
        expect(values['flutter.Double'], allTestValues['flutter.Double']);
        expect(
            values['flutter.StringList'], allTestValues['flutter.StringList']);
      });

      testWidgets('clearWithPrefix', (WidgetTester _) async {
        await preferences.clearWithPrefix('prefix.');
        Map<String, Object> values =
            await preferences.getAllWithPrefix('prefix.');
        expect(values['prefix.String'], null);
        expect(values['prefix.Bool'], null);
        expect(values['prefix.Int'], null);
        expect(values['prefix.Double'], null);
        expect(values['prefix.StringList'], null);
        values = await preferences.getAllWithPrefix('flutter.');
        expect(values['flutter.String'], allTestValues['flutter.String']);
        expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
        expect(values['flutter.Int'], allTestValues['flutter.Int']);
        expect(values['flutter.Double'], allTestValues['flutter.Double']);
        expect(
            values['flutter.StringList'], allTestValues['flutter.StringList']);
      });

      testWidgets('clearWithNoPrefix', (WidgetTester _) async {
        await preferences.clearWithPrefix('');
        final Map<String, Object> values =
            await preferences.getAllWithPrefix('');
        expect(values['String'], null);
        expect(values['Bool'], null);
        expect(values['Int'], null);
        expect(values['Double'], null);
        expect(values['StringList'], null);
        expect(values['flutter.String'], null);
        expect(values['flutter.Bool'], null);
        expect(values['flutter.Int'], null);
        expect(values['flutter.Double'], null);
        expect(values['flutter.StringList'], null);
      });
    });

    group('withParameters', () {
      testWidgets('remove', (WidgetTester _) async {
        const String key = 'flutter.String';
        await preferences.remove(key);
        final Map<String, Object> values =
            await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: ''),
          ),
        );
        expect(values[key], isNull);
      });

      testWidgets('clear', (WidgetTester _) async {
        await preferences.clear();
        final Map<String, Object> values = await preferences.getAll();
        expect(values['flutter.String'], null);
        expect(values['flutter.Bool'], null);
        expect(values['flutter.Int'], null);
        expect(values['flutter.Double'], null);
        expect(values['flutter.StringList'], null);
      });

      testWidgets('get all with prefix', (WidgetTester _) async {
        final Map<String, Object> values =
            await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: 'prefix.'),
          ),
        );
        expect(values['prefix.String'], allTestValues['prefix.String']);
        expect(values['prefix.Bool'], allTestValues['prefix.Bool']);
        expect(values['prefix.Int'], allTestValues['prefix.Int']);
        expect(values['prefix.Double'], allTestValues['prefix.Double']);
        expect(values['prefix.StringList'], allTestValues['prefix.StringList']);
      });

      testWidgets('get all with allow list', (WidgetTester _) async {
        final Map<String, Object> values =
            await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(
              prefix: 'prefix.',
              allowList: <String>{'prefix.String'},
            ),
          ),
        );
        expect(values['prefix.String'], allTestValues['prefix.String']);
        expect(values['prefix.Bool'], null);
        expect(values['prefix.Int'], null);
        expect(values['prefix.Double'], null);
        expect(values['prefix.StringList'], null);
      });

      testWidgets('getAllWithNoPrefix', (WidgetTester _) async {
        final Map<String, Object> values =
            await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: ''),
          ),
        );
        expect(values['String'], allTestValues['String']);
        expect(values['Bool'], allTestValues['Bool']);
        expect(values['Int'], allTestValues['Int']);
        expect(values['Double'], allTestValues['Double']);
        expect(values['StringList'], allTestValues['StringList']);
        expect(values['flutter.String'], allTestValues['flutter.String']);
        expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
        expect(values['flutter.Int'], allTestValues['flutter.Int']);
        expect(values['flutter.Double'], allTestValues['flutter.Double']);
        expect(
            values['flutter.StringList'], allTestValues['flutter.StringList']);
      });

      testWidgets('clearWithParameters', (WidgetTester _) async {
        await preferences.clearWithParameters(
          ClearParameters(
            filter: PreferencesFilter(prefix: 'prefix.'),
          ),
        );
        Map<String, Object> values = await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: 'prefix.'),
          ),
        );
        expect(values['prefix.String'], null);
        expect(values['prefix.Bool'], null);
        expect(values['prefix.Int'], null);
        expect(values['prefix.Double'], null);
        expect(values['prefix.StringList'], null);
        values = await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: 'flutter.'),
          ),
        );
        expect(values['flutter.String'], allTestValues['flutter.String']);
        expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
        expect(values['flutter.Int'], allTestValues['flutter.Int']);
        expect(values['flutter.Double'], allTestValues['flutter.Double']);
        expect(
            values['flutter.StringList'], allTestValues['flutter.StringList']);
      });

      testWidgets('clearWithParameters with allow list',
          (WidgetTester _) async {
        await addData();
        await preferences.clearWithParameters(
          ClearParameters(
            filter: PreferencesFilter(
              prefix: 'prefix.',
              allowList: <String>{'prefix.StringList'},
            ),
          ),
        );
        Map<String, Object> values = await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: 'prefix.'),
          ),
        );
        expect(values['prefix.String'], allTestValues['prefix.String']);
        expect(values['prefix.Bool'], allTestValues['prefix.Bool']);
        expect(values['prefix.Int'], allTestValues['prefix.Int']);
        expect(values['prefix.Double'], allTestValues['prefix.Double']);
        expect(values['prefix.StringList'], null);
        values = await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: 'flutter.'),
          ),
        );
        expect(values['flutter.String'], allTestValues['flutter.String']);
        expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
        expect(values['flutter.Int'], allTestValues['flutter.Int']);
        expect(values['flutter.Double'], allTestValues['flutter.Double']);
        expect(
            values['flutter.StringList'], allTestValues['flutter.StringList']);
      });

      testWidgets('clearWithNoPrefix', (WidgetTester _) async {
        await preferences.clearWithParameters(
          ClearParameters(
            filter: PreferencesFilter(prefix: ''),
          ),
        );
        final Map<String, Object> values =
            await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: ''),
          ),
        );
        expect(values['String'], null);
        expect(values['Bool'], null);
        expect(values['Int'], null);
        expect(values['Double'], null);
        expect(values['StringList'], null);
        expect(values['flutter.String'], null);
        expect(values['flutter.Bool'], null);
        expect(values['flutter.Int'], null);
        expect(values['flutter.Double'], null);
        expect(values['flutter.StringList'], null);
      });
    });
  });

  group('shared_preferences_async', () {
    const SharedPreferencesLinuxOptions emptyOptions =
        SharedPreferencesLinuxOptions();

    const String stringKey = 'testString';
    const String boolKey = 'testBool';
    const String intKey = 'testInt';
    const String doubleKey = 'testDouble';
    const String listKey = 'testList';

    const String testString = 'hello world';
    const bool testBool = true;
    const int testInt = 42;
    const double testDouble = 3.14159;
    const List<String> testList = <String>['foo', 'bar'];

    Future<SharedPreferencesAsyncPlatform> getPreferences(
        {bool clear = true}) async {
      final SharedPreferencesAsyncPlatform preferences =
          SharedPreferencesAsyncPlatform.instance!;
      if (clear) {
        await preferences.clear(
            const ClearPreferencesParameters(filter: PreferencesFilters()),
            emptyOptions);
      }
      return preferences;
    }

    testWidgets('set and get String', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setString(stringKey, testString, emptyOptions);
      expect(await preferences.getString(stringKey, emptyOptions), testString);
    });

    testWidgets('set and get bool', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setBool(boolKey, testBool, emptyOptions);
      expect(await preferences.getBool(boolKey, emptyOptions), testBool);
    });

    testWidgets('set and get int', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setInt(intKey, testInt, emptyOptions);
      expect(await preferences.getInt(intKey, emptyOptions), testInt);
    });

    testWidgets('set and get double', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setDouble(doubleKey, testDouble, emptyOptions);
      expect(await preferences.getDouble(doubleKey, emptyOptions), testDouble);
    });

    testWidgets('set and get StringList', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setStringList(listKey, testList, emptyOptions);
      expect(await preferences.getStringList(listKey, emptyOptions), testList);
    });
    testWidgets('getStringList does not throw cast error',
        (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setStringList(listKey, testList, emptyOptions);
      await (preferences as SharedPreferencesAsyncLinux).reload(emptyOptions);
      expect(await preferences.getStringList(listKey, emptyOptions), testList);
    });

    testWidgets('getStringList returns mutable list', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setStringList(listKey, testList, emptyOptions);
      final List<String>? list =
          await preferences.getStringList(listKey, emptyOptions);
      list?.add('value');
      expect(list?.length, testList.length + 1);
    });

    testWidgets('getPreferences', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await Future.wait(<Future<void>>[
        preferences.setString(stringKey, testString, emptyOptions),
        preferences.setBool(boolKey, testBool, emptyOptions),
        preferences.setInt(intKey, testInt, emptyOptions),
        preferences.setDouble(doubleKey, testDouble, emptyOptions),
        preferences.setStringList(listKey, testList, emptyOptions)
      ]);

      final Map<String, Object?> gotAll = await preferences.getPreferences(
        const GetPreferencesParameters(filter: PreferencesFilters()),
        emptyOptions,
      );

      expect(gotAll.length, 5);
      expect(gotAll[stringKey], testString);
      expect(gotAll[boolKey], testBool);
      expect(gotAll[intKey], testInt);
      expect(gotAll[doubleKey], testDouble);
      expect(gotAll[listKey], testList);
    });

    testWidgets('getPreferences with filter', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await Future.wait(<Future<void>>[
        preferences.setString(stringKey, testString, emptyOptions),
        preferences.setBool(boolKey, testBool, emptyOptions),
        preferences.setInt(intKey, testInt, emptyOptions),
        preferences.setDouble(doubleKey, testDouble, emptyOptions),
        preferences.setStringList(listKey, testList, emptyOptions)
      ]);

      final Map<String, Object?> gotAll = await preferences.getPreferences(
        const GetPreferencesParameters(
          filter: PreferencesFilters(allowList: <String>{stringKey, boolKey}),
        ),
        emptyOptions,
      );

      expect(gotAll.length, 2);
      expect(gotAll[stringKey], testString);
      expect(gotAll[boolKey], testBool);
    });

    testWidgets('getKeys', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await Future.wait(<Future<void>>[
        preferences.setString(stringKey, testString, emptyOptions),
        preferences.setBool(boolKey, testBool, emptyOptions),
        preferences.setInt(intKey, testInt, emptyOptions),
        preferences.setDouble(doubleKey, testDouble, emptyOptions),
        preferences.setStringList(listKey, testList, emptyOptions)
      ]);

      final Set<String> keys = await preferences.getKeys(
        const GetPreferencesParameters(filter: PreferencesFilters()),
        emptyOptions,
      );

      expect(keys.length, 5);
      expect(keys, contains(stringKey));
      expect(keys, contains(boolKey));
      expect(keys, contains(intKey));
      expect(keys, contains(doubleKey));
      expect(keys, contains(listKey));
    });

    testWidgets('getKeys with filter', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await Future.wait(<Future<void>>[
        preferences.setString(stringKey, testString, emptyOptions),
        preferences.setBool(boolKey, testBool, emptyOptions),
        preferences.setInt(intKey, testInt, emptyOptions),
        preferences.setDouble(doubleKey, testDouble, emptyOptions),
        preferences.setStringList(listKey, testList, emptyOptions)
      ]);

      final Set<String> keys = await preferences.getKeys(
        const GetPreferencesParameters(
          filter: PreferencesFilters(allowList: <String>{stringKey, boolKey}),
        ),
        emptyOptions,
      );

      expect(keys.length, 2);
      expect(keys, contains(stringKey));
      expect(keys, contains(boolKey));
    });

    testWidgets('clear', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await Future.wait(<Future<void>>[
        preferences.setString(stringKey, testString, emptyOptions),
        preferences.setBool(boolKey, testBool, emptyOptions),
        preferences.setInt(intKey, testInt, emptyOptions),
        preferences.setDouble(doubleKey, testDouble, emptyOptions),
        preferences.setStringList(listKey, testList, emptyOptions)
      ]);

      await preferences.clear(
        const ClearPreferencesParameters(filter: PreferencesFilters()),
        emptyOptions,
      );

      expect(await preferences.getString(stringKey, emptyOptions), null);
      expect(await preferences.getBool(boolKey, emptyOptions), null);
      expect(await preferences.getInt(intKey, emptyOptions), null);
      expect(await preferences.getDouble(doubleKey, emptyOptions), null);
      expect(await preferences.getStringList(listKey, emptyOptions), null);
    });

    testWidgets('clear with filter', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await Future.wait(<Future<void>>[
        preferences.setString(stringKey, testString, emptyOptions),
        preferences.setBool(boolKey, testBool, emptyOptions),
        preferences.setInt(intKey, testInt, emptyOptions),
        preferences.setDouble(doubleKey, testDouble, emptyOptions),
        preferences.setStringList(listKey, testList, emptyOptions)
      ]);
      await preferences.clear(
        const ClearPreferencesParameters(
          filter: PreferencesFilters(allowList: <String>{stringKey, boolKey}),
        ),
        emptyOptions,
      );
      expect(await preferences.getString(stringKey, emptyOptions), null);
      expect(await preferences.getBool(boolKey, emptyOptions), null);
      expect(await preferences.getInt(intKey, emptyOptions), testInt);
      expect(await preferences.getDouble(doubleKey, emptyOptions), testDouble);
      expect(await preferences.getStringList(listKey, emptyOptions), testList);
    });
  });
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\linux\flutter\ephemeral\.plugin_symlinks\shared_preferences_linux\example\lib\main.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// ignore_for_file: public_member_api_docs

import 'package:flutter/material.dart';
import 'package:shared_preferences_linux/shared_preferences_linux.dart';
import 'package:shared_preferences_platform_interface/shared_preferences_async_platform_interface.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return const MaterialApp(
      title: 'SharedPreferences Demo',
      home: SharedPreferencesDemo(),
    );
  }
}

class SharedPreferencesDemo extends StatefulWidget {
  const SharedPreferencesDemo({super.key});

  @override
  SharedPreferencesDemoState createState() => SharedPreferencesDemoState();
}

class SharedPreferencesDemoState extends State<SharedPreferencesDemo> {
  final SharedPreferencesAsyncPlatform? _prefs =
      SharedPreferencesAsyncPlatform.instance;
  final SharedPreferencesLinuxOptions options =
      const SharedPreferencesLinuxOptions();
  static const String _counterKey = 'counter';
  late Future<int> _counter;

  Future<void> _incrementCounter() async {
    final int? value = await _prefs!.getInt(_counterKey, options);
    final int counter = (value ?? 0) + 1;

    setState(() {
      _counter = _prefs.setInt(_counterKey, counter, options).then((_) {
        return counter;
      });
    });
  }

  Future<void> _getAndSetCounter() async {
    setState(() {
      _counter = _prefs!.getInt(_counterKey, options).then((int? counter) {
        return counter ?? 0;
      });
    });
  }

  @override
  void initState() {
    super.initState();
    _getAndSetCounter();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('SharedPreferences Demo'),
      ),
      body: Center(
          child: FutureBuilder<int>(
              future: _counter,
              builder: (BuildContext context, AsyncSnapshot<int> snapshot) {
                switch (snapshot.connectionState) {
                  case ConnectionState.none:
                  case ConnectionState.waiting:
                    return const CircularProgressIndicator();
                  case ConnectionState.active:
                  case ConnectionState.done:
                    if (snapshot.hasError) {
                      return Text('Error: ${snapshot.error}');
                    } else {
                      return Text(
                        'Button tapped ${snapshot.data} time${snapshot.data == 1 ? '' : 's'}.\n\n'
                        'This should persist across restarts.',
                      );
                    }
                }
              })),
      floatingActionButton: FloatingActionButton(
        onPressed: _incrementCounter,
        tooltip: 'Increment',
        child: const Icon(Icons.add),
      ),
    );
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\linux\flutter\ephemeral\.plugin_symlinks\shared_preferences_linux\example\test_driver\integration_test.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:integration_test/integration_test_driver.dart';

Future<void> main() => integrationDriver();
.
===== D:\Computer Science\flutter project\stock_tracker_app\linux\flutter\ephemeral\.plugin_symlinks\shared_preferences_linux\lib\shared_preferences_linux.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:async';
import 'dart:convert' show json;

import 'package:file/file.dart';
import 'package:file/local.dart';
import 'package:flutter/foundation.dart' show debugPrint, visibleForTesting;
import 'package:path/path.dart' as path;
import 'package:path_provider_linux/path_provider_linux.dart';
import 'package:shared_preferences_platform_interface/shared_preferences_async_platform_interface.dart';
import 'package:shared_preferences_platform_interface/shared_preferences_platform_interface.dart';
import 'package:shared_preferences_platform_interface/types.dart';

const String _defaultFileName = 'shared_preferences';

const String _defaultPrefix = 'flutter.';

/// The Linux implementation of [SharedPreferencesStorePlatform].
///
/// This class implements the `package:shared_preferences` functionality for Linux.
class SharedPreferencesLinux extends SharedPreferencesStorePlatform {
  /// Deprecated instance of [SharedPreferencesLinux].
  /// Use [SharedPreferencesStorePlatform.instance] instead.
  @Deprecated('Use `SharedPreferencesStorePlatform.instance` instead.')
  static SharedPreferencesLinux instance = SharedPreferencesLinux();

  /// Registers the Linux implementation.
  static void registerWith() {
    SharedPreferencesStorePlatform.instance = SharedPreferencesLinux();
    // A temporary work-around for having two plugins contained in a single package.
    SharedPreferencesAsyncLinux.registerWith();
  }

  /// Local copy of preferences
  Map<String, Object>? _cachedPreferences;

  /// File system used to store to disk. Exposed for testing only.
  @visibleForTesting
  FileSystem fs = const LocalFileSystem();

  /// The path_provider_linux instance used to find the support directory.
  @visibleForTesting
  PathProviderLinux pathProvider = PathProviderLinux();

  /// Checks for cached preferences and returns them or loads preferences from
  /// file and returns and caches them.
  Future<Map<String, Object>> _readPreferences() async {
    _cachedPreferences ??= await _reload(
      _defaultFileName,
      fs: fs,
      pathProvider: pathProvider,
    );
    return _cachedPreferences!;
  }

  @override
  Future<bool> clear() async {
    return clearWithParameters(
      ClearParameters(
        filter: PreferencesFilter(prefix: _defaultPrefix),
      ),
    );
  }

  @override
  Future<bool> clearWithPrefix(String prefix) async {
    return clearWithParameters(
        ClearParameters(filter: PreferencesFilter(prefix: prefix)));
  }

  @override
  Future<bool> clearWithParameters(ClearParameters parameters) async {
    final PreferencesFilter filter = parameters.filter;

    final Map<String, Object> preferences = await _readPreferences();
    preferences.removeWhere((String key, _) =>
        key.startsWith(filter.prefix) &&
        (filter.allowList == null || filter.allowList!.contains(key)));
    return _writePreferences(
      preferences,
      _defaultFileName,
      fs: fs,
      pathProvider: pathProvider,
    );
  }

  @override
  Future<Map<String, Object>> getAll() async {
    return getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: _defaultPrefix),
      ),
    );
  }

  @override
  Future<Map<String, Object>> getAllWithPrefix(String prefix) async {
    return getAllWithParameters(
        GetAllParameters(filter: PreferencesFilter(prefix: prefix)));
  }

  @override
  Future<Map<String, Object>> getAllWithParameters(
      GetAllParameters parameters) async {
    final PreferencesFilter filter = parameters.filter;
    final Map<String, Object> withPrefix =
        Map<String, Object>.from(await _readPreferences());
    withPrefix.removeWhere((String key, _) => !(key.startsWith(filter.prefix) &&
        (filter.allowList?.contains(key) ?? true)));
    return withPrefix;
  }

  @override
  Future<bool> remove(String key) async {
    final Map<String, Object> preferences = await _readPreferences();
    preferences.remove(key);
    return _writePreferences(
      preferences,
      _defaultFileName,
      fs: fs,
      pathProvider: pathProvider,
    );
  }

  @override
  Future<bool> setValue(String valueType, String key, Object value) async {
    final Map<String, Object> preferences = await _readPreferences();
    preferences[key] = value;
    return _writePreferences(
      preferences,
      _defaultFileName,
      fs: fs,
      pathProvider: pathProvider,
    );
  }
}

/// The Linux implementation of [SharedPreferencesAsyncPlatform].
///
/// This class implements the `package:shared_preferences` functionality for Linux.
base class SharedPreferencesAsyncLinux extends SharedPreferencesAsyncPlatform {
  /// Registers the Linux implementation.
  static void registerWith() {
    SharedPreferencesAsyncPlatform.instance = SharedPreferencesAsyncLinux();
  }

  /// Local copy of preferences
  Map<String, Object>? _cachedPreferences;

  /// File system used to store to disk. Exposed for testing only.
  @visibleForTesting
  FileSystem fs = const LocalFileSystem();

  /// The path_provider_linux instance used to find the support directory.
  @visibleForTesting
  PathProviderLinux pathProvider = PathProviderLinux();

  @override
  Future<Set<String>> getKeys(
    GetPreferencesParameters parameters,
    SharedPreferencesOptions options,
  ) async {
    return (await getPreferences(parameters, options)).keys.toSet();
  }

  @override
  Future<void> setString(
    String key,
    String value,
    SharedPreferencesOptions options,
  ) {
    return _setValue(key, value, options);
  }

  @override
  Future<void> setBool(
    String key,
    bool value,
    SharedPreferencesOptions options,
  ) {
    return _setValue(key, value, options);
  }

  @override
  Future<void> setDouble(
    String key,
    double value,
    SharedPreferencesOptions options,
  ) {
    return _setValue(key, value, options);
  }

  @override
  Future<void> setInt(
    String key,
    int value,
    SharedPreferencesOptions options,
  ) {
    return _setValue(key, value, options);
  }

  @override
  Future<void> setStringList(
    String key,
    List<String> value,
    SharedPreferencesOptions options,
  ) {
    return _setValue(key, value, options);
  }

  @override
  Future<String?> getString(
    String key,
    SharedPreferencesOptions options,
  ) async {
    final Map<String, Object> data = await _readAll(<String>{key}, options);
    return data[key] as String?;
  }

  @override
  Future<bool?> getBool(
    String key,
    SharedPreferencesOptions options,
  ) async {
    final Map<String, Object> data = await _readAll(<String>{key}, options);
    return data[key] as bool?;
  }

  @override
  Future<double?> getDouble(
    String key,
    SharedPreferencesOptions options,
  ) async {
    final Map<String, Object> data = await _readAll(<String>{key}, options);
    return data[key] as double?;
  }

  @override
  Future<int?> getInt(
    String key,
    SharedPreferencesOptions options,
  ) async {
    final Map<String, Object> data = await _readAll(<String>{key}, options);
    return data[key] as int?;
  }

  @override
  Future<List<String>?> getStringList(
    String key,
    SharedPreferencesOptions options,
  ) async {
    final Map<String, Object> data = await _readAll(<String>{key}, options);
    return (data[key] as List<Object?>?)?.cast<String>().toList();
  }

  @override
  Future<void> clear(ClearPreferencesParameters parameters,
      SharedPreferencesOptions options) async {
    final SharedPreferencesLinuxOptions linuxOptions =
        SharedPreferencesLinuxOptions.fromSharedPreferencesOptions(options);
    final PreferencesFilters filter = parameters.filter;
    final Map<String, Object> preferences =
        await _readPreferences(linuxOptions.fileName);
    preferences.removeWhere((String key, _) =>
        filter.allowList == null || filter.allowList!.contains(key));
    await _writePreferences(
      preferences,
      linuxOptions.fileName,
      fs: fs,
      pathProvider: pathProvider,
    );
  }

  @override
  Future<Map<String, Object>> getPreferences(
    GetPreferencesParameters parameters,
    SharedPreferencesOptions options,
  ) async {
    return _readAll(parameters.filter.allowList, options);
  }

  /// Reloads preferences from file.
  @visibleForTesting
  Future<void> reload(
    SharedPreferencesLinuxOptions options,
  ) async {
    _cachedPreferences = await _reload(options.fileName);
  }

  Future<Map<String, Object>> _readAll(
    Set<String>? allowList,
    SharedPreferencesOptions options,
  ) async {
    final SharedPreferencesLinuxOptions linuxOptions =
        SharedPreferencesLinuxOptions.fromSharedPreferencesOptions(options);
    final Map<String, Object> prefs =
        Map<String, Object>.from(await _readPreferences(linuxOptions.fileName));
    prefs.removeWhere((String key, _) => !(allowList?.contains(key) ?? true));
    return prefs;
  }

  Future<void> _setValue(
      String key, Object value, SharedPreferencesOptions options) async {
    final SharedPreferencesLinuxOptions linuxOptions =
        SharedPreferencesLinuxOptions.fromSharedPreferencesOptions(options);
    final Map<String, Object> preferences =
        await _readPreferences(linuxOptions.fileName);
    preferences[key] = value;
    await _writePreferences(
      preferences,
      linuxOptions.fileName,
      fs: fs,
      pathProvider: pathProvider,
    );
  }

  /// Checks for cached preferences and returns them or loads preferences from
  /// file and returns and caches them.
  Future<Map<String, Object>> _readPreferences(String fileName) async {
    _cachedPreferences ??= await _reload(
      fileName,
      fs: fs,
      pathProvider: pathProvider,
    );
    return _cachedPreferences!;
  }
}

/// Gets the file where the preferences are stored.
Future<File?> _getLocalDataFile(
  String fileName, {
  FileSystem fs = const LocalFileSystem(),
  PathProviderLinux? pathProvider,
}) async {
  pathProvider = pathProvider ?? PathProviderLinux();
  final String? directory = await pathProvider.getApplicationSupportPath();
  if (directory == null) {
    return null;
  }
  final String fileLocation = path.join(directory, '$fileName.json');
  return fs.file(fileLocation);
}

/// Gets the preferences from the stored file and saves them in cache.
Future<Map<String, Object>> _reload(
  String fileName, {
  FileSystem fs = const LocalFileSystem(),
  PathProviderLinux? pathProvider,
}) async {
  Map<String, Object> preferences = <String, Object>{};
  final File? localDataFile = await _getLocalDataFile(
    fileName,
    fs: fs,
    pathProvider: pathProvider,
  );
  if (localDataFile != null && localDataFile.existsSync()) {
    final String stringMap = localDataFile.readAsStringSync();
    if (stringMap.isNotEmpty) {
      final Object? data = json.decode(stringMap);
      if (data is Map) {
        preferences = data.cast<String, Object>();
      }
    }
  }
  return preferences;
}

/// Writes the cached preferences to disk. Returns [true] if the operation
/// succeeded.
Future<bool> _writePreferences(
  Map<String, Object> preferences,
  String fileName, {
  FileSystem fs = const LocalFileSystem(),
  PathProviderLinux? pathProvider,
}) async {
  try {
    final File? localDataFile = await _getLocalDataFile(
      fileName,
      fs: fs,
      pathProvider: pathProvider,
    );
    if (localDataFile == null) {
      debugPrint('Unable to determine where to write preferences.');
      return false;
    }
    if (!localDataFile.existsSync()) {
      localDataFile.createSync(recursive: true);
    }
    final String stringMap = json.encode(preferences);
    localDataFile.writeAsStringSync(stringMap);
  } catch (e) {
    debugPrint('Error saving preferences to disk: $e');
    return false;
  }
  return true;
}

/// Linux specific SharedPreferences Options.
class SharedPreferencesLinuxOptions extends SharedPreferencesOptions {
  /// Constructor for SharedPreferencesLinuxOptions.
  const SharedPreferencesLinuxOptions({
    this.fileName = 'shared_preferences',
  });

  /// The name of the file to store preferences in.
  final String fileName;

  /// Returns a new instance of [SharedPreferencesLinuxOptions] from an existing
  /// [SharedPreferencesOptions].
  static SharedPreferencesLinuxOptions fromSharedPreferencesOptions(
      SharedPreferencesOptions options) {
    if (options is SharedPreferencesLinuxOptions) {
      return options;
    }
    return const SharedPreferencesLinuxOptions();
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\linux\flutter\ephemeral\.plugin_symlinks\shared_preferences_linux\test\fake_path_provider_linux.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
import 'package:flutter_test/flutter_test.dart';
import 'package:path_provider_linux/path_provider_linux.dart';
import 'package:path_provider_platform_interface/path_provider_platform_interface.dart';

/// Fake implementation of PathProviderLinux that returns hard-coded paths,
/// allowing tests to run on any platform.
///
/// Note that this should only be used with an in-memory filesystem, as the
/// path it returns is a root path that does not actually exist on Linux.
class FakePathProviderLinux extends PathProviderPlatform
    implements PathProviderLinux {
  @override
  Future<String?> getApplicationSupportPath() async => r'/appsupport';

  @override
  Future<String?> getTemporaryPath() async => null;

  @override
  Future<String?> getLibraryPath() async => null;

  @override
  Future<String?> getApplicationDocumentsPath() async => null;

  @override
  Future<String?> getDownloadsPath() async => null;
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\linux\flutter\ephemeral\.plugin_symlinks\shared_preferences_linux\test\legacy_shared_preferences_linux_test.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
import 'dart:convert';

import 'package:file/memory.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:path/path.dart' as path;
import 'package:path_provider_linux/path_provider_linux.dart';
import 'package:shared_preferences_linux/shared_preferences_linux.dart';
import 'package:shared_preferences_platform_interface/shared_preferences_platform_interface.dart';
import 'package:shared_preferences_platform_interface/types.dart';

import 'fake_path_provider_linux.dart';

void main() {
  late MemoryFileSystem fs;
  late PathProviderLinux pathProvider;

  SharedPreferencesLinux.registerWith();

  const Map<String, Object> flutterTestValues = <String, Object>{
    'flutter.String': 'hello world',
    'flutter.Bool': true,
    'flutter.Int': 42,
    'flutter.Double': 3.14159,
    'flutter.StringList': <String>['foo', 'bar'],
  };

  const Map<String, Object> prefixTestValues = <String, Object>{
    'prefix.String': 'hello world',
    'prefix.Bool': true,
    'prefix.Int': 42,
    'prefix.Double': 3.14159,
    'prefix.StringList': <String>['foo', 'bar'],
  };

  const Map<String, Object> nonPrefixTestValues = <String, Object>{
    'String': 'hello world',
    'Bool': true,
    'Int': 42,
    'Double': 3.14159,
    'StringList': <String>['foo', 'bar'],
  };

  final Map<String, Object> allTestValues = <String, Object>{};

  allTestValues.addAll(flutterTestValues);
  allTestValues.addAll(prefixTestValues);
  allTestValues.addAll(nonPrefixTestValues);

  setUp(() {
    fs = MemoryFileSystem.test();
    pathProvider = FakePathProviderLinux();
  });

  Future<String> getFilePath() async {
    final String? directory = await pathProvider.getApplicationSupportPath();
    return path.join(directory!, 'shared_preferences.json');
  }

  Future<void> writeTestFile(String value) async {
    fs.file(await getFilePath())
      ..createSync(recursive: true)
      ..writeAsStringSync(value);
  }

  Future<String> readTestFile() async {
    return fs.file(await getFilePath()).readAsStringSync();
  }

  SharedPreferencesLinux getPreferences() {
    final SharedPreferencesLinux prefs = SharedPreferencesLinux();
    prefs.fs = fs;
    prefs.pathProvider = pathProvider;
    return prefs;
  }

  test('registered instance', () async {
    SharedPreferencesLinux.registerWith();
    expect(
        SharedPreferencesStorePlatform.instance, isA<SharedPreferencesLinux>());
  });

  test('getAll', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesLinux prefs = getPreferences();

    final Map<String, Object> values = await prefs.getAll();
    expect(values, hasLength(5));
    expect(values, flutterTestValues);
  });

  test('getAllWithPrefix', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesLinux prefs = getPreferences();

    final Map<String, Object> values = await prefs.getAllWithPrefix('prefix.');
    expect(values, hasLength(5));
    expect(values, prefixTestValues);
  });

  test('getAllWithParameters', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesLinux prefs = getPreferences();

    final Map<String, Object> values = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: 'prefix.'),
      ),
    );
    expect(values, hasLength(5));
    expect(values, prefixTestValues);
  });

  test('getAllWithParameters with allow list', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesLinux prefs = getPreferences();

    final Map<String?, Object?> all = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(
          prefix: 'prefix.',
          allowList: <String>{'prefix.Bool'},
        ),
      ),
    );
    expect(all.length, 1);
    expect(all['prefix.Bool'], prefixTestValues['prefix.Bool']);
  });

  test('remove', () async {
    await writeTestFile('{"key1":"one","key2":2}');
    final SharedPreferencesLinux prefs = getPreferences();

    await prefs.remove('key2');

    expect(await readTestFile(), '{"key1":"one"}');
  });

  test('setValue', () async {
    await writeTestFile('{}');
    final SharedPreferencesLinux prefs = getPreferences();

    await prefs.setValue('', 'key1', 'one');
    await prefs.setValue('', 'key2', 2);

    expect(await readTestFile(), '{"key1":"one","key2":2}');
  });

  test('clear', () async {
    await writeTestFile(json.encode(flutterTestValues));
    final SharedPreferencesLinux prefs = getPreferences();

    expect(await readTestFile(), json.encode(flutterTestValues));
    await prefs.clear();
    expect(await readTestFile(), '{}');
  });

  test('clearWithPrefix', () async {
    await writeTestFile(json.encode(flutterTestValues));
    final SharedPreferencesLinux prefs = getPreferences();
    await prefs.clearWithPrefix('prefix.');
    final Map<String, Object> noValues =
        await prefs.getAllWithPrefix('prefix.');
    expect(noValues, hasLength(0));

    final Map<String, Object> values = await prefs.getAll();
    expect(values, hasLength(5));
    expect(values, flutterTestValues);
  });

  test('getAllWithNoPrefix', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesLinux prefs = getPreferences();

    final Map<String, Object> values = await prefs.getAllWithPrefix('');
    expect(values, hasLength(15));
    expect(values, allTestValues);
  });

  test('clearWithNoPrefix', () async {
    await writeTestFile(json.encode(flutterTestValues));
    final SharedPreferencesLinux prefs = getPreferences();
    await prefs.clearWithPrefix('');
    final Map<String, Object> noValues = await prefs.getAllWithPrefix('');
    expect(noValues, hasLength(0));
  });

  test('clearWithParameters', () async {
    await writeTestFile(json.encode(flutterTestValues));
    final SharedPreferencesLinux prefs = getPreferences();
    await prefs.clearWithParameters(
      ClearParameters(
        filter: PreferencesFilter(prefix: 'prefix.'),
      ),
    );
    final Map<String, Object> noValues = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: 'prefix.'),
      ),
    );
    expect(noValues, hasLength(0));

    final Map<String, Object> values = await prefs.getAll();
    expect(values, hasLength(5));
    expect(values, flutterTestValues);
  });

  test('clearWithParameters with allow list', () async {
    await writeTestFile(json.encode(prefixTestValues));
    final SharedPreferencesLinux prefs = getPreferences();
    await prefs.clearWithParameters(
      ClearParameters(
        filter: PreferencesFilter(
          prefix: 'prefix.',
          allowList: <String>{'prefix.StringList'},
        ),
      ),
    );
    final Map<String, Object> someValues = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: 'prefix.'),
      ),
    );
    expect(someValues, hasLength(4));
  });

  test('getAllWithNoPrefix', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesLinux prefs = getPreferences();

    final Map<String, Object> values = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: ''),
      ),
    );
    expect(values, hasLength(15));
    expect(values, allTestValues);
  });

  test('clearWithNoPrefix', () async {
    await writeTestFile(json.encode(flutterTestValues));
    final SharedPreferencesLinux prefs = getPreferences();
    await prefs.clearWithParameters(
      ClearParameters(
        filter: PreferencesFilter(prefix: ''),
      ),
    );
    final Map<String, Object> noValues = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: ''),
      ),
    );
    expect(noValues, hasLength(0));
  });
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\linux\flutter\ephemeral\.plugin_symlinks\shared_preferences_linux\test\shared_preferences_linux_async_test.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file/memory.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:path_provider_linux/path_provider_linux.dart';
import 'package:shared_preferences_linux/shared_preferences_linux.dart';
import 'package:shared_preferences_platform_interface/types.dart';

import 'fake_path_provider_linux.dart';

void main() {
  late MemoryFileSystem fs;
  late PathProviderLinux pathProvider;

  SharedPreferencesAsyncLinux.registerWith();

  const String stringKey = 'testString';
  const String boolKey = 'testBool';
  const String intKey = 'testInt';
  const String doubleKey = 'testDouble';
  const String listKey = 'testList';

  const String testString = 'hello world';
  const bool testBool = true;
  const int testInt = 42;
  const double testDouble = 3.14159;
  const List<String> testList = <String>['foo', 'bar'];

  const SharedPreferencesLinuxOptions emptyOptions =
      SharedPreferencesLinuxOptions();

  setUp(() {
    fs = MemoryFileSystem.test();
    pathProvider = FakePathProviderLinux();
  });

  SharedPreferencesAsyncLinux getPreferences() {
    final SharedPreferencesAsyncLinux prefs = SharedPreferencesAsyncLinux();
    prefs.fs = fs;
    prefs.pathProvider = pathProvider;
    return prefs;
  }

  test('set and get String', () async {
    final SharedPreferencesAsyncLinux preferences = getPreferences();

    await preferences.setString(stringKey, testString, emptyOptions);
    expect(await preferences.getString(stringKey, emptyOptions), testString);
  });

  test('set and get bool', () async {
    final SharedPreferencesAsyncLinux preferences = getPreferences();

    await preferences.setBool(boolKey, testBool, emptyOptions);
    expect(await preferences.getBool(boolKey, emptyOptions), testBool);
  });

  test('set and get int', () async {
    final SharedPreferencesAsyncLinux preferences = getPreferences();

    await preferences.setInt(intKey, testInt, emptyOptions);
    expect(await preferences.getInt(intKey, emptyOptions), testInt);
  });

  test('set and get double', () async {
    final SharedPreferencesAsyncLinux preferences = getPreferences();

    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    expect(await preferences.getDouble(doubleKey, emptyOptions), testDouble);
  });

  test('set and get StringList', () async {
    final SharedPreferencesAsyncLinux preferences = getPreferences();

    await preferences.setStringList(listKey, testList, emptyOptions);
    expect(await preferences.getStringList(listKey, emptyOptions), testList);
  });

  test('getPreferences', () async {
    final SharedPreferencesAsyncLinux preferences = getPreferences();

    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);

    final Map<String, Object?> gotAll = await preferences.getPreferences(
        const GetPreferencesParameters(filter: PreferencesFilters()),
        emptyOptions);

    expect(gotAll.length, 5);
    expect(gotAll[stringKey], testString);
    expect(gotAll[boolKey], testBool);
    expect(gotAll[intKey], testInt);
    expect(gotAll[doubleKey], testDouble);
    expect(gotAll[listKey], testList);
  });

  test('getPreferences with filter', () async {
    final SharedPreferencesAsyncLinux preferences = getPreferences();

    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);

    final Map<String, Object?> gotAll = await preferences.getPreferences(
        const GetPreferencesParameters(
            filter:
                PreferencesFilters(allowList: <String>{stringKey, boolKey})),
        emptyOptions);

    expect(gotAll.length, 2);
    expect(gotAll[stringKey], testString);
    expect(gotAll[boolKey], testBool);
  });

  test('getKeys', () async {
    final SharedPreferencesAsyncLinux preferences = getPreferences();

    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);

    final Set<String> keys = await preferences.getKeys(
      const GetPreferencesParameters(filter: PreferencesFilters()),
      emptyOptions,
    );

    expect(keys.length, 5);
    expect(keys, contains(stringKey));
    expect(keys, contains(boolKey));
    expect(keys, contains(intKey));
    expect(keys, contains(doubleKey));
    expect(keys, contains(listKey));
  });

  test('getKeys with filter', () async {
    final SharedPreferencesAsyncLinux preferences = getPreferences();

    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);

    final Set<String> keys = await preferences.getKeys(
      const GetPreferencesParameters(
        filter: PreferencesFilters(allowList: <String>{stringKey, boolKey}),
      ),
      emptyOptions,
    );

    expect(keys.length, 2);
    expect(keys, contains(stringKey));
    expect(keys, contains(boolKey));
  });

  test('clear', () async {
    final SharedPreferencesAsyncLinux preferences = getPreferences();

    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);
    await preferences.clear(
        const ClearPreferencesParameters(filter: PreferencesFilters()),
        emptyOptions);
    expect(await preferences.getString(stringKey, emptyOptions), null);
    expect(await preferences.getBool(boolKey, emptyOptions), null);
    expect(await preferences.getInt(intKey, emptyOptions), null);
    expect(await preferences.getDouble(doubleKey, emptyOptions), null);
    expect(await preferences.getStringList(listKey, emptyOptions), null);
  });

  test('clear with filter', () async {
    final SharedPreferencesAsyncLinux preferences = getPreferences();

    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);
    await preferences.clear(
      const ClearPreferencesParameters(
        filter: PreferencesFilters(allowList: <String>{stringKey, boolKey}),
      ),
      emptyOptions,
    );
    expect(await preferences.getString(stringKey, emptyOptions), null);
    expect(await preferences.getBool(boolKey, emptyOptions), null);
    expect(await preferences.getInt(intKey, emptyOptions), testInt);
    expect(await preferences.getDouble(doubleKey, emptyOptions), testDouble);
    expect(await preferences.getStringList(listKey, emptyOptions), testList);
  });
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\linux\flutter\ephemeral\.plugin_symlinks\url_launcher_linux\example\integration_test\url_launcher_test.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:url_launcher_platform_interface/url_launcher_platform_interface.dart';

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  testWidgets('canLaunch', (WidgetTester _) async {
    final UrlLauncherPlatform launcher = UrlLauncherPlatform.instance;

    expect(await launcher.canLaunch('randomstring'), false);

    // Generally all devices should have some default browser.
    expect(await launcher.canLaunch('http://flutter.dev'), true);
  });
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\linux\flutter\ephemeral\.plugin_symlinks\url_launcher_linux\example\lib\main.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// ignore_for_file: public_member_api_docs

import 'dart:async';
import 'package:flutter/material.dart';
import 'package:url_launcher_platform_interface/url_launcher_platform_interface.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'URL Launcher',
      theme: ThemeData(
        primarySwatch: Colors.blue,
      ),
      home: const MyHomePage(title: 'URL Launcher'),
    );
  }
}

class MyHomePage extends StatefulWidget {
  const MyHomePage({super.key, required this.title});
  final String title;

  @override
  State<MyHomePage> createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> {
  Future<void>? _launched;

  Future<void> _launchInBrowser(String url) async {
    if (await UrlLauncherPlatform.instance.canLaunch(url)) {
      await UrlLauncherPlatform.instance.launch(
        url,
        useSafariVC: false,
        useWebView: false,
        enableJavaScript: false,
        enableDomStorage: false,
        universalLinksOnly: false,
        headers: <String, String>{},
      );
    } else {
      throw Exception('Could not launch $url');
    }
  }

  Widget _launchStatus(BuildContext context, AsyncSnapshot<void> snapshot) {
    if (snapshot.hasError) {
      return Text('Error: ${snapshot.error}');
    } else {
      return const Text('');
    }
  }

  @override
  Widget build(BuildContext context) {
    const String toLaunch = 'https://www.cylog.org/headers/';
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.title),
      ),
      body: ListView(
        children: <Widget>[
          Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: <Widget>[
              const Padding(
                padding: EdgeInsets.all(16.0),
                child: Text(toLaunch),
              ),
              ElevatedButton(
                onPressed: () => setState(() {
                  _launched = _launchInBrowser(toLaunch);
                }),
                child: const Text('Launch in browser'),
              ),
              const Padding(padding: EdgeInsets.all(16.0)),
              FutureBuilder<void>(future: _launched, builder: _launchStatus),
            ],
          ),
        ],
      ),
    );
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\linux\flutter\ephemeral\.plugin_symlinks\url_launcher_linux\example\test_driver\integration_test.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:integration_test/integration_test_driver.dart';

Future<void> main() => integrationDriver();
.
===== D:\Computer Science\flutter project\stock_tracker_app\linux\flutter\ephemeral\.plugin_symlinks\url_launcher_linux\lib\url_launcher_linux.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';
import 'package:url_launcher_platform_interface/link.dart';
import 'package:url_launcher_platform_interface/url_launcher_platform_interface.dart';

import 'src/messages.g.dart';

/// An implementation of [UrlLauncherPlatform] for Linux.
class UrlLauncherLinux extends UrlLauncherPlatform {
  /// Creates a new URL launcher instance.
  UrlLauncherLinux({@visibleForTesting UrlLauncherApi? api})
      : _hostApi = api ?? UrlLauncherApi();

  /// Registers this class as the default instance of [UrlLauncherPlatform].
  static void registerWith() {
    UrlLauncherPlatform.instance = UrlLauncherLinux();
  }

  final UrlLauncherApi _hostApi;

  @override
  final LinkDelegate? linkDelegate = null;

  @override
  Future<bool> canLaunch(String url) async {
    return _hostApi.canLaunchUrl(url);
  }

  @override
  Future<bool> launch(
    String url, {
    required bool useSafariVC,
    required bool useWebView,
    required bool enableJavaScript,
    required bool enableDomStorage,
    required bool universalLinksOnly,
    required Map<String, String> headers,
    String? webOnlyWindowName,
  }) {
    // None of the options are supported, so they don't need to be converted to
    // LaunchOptions.
    return launchUrl(url, const LaunchOptions());
  }

  @override
  Future<bool> launchUrl(String url, LaunchOptions options) async {
    final String? error = await _hostApi.launchUrl(url);
    if (error != null) {
      // TODO(stuartmorgan): Standardize errors across the entire plugin,
      // instead of using PlatformException. This preserves the pre-Pigeon
      // behavior of the C code returning this error response.
      throw PlatformException(
          code: 'Launch Error', message: 'Failed to launch URL: $error');
    }
    return true;
  }

  @override
  Future<bool> supportsMode(PreferredLaunchMode mode) async {
    return mode == PreferredLaunchMode.platformDefault ||
        mode == PreferredLaunchMode.externalApplication;
  }

  @override
  Future<bool> supportsCloseForMode(PreferredLaunchMode mode) async {
    // No supported mode is closeable.
    return false;
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\linux\flutter\ephemeral\.plugin_symlinks\url_launcher_linux\lib\src\messages.g.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Autogenerated from Pigeon (v22.6.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import, no_leading_underscores_for_local_identifiers

import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

PlatformException _createConnectionError(String channelName) {
  return PlatformException(
    code: 'channel-error',
    message: 'Unable to establish connection on channel: "$channelName".',
  );
}

class _PigeonCodec extends StandardMessageCodec {
  const _PigeonCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is int) {
      buffer.putUint8(4);
      buffer.putInt64(value);
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class UrlLauncherApi {
  /// Constructor for [UrlLauncherApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  UrlLauncherApi(
      {BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : pigeonVar_binaryMessenger = binaryMessenger,
        pigeonVar_messageChannelSuffix =
            messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? pigeonVar_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();

  final String pigeonVar_messageChannelSuffix;

  /// Returns true if the URL can definitely be launched.
  Future<bool> canLaunchUrl(String url) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.url_launcher_linux.UrlLauncherApi.canLaunchUrl$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[url]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as bool?)!;
    }
  }

  /// Opens the URL externally, returning an error string on failure.
  Future<String?> launchUrl(String url) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.url_launcher_linux.UrlLauncherApi.launchUrl$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[url]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as String?);
    }
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\linux\flutter\ephemeral\.plugin_symlinks\url_launcher_linux\pigeons\messages.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:pigeon/pigeon.dart';

@ConfigurePigeon(PigeonOptions(
  dartOut: 'lib/src/messages.g.dart',
  gobjectHeaderOut: 'linux/messages.g.h',
  gobjectSourceOut: 'linux/messages.g.cc',
  gobjectOptions: GObjectOptions(module: 'Ful'),
  copyrightHeader: 'pigeons/copyright.txt',
))
@HostApi()
abstract class UrlLauncherApi {
  /// Returns true if the URL can definitely be launched.
  bool canLaunchUrl(String url);

  /// Opens the URL externally, returning an error string on failure.
  String? launchUrl(String url);
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\linux\flutter\ephemeral\.plugin_symlinks\url_launcher_linux\test\url_launcher_linux_test.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter/services.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:url_launcher_linux/src/messages.g.dart';
import 'package:url_launcher_linux/url_launcher_linux.dart';
import 'package:url_launcher_platform_interface/url_launcher_platform_interface.dart';

void main() {
  group('UrlLauncherLinux', () {
    test('registers instance', () {
      UrlLauncherLinux.registerWith();
      expect(UrlLauncherPlatform.instance, isA<UrlLauncherLinux>());
    });

    test('canLaunch passes true', () async {
      final _FakeUrlLauncherApi api = _FakeUrlLauncherApi();
      final UrlLauncherLinux launcher = UrlLauncherLinux(api: api);

      final bool canLaunch = await launcher.canLaunch('http://example.com/');

      expect(canLaunch, true);
    });

    test('canLaunch passes false', () async {
      final _FakeUrlLauncherApi api = _FakeUrlLauncherApi(canLaunch: false);
      final UrlLauncherLinux launcher = UrlLauncherLinux(api: api);

      final bool canLaunch = await launcher.canLaunch('http://example.com/');

      expect(canLaunch, false);
    });

    test('launch', () async {
      final _FakeUrlLauncherApi api = _FakeUrlLauncherApi();
      final UrlLauncherLinux launcher = UrlLauncherLinux(api: api);
      const String url = 'http://example.com/';

      final bool launched = await launcher.launch(
        url,
        useSafariVC: true,
        useWebView: false,
        enableJavaScript: false,
        enableDomStorage: false,
        universalLinksOnly: false,
        headers: const <String, String>{},
      );

      expect(launched, true);
      expect(api.argument, url);
    });

    test('launch should throw if platform returns an error', () async {
      final _FakeUrlLauncherApi api = _FakeUrlLauncherApi(error: 'An error');
      final UrlLauncherLinux launcher = UrlLauncherLinux(api: api);

      await expectLater(
          launcher.launch(
            'http://example.com/',
            useSafariVC: true,
            useWebView: false,
            enableJavaScript: false,
            enableDomStorage: false,
            universalLinksOnly: false,
            headers: const <String, String>{},
          ),
          throwsA(isA<PlatformException>()
              .having((PlatformException e) => e.code, 'code', 'Launch Error')
              .having((PlatformException e) => e.message, 'message',
                  contains('Failed to launch URL: An error'))));
    });

    group('launchUrl', () {
      test('passes URL', () async {
        final _FakeUrlLauncherApi api = _FakeUrlLauncherApi();
        final UrlLauncherLinux launcher = UrlLauncherLinux(api: api);
        const String url = 'http://example.com/';

        final bool launched =
            await launcher.launchUrl(url, const LaunchOptions());

        expect(launched, true);
        expect(api.argument, url);
      });

      test('throws if platform returns an error', () async {
        final _FakeUrlLauncherApi api = _FakeUrlLauncherApi(error: 'An error');
        final UrlLauncherLinux launcher = UrlLauncherLinux(api: api);

        await expectLater(
            launcher.launchUrl('http://example.com/', const LaunchOptions()),
            throwsA(isA<PlatformException>()
                .having((PlatformException e) => e.code, 'code', 'Launch Error')
                .having((PlatformException e) => e.message, 'message',
                    contains('Failed to launch URL: An error'))));
      });
    });

    group('supportsMode', () {
      test('returns true for platformDefault', () async {
        final UrlLauncherLinux launcher = UrlLauncherLinux();
        expect(await launcher.supportsMode(PreferredLaunchMode.platformDefault),
            true);
      });

      test('returns true for external application', () async {
        final UrlLauncherLinux launcher = UrlLauncherLinux();
        expect(
            await launcher
                .supportsMode(PreferredLaunchMode.externalApplication),
            true);
      });

      test('returns false for other modes', () async {
        final UrlLauncherLinux launcher = UrlLauncherLinux();
        expect(
            await launcher.supportsMode(
                PreferredLaunchMode.externalNonBrowserApplication),
            false);
        expect(
            await launcher.supportsMode(PreferredLaunchMode.inAppBrowserView),
            false);
        expect(await launcher.supportsMode(PreferredLaunchMode.inAppWebView),
            false);
      });
    });

    test('supportsCloseForMode returns false', () async {
      final UrlLauncherLinux launcher = UrlLauncherLinux();
      expect(
          await launcher
              .supportsCloseForMode(PreferredLaunchMode.platformDefault),
          false);
      expect(
          await launcher
              .supportsCloseForMode(PreferredLaunchMode.externalApplication),
          false);
    });
  });
}

class _FakeUrlLauncherApi implements UrlLauncherApi {
  _FakeUrlLauncherApi({this.canLaunch = true, this.error});

  /// The value to return from canLaunch.
  final bool canLaunch;

  /// The error to return from launchUrl, if any.
  final String? error;

  /// The argument that was passed to an API call.
  String? argument;

  @override
  Future<bool> canLaunchUrl(String url) async {
    argument = url;
    return canLaunch;
  }

  @override
  Future<String?> launchUrl(String url) async {
    argument = url;
    return error;
  }

  @override
  // ignore: non_constant_identifier_names
  BinaryMessenger? get pigeonVar_binaryMessenger => null;

  @override
  // ignore: non_constant_identifier_names
  String get pigeonVar_messageChannelSuffix => '';
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\test\widget_test.dart ===== 
// This is a basic Flutter widget test.
//
// To perform an interaction with a widget in your test, use the WidgetTester
// utility in the flutter_test package. For example, you can send tap and scroll
// gestures. You can also use WidgetTester to find child widgets in the widget
// tree, read text, and verify that the values of widget properties are correct.

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';

import 'package:stock_tracker_app/src/app.dart';

void main() {
  testWidgets('Counter increments smoke test', (WidgetTester tester) async {
    // Build our app and trigger a frame.
    await tester.pumpWidget(const MyApp());

    // Verify that our counter starts at 0.
    expect(find.text('0'), findsOneWidget);
    expect(find.text('1'), findsNothing);

    // Tap the '+' icon and trigger a frame.
    await tester.tap(find.byIcon(Icons.add));
    await tester.pump();

    // Verify that our counter has incremented.
    expect(find.text('0'), findsNothing);
    expect(find.text('1'), findsOneWidget);
  });
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\windows\flutter\ephemeral\.plugin_symlinks\path_provider_windows\example\integration_test\path_provider_test.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:io';
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:path_provider_windows/path_provider_windows.dart';

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  testWidgets('getTemporaryDirectory', (WidgetTester tester) async {
    final PathProviderWindows provider = PathProviderWindows();
    final String? result = await provider.getTemporaryPath();
    _verifySampleFile(result, 'temporaryDirectory');
  });

  testWidgets('getApplicationDocumentsDirectory', (WidgetTester tester) async {
    final PathProviderWindows provider = PathProviderWindows();
    final String? result = await provider.getApplicationDocumentsPath();
    _verifySampleFile(result, 'applicationDocuments');
  });

  testWidgets('getApplicationSupportDirectory', (WidgetTester tester) async {
    final PathProviderWindows provider = PathProviderWindows();
    final String? result = await provider.getApplicationSupportPath();
    _verifySampleFile(result, 'applicationSupport');
  });

  testWidgets('getApplicationCacheDirectory', (WidgetTester tester) async {
    final PathProviderWindows provider = PathProviderWindows();
    final String? result = await provider.getApplicationCachePath();
    _verifySampleFile(result, 'applicationCache');
  });

  testWidgets('getDownloadsDirectory', (WidgetTester tester) async {
    final PathProviderWindows provider = PathProviderWindows();
    final String? result = await provider.getDownloadsPath();
    _verifySampleFile(result, 'downloads');
  });
}

/// Verify a file called [name] in [directoryPath] by recreating it with test
/// contents when necessary.
void _verifySampleFile(String? directoryPath, String name) {
  expect(directoryPath, isNotNull);
  if (directoryPath == null) {
    return;
  }
  final Directory directory = Directory(directoryPath);
  final File file = File('${directory.path}${Platform.pathSeparator}$name');

  if (file.existsSync()) {
    file.deleteSync();
    expect(file.existsSync(), isFalse);
  }

  file.writeAsStringSync('Hello world!');
  expect(file.readAsStringSync(), 'Hello world!');
  expect(directory.listSync(), isNotEmpty);
  file.deleteSync();
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\windows\flutter\ephemeral\.plugin_symlinks\path_provider_windows\example\lib\main.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// ignore_for_file: public_member_api_docs

import 'package:flutter/material.dart';
import 'package:path_provider_windows/path_provider_windows.dart';

void main() {
  runApp(const MyApp());
}

/// Sample app
class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  String? _tempDirectory = 'Unknown';
  String? _downloadsDirectory = 'Unknown';
  String? _appSupportDirectory = 'Unknown';
  String? _documentsDirectory = 'Unknown';
  String? _cacheDirectory = 'Unknown';

  @override
  void initState() {
    super.initState();
    initDirectories();
  }

  // Platform messages are asynchronous, so we initialize in an async method.
  Future<void> initDirectories() async {
    String? tempDirectory;
    String? downloadsDirectory;
    String? appSupportDirectory;
    String? documentsDirectory;
    String? cacheDirectory;
    final PathProviderWindows provider = PathProviderWindows();

    try {
      tempDirectory = await provider.getTemporaryPath();
    } catch (exception) {
      tempDirectory = 'Failed to get temp directory: $exception';
    }
    try {
      downloadsDirectory = await provider.getDownloadsPath();
    } catch (exception) {
      downloadsDirectory = 'Failed to get downloads directory: $exception';
    }

    try {
      documentsDirectory = await provider.getApplicationDocumentsPath();
    } catch (exception) {
      documentsDirectory = 'Failed to get documents directory: $exception';
    }

    try {
      appSupportDirectory = await provider.getApplicationSupportPath();
    } catch (exception) {
      appSupportDirectory = 'Failed to get app support directory: $exception';
    }

    try {
      cacheDirectory = await provider.getApplicationCachePath();
    } catch (exception) {
      cacheDirectory = 'Failed to get cache directory: $exception';
    }

    setState(() {
      _tempDirectory = tempDirectory;
      _downloadsDirectory = downloadsDirectory;
      _appSupportDirectory = appSupportDirectory;
      _documentsDirectory = documentsDirectory;
      _cacheDirectory = cacheDirectory;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        appBar: AppBar(
          title: const Text('Path Provider example app'),
        ),
        body: Center(
          child: Column(
            children: <Widget>[
              Text('Temp Directory: $_tempDirectory\n'),
              Text('Documents Directory: $_documentsDirectory\n'),
              Text('Downloads Directory: $_downloadsDirectory\n'),
              Text('Application Support Directory: $_appSupportDirectory\n'),
              Text('Cache Directory: $_cacheDirectory\n'),
            ],
          ),
        ),
      ),
    );
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\windows\flutter\ephemeral\.plugin_symlinks\path_provider_windows\example\test_driver\integration_test.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:integration_test/integration_test_driver.dart';

Future<void> main() => integrationDriver();
.
===== D:\Computer Science\flutter project\stock_tracker_app\windows\flutter\ephemeral\.plugin_symlinks\path_provider_windows\lib\path_provider_windows.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// path_provider_windows is implemented using FFI; export a stub for platforms
// that don't support FFI (e.g., web) to avoid having transitive dependencies
// break web compilation.
export 'src/folders_stub.dart' if (dart.library.ffi) 'src/folders.dart';
export 'src/path_provider_windows_stub.dart'
    if (dart.library.ffi) 'src/path_provider_windows_real.dart';
.
===== D:\Computer Science\flutter project\stock_tracker_app\windows\flutter\ephemeral\.plugin_symlinks\path_provider_windows\lib\src\folders.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// ignore_for_file: non_constant_identifier_names

// ignore: avoid_classes_with_only_static_members
/// A class containing the GUID references for each of the documented Windows
/// known folders. A property of this class may be passed to the `getPath`
/// method in the [PathProvidersWindows] class to retrieve a known folder from
/// Windows.
// These constants come from
// https://learn.microsoft.com/windows/win32/shell/knownfolderid
class WindowsKnownFolder {
  /// The file system directory that is used to store administrative tools for
  /// an individual user. The MMC will save customized consoles to this
  /// directory, and it will roam with the user.
  static String get AdminTools => '{724EF170-A42D-4FEF-9F26-B60E846FBA4F}';

  /// The file system directory that acts as a staging area for files waiting to
  /// be written to a CD. A typical path is C:\Documents and
  /// Settings\username\Local Settings\Application Data\Microsoft\CD Burning.
  static String get CDBurning => '{9E52AB10-F80D-49DF-ACB8-4330F5687855}';

  /// The file system directory that contains administrative tools for all users
  /// of the computer.
  static String get CommonAdminTools =>
      '{D0384E7D-BAC3-4797-8F14-CBA229B392B5}';

  /// The file system directory that contains the directories for the common
  /// program groups that appear on the Start menu for all users. A typical path
  /// is C:\Documents and Settings\All Users\Start Menu\Programs.
  static String get CommonPrograms => '{0139D44E-6AFE-49F2-8690-3DAFCAE6FFB8}';

  /// The file system directory that contains the programs and folders that
  /// appear on the Start menu for all users. A typical path is C:\Documents and
  /// Settings\All Users\Start Menu.
  static String get CommonStartMenu => '{A4115719-D62E-491D-AA7C-E74B8BE3B067}';

  /// The file system directory that contains the programs that appear in the
  /// Startup folder for all users. A typical path is C:\Documents and
  /// Settings\All Users\Start Menu\Programs\Startup.
  static String get CommonStartup => '{82A5EA35-D9CD-47C5-9629-E15D2F714E6E}';

  /// The file system directory that contains the templates that are available
  /// to all users. A typical path is C:\Documents and Settings\All
  /// Users\Templates.
  static String get CommonTemplates => '{B94237E7-57AC-4347-9151-B08C6C32D1F7}';

  /// The virtual folder that represents My Computer, containing everything on
  /// the local computer: storage devices, printers, and Control Panel. The
  /// folder can also contain mapped network drives.
  static String get ComputerFolder => '{0AC0837C-BBF8-452A-850D-79D08E667CA7}';

  /// The virtual folder that represents Network Connections, that contains
  /// network and dial-up connections.
  static String get ConnectionsFolder =>
      '{6F0CD92B-2E97-45D1-88FF-B0D186B8DEDD}';

  /// The virtual folder that contains icons for the Control Panel applications.
  static String get ControlPanelFolder =>
      '{82A74AEB-AEB4-465C-A014-D097EE346D63}';

  /// The file system directory that serves as a common repository for Internet
  /// cookies. A typical path is C:\Documents and Settings\username\Cookies.
  static String get Cookies => '{2B0F765D-C0E9-4171-908E-08A611B84FF6}';

  /// The virtual folder that represents the Windows desktop, the root of the
  /// namespace.
  static String get Desktop => '{B4BFCC3A-DB2C-424C-B029-7FE99A87C641}';

  /// The virtual folder that represents the My Documents desktop item.
  static String get Documents => '{FDD39AD0-238F-46AF-ADB4-6C85480369C7}';

  /// The file system directory that serves as a repository for Internet
  /// downloads.
  static String get Downloads => '{374DE290-123F-4565-9164-39C4925E467B}';

  /// The file system directory that serves as a common repository for the
  /// user's favorite items. A typical path is C:\Documents and
  /// Settings\username\Favorites.
  static String get Favorites => '{1777F761-68AD-4D8A-87BD-30B759FA33DD}';

  /// A virtual folder that contains fonts. A typical path is C:\Windows\Fonts.
  static String get Fonts => '{FD228CB7-AE11-4AE3-864C-16F3910AB8FE}';

  /// The file system directory that serves as a common repository for Internet
  /// history items.
  static String get History => '{D9DC8A3B-B784-432E-A781-5A1130A75963}';

  /// The file system directory that serves as a common repository for temporary
  /// Internet files. A typical path is C:\Documents and Settings\username\Local
  /// Settings\Temporary Internet Files.
  static String get InternetCache => '{352481E8-33BE-4251-BA85-6007CAEDCF9D}';

  /// A virtual folder for Internet Explorer.
  static String get InternetFolder => '{4D9F7874-4E0C-4904-967B-40B0D20C3E4B}';

  /// The file system directory that serves as a data repository for local
  /// (nonroaming) applications. A typical path is C:\Documents and
  /// Settings\username\Local Settings\Application Data.
  static String get LocalAppData => '{F1B32785-6FBA-4FCF-9D55-7B8E7F157091}';

  /// The file system directory that serves as a common repository for music
  /// files. A typical path is C:\Documents and Settings\User\My Documents\My
  /// Music.
  static String get Music => '{4BD8D571-6D19-48D3-BE97-422220080E43}';

  /// A file system directory that contains the link objects that may exist in
  /// the My Network Places virtual folder. A typical path is C:\Documents and
  /// Settings\username\NetHood.
  static String get NetHood => '{C5ABBF53-E17F-4121-8900-86626FC2C973}';

  /// The folder that represents other computers in your workgroup.
  static String get NetworkFolder => '{D20BEEC4-5CA8-4905-AE3B-BF251EA09B53}';

  /// The file system directory that serves as a common repository for image
  /// files. A typical path is C:\Documents and Settings\username\My
  /// Documents\My Pictures.
  static String get Pictures => '{33E28130-4E1E-4676-835A-98395C3BC3BB}';

  /// The file system directory that contains the link objects that can exist in
  /// the Printers virtual folder. A typical path is C:\Documents and
  /// Settings\username\PrintHood.
  static String get PrintHood => '{9274BD8D-CFD1-41C3-B35E-B13F55A758F4}';

  /// The virtual folder that contains installed printers.
  static String get PrintersFolder => '{76FC4E2D-D6AD-4519-A663-37BD56068185}';

  /// The user's profile folder. A typical path is C:\Users\username.
  /// Applications should not create files or folders at this level.
  static String get Profile => '{5E6C858F-0E22-4760-9AFE-EA3317B67173}';

  /// The file system directory that contains application data for all users. A
  /// typical path is C:\Documents and Settings\All Users\Application Data. This
  /// folder is used for application data that is not user specific. For
  /// example, an application can store a spell-check dictionary, a database of
  /// clip art, or a log file in the CSIDL_COMMON_APPDATA folder. This
  /// information will not roam and is available to anyone using the computer.
  static String get ProgramData => '{62AB5D82-FDC1-4DC3-A9DD-070D1D495D97}';

  /// The Program Files folder. A typical path is C:\Program Files.
  static String get ProgramFiles => '{905e63b6-c1bf-494e-b29c-65b732d3d21a}';

  /// The common Program Files folder. A typical path is C:\Program
  /// Files\Common.
  static String get ProgramFilesCommon =>
      '{F7F1ED05-9F6D-47A2-AAAE-29D317C6F066}';

  /// On 64-bit systems, a link to the common Program Files folder. A typical path is
  /// C:\Program Files\Common Files.
  static String get ProgramFilesCommonX64 =>
      '{6365D5A7-0F0D-45e5-87F6-0DA56B6A4F7D}';

  /// On 64-bit systems, a link to the 32-bit common Program Files folder. A
  /// typical path is C:\Program Files (x86)\Common Files. On 32-bit systems, a
  /// link to the Common Program Files folder.
  static String get ProgramFilesCommonX86 =>
      '{DE974D24-D9C6-4D3E-BF91-F4455120B917}';

  /// On 64-bit systems, a link to the Program Files folder. A typical path is
  /// C:\Program Files.
  static String get ProgramFilesX64 => '{6D809377-6AF0-444b-8957-A3773F02200E}';

  /// On 64-bit systems, a link to the 32-bit Program Files folder. A typical
  /// path is C:\Program Files (x86). On 32-bit systems, a link to the Common
  /// Program Files folder.
  static String get ProgramFilesX86 => '{7C5A40EF-A0FB-4BFC-874A-C0F2E0B9FA8E}';

  /// The file system directory that contains the user's program groups (which
  /// are themselves file system directories).
  static String get Programs => '{A77F5D77-2E2B-44C3-A6A2-ABA601054A51}';

  /// The file system directory that contains files and folders that appear on
  /// the desktop for all users. A typical path is C:\Documents and Settings\All
  /// Users\Desktop.
  static String get PublicDesktop => '{C4AA340D-F20F-4863-AFEF-F87EF2E6BA25}';

  /// The file system directory that contains documents that are common to all
  /// users. A typical path is C:\Documents and Settings\All Users\Documents.
  static String get PublicDocuments => '{ED4824AF-DCE4-45A8-81E2-FC7965083634}';

  /// The file system directory that serves as a repository for music files
  /// common to all users. A typical path is C:\Documents and Settings\All
  /// Users\Documents\My Music.
  static String get PublicMusic => '{3214FAB5-9757-4298-BB61-92A9DEAA44FF}';

  /// The file system directory that serves as a repository for image files
  /// common to all users. A typical path is C:\Documents and Settings\All
  /// Users\Documents\My Pictures.
  static String get PublicPictures => '{B6EBFB86-6907-413C-9AF7-4FC2ABF07CC5}';

  /// The file system directory that serves as a repository for video files
  /// common to all users. A typical path is C:\Documents and Settings\All
  /// Users\Documents\My Videos.
  static String get PublicVideos => '{2400183A-6185-49FB-A2D8-4A392A602BA3}';

  /// The file system directory that contains shortcuts to the user's most
  /// recently used documents. A typical path is C:\Documents and
  /// Settings\username\My Recent Documents.
  static String get Recent => '{AE50C081-EBD2-438A-8655-8A092E34987A}';

  /// The virtual folder that contains the objects in the user's Recycle Bin.
  static String get RecycleBinFolder =>
      '{B7534046-3ECB-4C18-BE4E-64CD4CB7D6AC}';

  /// The file system directory that contains resource data. A typical path is
  /// C:\Windows\Resources.
  static String get ResourceDir => '{8AD10C31-2ADB-4296-A8F7-E4701232C972}';

  /// The file system directory that serves as a common repository for
  /// application-specific data. A typical path is C:\Documents and
  /// Settings\username\Application Data.
  static String get RoamingAppData => '{3EB685DB-65F9-4CF6-A03A-E3EF65729F3D}';

  /// The file system directory that contains Send To menu items. A typical path
  /// is C:\Documents and Settings\username\SendTo.
  static String get SendTo => '{8983036C-27C0-404B-8F08-102D10DCFD74}';

  /// The file system directory that contains Start menu items. A typical path
  /// is C:\Documents and Settings\username\Start Menu.
  static String get StartMenu => '{625B53C3-AB48-4EC1-BA1F-A1EF4146FC19}';

  /// The file system directory that corresponds to the user's Startup program
  /// group. The system starts these programs whenever the associated user logs
  /// on. A typical path is C:\Documents and Settings\username\Start
  /// Menu\Programs\Startup.
  static String get Startup => '{B97D20BB-F46A-4C97-BA10-5E3608430854}';

  /// The Windows System folder. A typical path is C:\Windows\System32.
  static String get System => '{1AC14E77-02E7-4E5D-B744-2EB1AE5198B7}';

  /// The 32-bit Windows System folder. On 32-bit systems, this is typically
  /// C:\Windows\system32. On 64-bit systems, this is typically
  /// C:\Windows\syswow64.
  static String get SystemX86 => '{D65231B0-B2F1-4857-A4CE-A8E7C6EA7D27}';

  /// The file system directory that serves as a common repository for document
  /// templates. A typical path is C:\Documents and Settings\username\Templates.
  static String get Templates => '{A63293E8-664E-48DB-A079-DF759E0509F7}';

  /// The file system directory that serves as a common repository for video
  /// files. A typical path is C:\Documents and Settings\username\My
  /// Documents\My Videos.
  static String get Videos => '{18989B1D-99B5-455B-841C-AB7C74E4DDFC}';

  /// The Windows directory or SYSROOT. This corresponds to the %windir% or
  /// %SYSTEMROOT% environment variables. A typical path is C:\Windows.
  static String get Windows => '{F38BF404-1D43-42F2-9305-67DE0B28FC23}';
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\windows\flutter\ephemeral\.plugin_symlinks\path_provider_windows\lib\src\folders_stub.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// Stub version of the actual class.
class WindowsKnownFolder {}
.
===== D:\Computer Science\flutter project\stock_tracker_app\windows\flutter\ephemeral\.plugin_symlinks\path_provider_windows\lib\src\guid.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:ffi';
import 'dart:typed_data';

/// Representation of the Win32 GUID struct.
// For the layout of this struct, see
// https://learn.microsoft.com/windows/win32/api/guiddef/ns-guiddef-guid
@Packed(4)
base class GUID extends Struct {
  /// Native Data1 field.
  @Uint32()
  external int data1;

  /// Native Data2 field.
  @Uint16()
  external int data2;

  /// Native Data3 field.
  @Uint16()
  external int data3;

  /// Native Data4 field.
  // This should be an eight-element byte array, but there's no such annotation.
  @Uint64()
  external int data4;

  /// Parses a GUID string, with optional enclosing "{}"s and optional "-"s,
  /// into data.
  void parse(String guid) {
    final String hexOnly = guid.replaceAll(RegExp(r'[{}-]'), '');
    if (hexOnly.length != 32) {
      throw ArgumentError.value(guid, 'guid', 'Invalid GUID string');
    }
    final ByteData bytes = ByteData(16);
    for (int i = 0; i < 16; ++i) {
      bytes.setUint8(
          i, int.parse(hexOnly.substring(i * 2, i * 2 + 2), radix: 16));
    }
    data1 = bytes.getInt32(0);
    data2 = bytes.getInt16(4);
    data3 = bytes.getInt16(6);
    // [bytes] is big endian, but the host is little endian, so a default
    // big-endian read would reverse the bytes. Since data4 is supposed to be
    // a byte array, the order should be preserved, so do a little-endian read.
    // https://en.wikipedia.org/wiki/Universally_unique_identifier#Encoding
    data4 = bytes.getInt64(8, Endian.little);
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\windows\flutter\ephemeral\.plugin_symlinks\path_provider_windows\lib\src\path_provider_windows_real.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:ffi';
import 'dart:io';

import 'package:ffi/ffi.dart';
import 'package:flutter/foundation.dart' show visibleForTesting;
import 'package:flutter/services.dart';
import 'package:path/path.dart' as path;
import 'package:path_provider_platform_interface/path_provider_platform_interface.dart';

import 'folders.dart';
import 'guid.dart';
import 'win32_wrappers.dart';

/// Constant for en-US language used in VersionInfo keys.
@visibleForTesting
const String languageEn = '0409';

/// Constant for CP1252 encoding used in VersionInfo keys
@visibleForTesting
const String encodingCP1252 = '04e4';

/// Constant for Unicode encoding used in VersionInfo keys
@visibleForTesting
const String encodingUnicode = '04b0';

/// Wraps the Win32 VerQueryValue API call.
///
/// This class exists to allow injecting alternate metadata in tests without
/// building multiple custom test binaries.
@visibleForTesting
class VersionInfoQuerier {
  /// Returns the value for [key] in [versionInfo]s in section with given
  /// language and encoding, or null if there is no such entry,
  /// or if versionInfo is null.
  ///
  /// See https://docs.microsoft.com/windows/win32/menurc/versioninfo-resource
  /// for list of possible language and encoding values.
  String? getStringValue(
    Pointer<Uint8>? versionInfo,
    String key, {
    required String language,
    required String encoding,
  }) {
    assert(language.isNotEmpty);
    assert(encoding.isNotEmpty);
    if (versionInfo == null) {
      return null;
    }
    final Pointer<Utf16> keyPath =
        '\\StringFileInfo\\$language$encoding\\$key'.toNativeUtf16();
    final Pointer<UINT> length = calloc<UINT>();
    final Pointer<Pointer<Utf16>> valueAddress = calloc<Pointer<Utf16>>();
    try {
      if (VerQueryValue(versionInfo, keyPath, valueAddress, length) == 0) {
        return null;
      }
      return valueAddress.value.toDartString();
    } finally {
      calloc.free(keyPath);
      calloc.free(length);
      calloc.free(valueAddress);
    }
  }
}

/// The Windows implementation of [PathProviderPlatform]
///
/// This class implements the `package:path_provider` functionality for Windows.
class PathProviderWindows extends PathProviderPlatform {
  /// Registers the Windows implementation.
  static void registerWith() {
    PathProviderPlatform.instance = PathProviderWindows();
  }

  /// The object to use for performing VerQueryValue calls.
  @visibleForTesting
  VersionInfoQuerier versionInfoQuerier = VersionInfoQuerier();

  /// This is typically the same as the TMP environment variable.
  @override
  Future<String?> getTemporaryPath() async {
    final Pointer<Utf16> buffer = calloc<Uint16>(MAX_PATH + 1).cast<Utf16>();
    String path;

    try {
      final int length = GetTempPath(MAX_PATH, buffer);

      if (length == 0) {
        final int error = GetLastError();
        throw _createWin32Exception(error);
      } else {
        path = buffer.toDartString();

        // GetTempPath adds a trailing backslash, but SHGetKnownFolderPath does
        // not. Strip off trailing backslash for consistency with other methods
        // here.
        if (path.endsWith(r'\')) {
          path = path.substring(0, path.length - 1);
        }
      }

      // Ensure that the directory exists, since GetTempPath doesn't.
      final Directory directory = Directory(path);
      if (!directory.existsSync()) {
        await directory.create(recursive: true);
      }

      return path;
    } finally {
      calloc.free(buffer);
    }
  }

  @override
  Future<String?> getApplicationSupportPath() =>
      _createApplicationSubdirectory(WindowsKnownFolder.RoamingAppData);

  @override
  Future<String?> getApplicationDocumentsPath() =>
      getPath(WindowsKnownFolder.Documents);

  @override
  Future<String?> getApplicationCachePath() =>
      _createApplicationSubdirectory(WindowsKnownFolder.LocalAppData);

  @override
  Future<String?> getDownloadsPath() => getPath(WindowsKnownFolder.Downloads);

  /// Retrieve any known folder from Windows.
  ///
  /// folderID is a GUID that represents a specific known folder ID, drawn from
  /// [WindowsKnownFolder].
  Future<String?> getPath(String folderID) {
    final Pointer<Pointer<Utf16>> pathPtrPtr = calloc<Pointer<Utf16>>();
    final Pointer<GUID> knownFolderID = calloc<GUID>()..ref.parse(folderID);

    try {
      final int hr = SHGetKnownFolderPath(
        knownFolderID,
        KF_FLAG_DEFAULT,
        NULL,
        pathPtrPtr,
      );

      if (FAILED(hr)) {
        if (hr == E_INVALIDARG || hr == E_FAIL) {
          throw _createWin32Exception(hr);
        }
        return Future<String?>.value();
      }

      final String path = pathPtrPtr.value.toDartString();
      return Future<String>.value(path);
    } finally {
      calloc.free(pathPtrPtr);
      calloc.free(knownFolderID);
    }
  }

  String? _getStringValue(Pointer<Uint8>? infoBuffer, String key) =>
      versionInfoQuerier.getStringValue(infoBuffer, key,
          language: languageEn, encoding: encodingCP1252) ??
      versionInfoQuerier.getStringValue(infoBuffer, key,
          language: languageEn, encoding: encodingUnicode);

  /// Returns the relative path string to append to the root directory returned
  /// by Win32 APIs for application storage (such as RoamingAppDir) to get a
  /// directory that is unique to the application.
  ///
  /// The convention is to use company-name\product-name\. This will use that if
  /// possible, using the data in the VERSIONINFO resource, with the following
  /// fallbacks:
  /// - If the company name isn't there, that component will be dropped.
  /// - If the product name isn't there, it will use the exe's filename (without
  ///   extension).
  String _getApplicationSpecificSubdirectory() {
    String? companyName;
    String? productName;

    final Pointer<Utf16> moduleNameBuffer =
        calloc<WCHAR>(MAX_PATH + 1).cast<Utf16>();
    final Pointer<DWORD> unused = calloc<DWORD>();
    Pointer<BYTE>? infoBuffer;
    try {
      // Get the module name.
      final int moduleNameLength =
          GetModuleFileName(0, moduleNameBuffer, MAX_PATH);
      if (moduleNameLength == 0) {
        final int error = GetLastError();
        throw _createWin32Exception(error);
      }

      // From that, load the VERSIONINFO resource
      final int infoSize = GetFileVersionInfoSize(moduleNameBuffer, unused);
      if (infoSize != 0) {
        infoBuffer = calloc<BYTE>(infoSize);
        if (GetFileVersionInfo(moduleNameBuffer, 0, infoSize, infoBuffer) ==
            0) {
          calloc.free(infoBuffer);
          infoBuffer = null;
        }
      }
      companyName =
          _sanitizedDirectoryName(_getStringValue(infoBuffer, 'CompanyName'));
      productName =
          _sanitizedDirectoryName(_getStringValue(infoBuffer, 'ProductName'));

      // If there was no product name, use the executable name.
      productName ??=
          path.basenameWithoutExtension(moduleNameBuffer.toDartString());

      return companyName != null
          ? path.join(companyName, productName)
          : productName;
    } finally {
      calloc.free(moduleNameBuffer);
      calloc.free(unused);
      if (infoBuffer != null) {
        calloc.free(infoBuffer);
      }
    }
  }

  /// Makes [rawString] safe as a directory component. See
  /// https://docs.microsoft.com/windows/win32/fileio/naming-a-file#naming-conventions
  ///
  /// If after sanitizing the string is empty, returns null.
  String? _sanitizedDirectoryName(String? rawString) {
    if (rawString == null) {
      return null;
    }
    String sanitized = rawString
        // Replace banned characters.
        .replaceAll(RegExp(r'[<>:"/\\|?*]'), '_')
        // Remove trailing whitespace.
        .trimRight()
        // Ensure that it does not end with a '.'.
        .replaceAll(RegExp(r'[.]+$'), '');
    const int kMaxComponentLength = 255;
    if (sanitized.length > kMaxComponentLength) {
      sanitized = sanitized.substring(0, kMaxComponentLength);
    }
    return sanitized.isEmpty ? null : sanitized;
  }

  Future<String?> _createApplicationSubdirectory(String folderId) async {
    final String? baseDir = await getPath(folderId);
    if (baseDir == null) {
      return null;
    }
    final Directory directory =
        Directory(path.join(baseDir, _getApplicationSpecificSubdirectory()));
    // Ensure that the directory exists if possible, since it will on other
    // platforms. If the name is longer than MAXPATH, creating will fail, so
    // skip that step; it's up to the client to decide what to do with the path
    // in that case (e.g., using a short path).
    if (directory.path.length <= MAX_PATH) {
      if (!directory.existsSync()) {
        await directory.create(recursive: true);
      }
    }
    return directory.path;
  }
}

Exception _createWin32Exception(int errorCode) {
  return PlatformException(
      code: 'Win32 Error',
      // TODO(stuartmorgan): Consider getting the system error message via
      // FormatMessage if it turns out to be necessary for debugging issues.
      // Plugin-client-level usability isn't a major consideration since per
      // https://github.com/flutter/flutter/blob/master/docs/ecosystem/contributing/README.md#platform-exception-handling
      // any case that comes up in practice should be handled and returned
      // via a plugin-specific exception, not this fallback.
      message: 'Error code 0x${errorCode.toRadixString(16)}');
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\windows\flutter\ephemeral\.plugin_symlinks\path_provider_windows\lib\src\path_provider_windows_stub.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:path_provider_platform_interface/path_provider_platform_interface.dart';

/// A stub implementation to satisfy compilation of multi-platform packages that
/// depend on path_provider_windows. This should never actually be created.
///
/// Notably, because path_provider needs to manually register
/// path_provider_windows, anything with a transitive dependency on
/// path_provider will also depend on path_provider_windows, not just at the
/// pubspec level but the code level.
class PathProviderWindows extends PathProviderPlatform {
  /// Errors on attempted instantiation of the stub. It exists only to satisfy
  /// compile-time dependencies, and should never actually be created.
  PathProviderWindows() : assert(false);

  /// Registers the Windows implementation.
  static void registerWith() {
    PathProviderPlatform.instance = PathProviderWindows();
  }

  /// Stub; see comment on VersionInfoQuerier.
  VersionInfoQuerier versionInfoQuerier = VersionInfoQuerier();

  /// Match PathProviderWindows so that the analyzer won't report invalid
  /// overrides if tests provide fake PathProviderWindows implementations.
  Future<String> getPath(String folderID) async => '';
}

/// Stub to satisfy the analyzer, which doesn't seem to handle conditional
/// exports correctly.
class VersionInfoQuerier {}
.
===== D:\Computer Science\flutter project\stock_tracker_app\windows\flutter\ephemeral\.plugin_symlinks\path_provider_windows\lib\src\win32_wrappers.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// The types and functions here correspond directly to corresponding Windows
// types and functions, so the Windows docs are the definitive source of
// documentation.
// ignore_for_file: public_member_api_docs

import 'dart:ffi';

import 'package:ffi/ffi.dart';

import 'guid.dart';

typedef BOOL = Int32;
typedef BYTE = Uint8;
typedef DWORD = Uint32;
typedef UINT = Uint32;
typedef HANDLE = IntPtr;
typedef HMODULE = HANDLE;
typedef HRESULT = Int32;
typedef LPCVOID = Pointer<NativeType>;
typedef LPCWSTR = Pointer<Utf16>;
typedef LPDWORD = Pointer<DWORD>;
typedef LPWSTR = Pointer<Utf16>;
typedef LPVOID = Pointer<NativeType>;
typedef PUINT = Pointer<UINT>;
typedef PWSTR = Pointer<Pointer<Utf16>>;
typedef WCHAR = Uint16;

const int NULL = 0;

// https://learn.microsoft.com/windows/win32/fileio/maximum-file-path-limitation?tabs=registry
const int MAX_PATH = 260;

// https://learn.microsoft.com/windows/win32/seccrypto/common-hresult-values
// ignore: non_constant_identifier_names
final int E_FAIL = 0x80004005.toSigned(32);
// ignore: non_constant_identifier_names
final int E_INVALIDARG = 0x80070057.toSigned(32);

// https://learn.microsoft.com/windows/win32/api/winerror/nf-winerror-failed#remarks
// ignore: non_constant_identifier_names
bool FAILED(int hr) => hr < 0;

// https://learn.microsoft.com/windows/win32/api/shlobj_core/ne-shlobj_core-known_folder_flag
const int KF_FLAG_DEFAULT = 0x00000000;

final DynamicLibrary _dllKernel32 = DynamicLibrary.open('kernel32.dll');
final DynamicLibrary _dllVersion = DynamicLibrary.open('version.dll');
final DynamicLibrary _dllShell32 = DynamicLibrary.open('shell32.dll');

// https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shgetknownfolderpath
typedef _FFITypeSHGetKnownFolderPath = HRESULT Function(
    Pointer<GUID>, DWORD, HANDLE, PWSTR);
typedef FFITypeSHGetKnownFolderPathDart = int Function(
    Pointer<GUID>, int, int, Pointer<Pointer<Utf16>>);
// ignore: non_constant_identifier_names
final FFITypeSHGetKnownFolderPathDart SHGetKnownFolderPath =
    _dllShell32.lookupFunction<_FFITypeSHGetKnownFolderPath,
        FFITypeSHGetKnownFolderPathDart>('SHGetKnownFolderPath');

// https://learn.microsoft.com/windows/win32/api/winver/nf-winver-getfileversioninfow
typedef _FFITypeGetFileVersionInfoW = BOOL Function(
    LPCWSTR, DWORD, DWORD, LPVOID);
typedef FFITypeGetFileVersionInfoW = int Function(
    Pointer<Utf16>, int, int, Pointer<NativeType>);
// ignore: non_constant_identifier_names
final FFITypeGetFileVersionInfoW GetFileVersionInfo = _dllVersion
    .lookupFunction<_FFITypeGetFileVersionInfoW, FFITypeGetFileVersionInfoW>(
        'GetFileVersionInfoW');

// https://learn.microsoft.com/windows/win32/api/winver/nf-winver-getfileversioninfosizew
typedef _FFITypeGetFileVersionInfoSizeW = DWORD Function(LPCWSTR, LPDWORD);
typedef FFITypeGetFileVersionInfoSizeW = int Function(
    Pointer<Utf16>, Pointer<Uint32>);
// ignore: non_constant_identifier_names
final FFITypeGetFileVersionInfoSizeW GetFileVersionInfoSize =
    _dllVersion.lookupFunction<_FFITypeGetFileVersionInfoSizeW,
        FFITypeGetFileVersionInfoSizeW>('GetFileVersionInfoSizeW');

// https://learn.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror
typedef _FFITypeGetLastError = DWORD Function();
typedef FFITypeGetLastError = int Function();
// ignore: non_constant_identifier_names
final FFITypeGetLastError GetLastError = _dllKernel32
    .lookupFunction<_FFITypeGetLastError, FFITypeGetLastError>('GetLastError');

// https://learn.microsoft.com/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamew
typedef _FFITypeGetModuleFileNameW = DWORD Function(HMODULE, LPWSTR, DWORD);
typedef FFITypeGetModuleFileNameW = int Function(int, Pointer<Utf16>, int);
// ignore: non_constant_identifier_names
final FFITypeGetModuleFileNameW GetModuleFileName = _dllKernel32.lookupFunction<
    _FFITypeGetModuleFileNameW,
    FFITypeGetModuleFileNameW>('GetModuleFileNameW');

// https://learn.microsoft.com/windows/win32/api/winver/nf-winver-verqueryvaluew
typedef _FFITypeVerQueryValueW = BOOL Function(LPCVOID, LPCWSTR, LPVOID, PUINT);
typedef FFITypeVerQueryValueW = int Function(
    Pointer<NativeType>, Pointer<Utf16>, Pointer<NativeType>, Pointer<Uint32>);
// ignore: non_constant_identifier_names
final FFITypeVerQueryValueW VerQueryValue =
    _dllVersion.lookupFunction<_FFITypeVerQueryValueW, FFITypeVerQueryValueW>(
        'VerQueryValueW');

// https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-gettemppathw
typedef _FFITypeGetTempPathW = DWORD Function(DWORD, LPWSTR);
typedef FFITypeGetTempPathW = int Function(int, Pointer<Utf16>);
// ignore: non_constant_identifier_names
final FFITypeGetTempPathW GetTempPath = _dllKernel32
    .lookupFunction<_FFITypeGetTempPathW, FFITypeGetTempPathW>('GetTempPathW');
.
===== D:\Computer Science\flutter project\stock_tracker_app\windows\flutter\ephemeral\.plugin_symlinks\path_provider_windows\test\guid_test.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:ffi';
import 'dart:typed_data';

import 'package:ffi/ffi.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:path_provider_windows/src/guid.dart';

void main() {
  test('has correct byte representation', () async {
    final Pointer<GUID> guid = calloc<GUID>()
      ..ref.parse('{00112233-4455-6677-8899-aabbccddeeff}');
    final ByteData data = ByteData(16)
      ..setInt32(0, guid.ref.data1, Endian.little)
      ..setInt16(4, guid.ref.data2, Endian.little)
      ..setInt16(6, guid.ref.data3, Endian.little)
      ..setInt64(8, guid.ref.data4, Endian.little);
    expect(data.getUint8(0), 0x33);
    expect(data.getUint8(1), 0x22);
    expect(data.getUint8(2), 0x11);
    expect(data.getUint8(3), 0x00);
    expect(data.getUint8(4), 0x55);
    expect(data.getUint8(5), 0x44);
    expect(data.getUint8(6), 0x77);
    expect(data.getUint8(7), 0x66);
    expect(data.getUint8(8), 0x88);
    expect(data.getUint8(9), 0x99);
    expect(data.getUint8(10), 0xAA);
    expect(data.getUint8(11), 0xBB);
    expect(data.getUint8(12), 0xCC);
    expect(data.getUint8(13), 0xDD);
    expect(data.getUint8(14), 0xEE);
    expect(data.getUint8(15), 0xFF);

    calloc.free(guid);
  });

  test('handles alternate forms', () async {
    final Pointer<GUID> guid1 = calloc<GUID>()
      ..ref.parse('{00112233-4455-6677-8899-aabbccddeeff}');
    final Pointer<GUID> guid2 = calloc<GUID>()
      ..ref.parse('00112233445566778899AABBCCDDEEFF');

    expect(guid1.ref.data1, guid2.ref.data1);
    expect(guid1.ref.data2, guid2.ref.data2);
    expect(guid1.ref.data3, guid2.ref.data3);
    expect(guid1.ref.data4, guid2.ref.data4);

    calloc.free(guid1);
    calloc.free(guid2);
  });

  test('throws for bad data', () async {
    final Pointer<GUID> guid = calloc<GUID>();

    expect(() => guid.ref.parse('{00112233-4455-6677-88'), throwsArgumentError);

    calloc.free(guid);
  });
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\windows\flutter\ephemeral\.plugin_symlinks\path_provider_windows\test\path_provider_windows_test.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:ffi';
import 'dart:io';

import 'package:flutter_test/flutter_test.dart';
import 'package:path_provider_platform_interface/path_provider_platform_interface.dart';
import 'package:path_provider_windows/path_provider_windows.dart';
import 'package:path_provider_windows/src/path_provider_windows_real.dart'
    show encodingCP1252, encodingUnicode, languageEn;

// A fake VersionInfoQuerier that just returns preset responses.
class FakeVersionInfoQuerier implements VersionInfoQuerier {
  FakeVersionInfoQuerier(
    this.responses, {
    this.language = languageEn,
    this.encoding = encodingUnicode,
  });

  final String language;
  final String encoding;
  final Map<String, String> responses;

  // ignore: unreachable_from_main
  String? getStringValue(
    Pointer<Uint8>? versionInfo,
    String key, {
    required String language,
    required String encoding,
  }) {
    if (language == this.language && encoding == this.encoding) {
      return responses[key];
    } else {
      return null;
    }
  }
}

void main() {
  test('registered instance', () {
    PathProviderWindows.registerWith();
    expect(PathProviderPlatform.instance, isA<PathProviderWindows>());
  });

  test('getTemporaryPath', () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    expect(await pathProvider.getTemporaryPath(), contains(r'C:\'));
  }, skip: !Platform.isWindows);

  test('getApplicationSupportPath with no version info', () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    pathProvider.versionInfoQuerier =
        FakeVersionInfoQuerier(<String, String>{});
    final String? path = await pathProvider.getApplicationSupportPath();
    expect(path, contains(r'C:\'));
    expect(path, contains(r'AppData'));
    // The last path component should be the executable name.
    expect(path, endsWith(r'flutter_tester'));
  }, skip: !Platform.isWindows);

  test('getApplicationSupportPath with full version info in CP1252', () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    pathProvider.versionInfoQuerier = FakeVersionInfoQuerier(<String, String>{
      'CompanyName': 'A Company',
      'ProductName': 'Amazing App',
    }, encoding: encodingCP1252);
    final String? path = await pathProvider.getApplicationSupportPath();
    expect(path, isNotNull);
    if (path != null) {
      expect(path, endsWith(r'AppData\Roaming\A Company\Amazing App'));
      expect(Directory(path).existsSync(), isTrue);
    }
  }, skip: !Platform.isWindows);

  test('getApplicationSupportPath with full version info in Unicode', () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    pathProvider.versionInfoQuerier = FakeVersionInfoQuerier(<String, String>{
      'CompanyName': 'A Company',
      'ProductName': 'Amazing App',
    });
    final String? path = await pathProvider.getApplicationSupportPath();
    expect(path, isNotNull);
    if (path != null) {
      expect(path, endsWith(r'AppData\Roaming\A Company\Amazing App'));
      expect(Directory(path).existsSync(), isTrue);
    }
  }, skip: !Platform.isWindows);

  test(
      'getApplicationSupportPath with full version info in Unsupported Encoding',
      () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    pathProvider.versionInfoQuerier = FakeVersionInfoQuerier(<String, String>{
      'CompanyName': 'A Company',
      'ProductName': 'Amazing App',
    }, language: '0000', encoding: '0000');
    final String? path = await pathProvider.getApplicationSupportPath();
    expect(path, contains(r'C:\'));
    expect(path, contains(r'AppData'));
    // The last path component should be the executable name.
    expect(path, endsWith(r'flutter_tester'));
  }, skip: !Platform.isWindows);

  test('getApplicationSupportPath with missing company', () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    pathProvider.versionInfoQuerier = FakeVersionInfoQuerier(<String, String>{
      'ProductName': 'Amazing App',
    });
    final String? path = await pathProvider.getApplicationSupportPath();
    expect(path, isNotNull);
    if (path != null) {
      expect(path, endsWith(r'AppData\Roaming\Amazing App'));
      expect(Directory(path).existsSync(), isTrue);
    }
  }, skip: !Platform.isWindows);

  test('getApplicationSupportPath with problematic values', () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    pathProvider.versionInfoQuerier = FakeVersionInfoQuerier(<String, String>{
      'CompanyName': r'A <Bad> Company: Name.',
      'ProductName': r'A"/Terrible\|App?*Name',
    });
    final String? path = await pathProvider.getApplicationSupportPath();
    expect(path, isNotNull);
    if (path != null) {
      expect(
          path,
          endsWith(
              r'AppData\Roaming\A _Bad_ Company_ Name\A__Terrible__App__Name'));
      expect(Directory(path).existsSync(), isTrue);
    }
  }, skip: !Platform.isWindows);

  test('getApplicationSupportPath with a completely invalid company', () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    pathProvider.versionInfoQuerier = FakeVersionInfoQuerier(<String, String>{
      'CompanyName': r'..',
      'ProductName': r'Amazing App',
    });
    final String? path = await pathProvider.getApplicationSupportPath();
    expect(path, isNotNull);
    if (path != null) {
      expect(path, endsWith(r'AppData\Roaming\Amazing App'));
      expect(Directory(path).existsSync(), isTrue);
    }
  }, skip: !Platform.isWindows);

  test('getApplicationSupportPath with very long app name', () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    final String truncatedName = 'A' * 255;
    pathProvider.versionInfoQuerier = FakeVersionInfoQuerier(<String, String>{
      'CompanyName': 'A Company',
      'ProductName': truncatedName * 2,
    });
    final String? path = await pathProvider.getApplicationSupportPath();
    expect(path, endsWith('\\$truncatedName'));
    // The directory won't exist, since it's longer than MAXPATH, so don't check
    // that here.
  }, skip: !Platform.isWindows);

  test('getApplicationDocumentsPath', () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    final String? path = await pathProvider.getApplicationDocumentsPath();
    expect(path, contains(r'C:\'));
    expect(path, contains(r'Documents'));
  }, skip: !Platform.isWindows);

  test('getApplicationCachePath', () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    pathProvider.versionInfoQuerier = FakeVersionInfoQuerier(<String, String>{
      'CompanyName': 'A Company',
      'ProductName': 'Amazing App',
    }, encoding: encodingCP1252);
    final String? path = await pathProvider.getApplicationCachePath();
    expect(path, isNotNull);
    if (path != null) {
      expect(path, endsWith(r'AppData\Local\A Company\Amazing App'));
      expect(Directory(path).existsSync(), isTrue);
    }
  }, skip: !Platform.isWindows);

  test('getDownloadsPath', () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    final String? path = await pathProvider.getDownloadsPath();
    expect(path, contains(r'C:\'));
    expect(path, contains(r'Downloads'));
  }, skip: !Platform.isWindows);
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\windows\flutter\ephemeral\.plugin_symlinks\shared_preferences_windows\example\integration_test\shared_preferences_test.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:shared_preferences_platform_interface/shared_preferences_async_platform_interface.dart';
import 'package:shared_preferences_platform_interface/types.dart';
import 'package:shared_preferences_windows/shared_preferences_windows.dart';

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  group('SharedPreferencesWindows', () {
    late SharedPreferencesWindows preferences;

    const Map<String, Object> flutterTestValues = <String, Object>{
      'flutter.String': 'hello world',
      'flutter.Bool': true,
      'flutter.Int': 42,
      'flutter.Double': 3.14159,
      'flutter.StringList': <String>['foo', 'bar'],
    };

    const Map<String, Object> prefixTestValues = <String, Object>{
      'prefix.String': 'hello world',
      'prefix.Bool': true,
      'prefix.Int': 42,
      'prefix.Double': 3.14159,
      'prefix.StringList': <String>['foo', 'bar'],
    };

    const Map<String, Object> nonPrefixTestValues = <String, Object>{
      'String': 'hello world',
      'Bool': true,
      'Int': 42,
      'Double': 3.14159,
      'StringList': <String>['foo', 'bar'],
    };

    final Map<String, Object> allTestValues = <String, Object>{};

    allTestValues.addAll(flutterTestValues);
    allTestValues.addAll(prefixTestValues);
    allTestValues.addAll(nonPrefixTestValues);

    Future<void> addData() async {
      await preferences.setValue('String', 'String', allTestValues['String']!);
      await preferences.setValue('Bool', 'Bool', allTestValues['Bool']!);
      await preferences.setValue('Int', 'Int', allTestValues['Int']!);
      await preferences.setValue('Double', 'Double', allTestValues['Double']!);
      await preferences.setValue(
          'StringList', 'StringList', allTestValues['StringList']!);
      await preferences.setValue(
          'String', 'prefix.String', allTestValues['prefix.String']!);
      await preferences.setValue(
          'Bool', 'prefix.Bool', allTestValues['prefix.Bool']!);
      await preferences.setValue(
          'Int', 'prefix.Int', allTestValues['prefix.Int']!);
      await preferences.setValue(
          'Double', 'prefix.Double', allTestValues['prefix.Double']!);
      await preferences.setValue('StringList', 'prefix.StringList',
          allTestValues['prefix.StringList']!);
      await preferences.setValue(
          'String', 'flutter.String', allTestValues['flutter.String']!);
      await preferences.setValue(
          'Bool', 'flutter.Bool', allTestValues['flutter.Bool']!);
      await preferences.setValue(
          'Int', 'flutter.Int', allTestValues['flutter.Int']!);
      await preferences.setValue(
          'Double', 'flutter.Double', allTestValues['flutter.Double']!);
      await preferences.setValue('StringList', 'flutter.StringList',
          allTestValues['flutter.StringList']!);
    }

    setUp(() async {
      preferences = SharedPreferencesWindows();
      await addData();
    });

    tearDown(() async {
      await preferences.clearWithParameters(
        ClearParameters(
          filter: PreferencesFilter(prefix: ''),
        ),
      );
    });

    testWidgets('getAll', (WidgetTester _) async {
      final Map<String, Object> values = await preferences.getAll();
      expect(values['flutter.String'], allTestValues['flutter.String']);
      expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
      expect(values['flutter.Int'], allTestValues['flutter.Int']);
      expect(values['flutter.Double'], allTestValues['flutter.Double']);
      expect(values['flutter.StringList'], allTestValues['flutter.StringList']);
    });

    group('withPrefix', () {
      testWidgets('remove', (WidgetTester _) async {
        const String key = 'flutter.String';
        await preferences.remove(key);
        final Map<String, Object> values =
            await preferences.getAllWithPrefix('');
        expect(values[key], isNull);
      });

      testWidgets('clear', (WidgetTester _) async {
        await preferences.clear();
        final Map<String, Object> values = await preferences.getAll();
        expect(values['flutter.String'], null);
        expect(values['flutter.Bool'], null);
        expect(values['flutter.Int'], null);
        expect(values['flutter.Double'], null);
        expect(values['flutter.StringList'], null);
      });

      testWidgets('get all with prefix', (WidgetTester _) async {
        final Map<String, Object> values =
            await preferences.getAllWithPrefix('prefix.');
        expect(values['prefix.String'], allTestValues['prefix.String']);
        expect(values['prefix.Bool'], allTestValues['prefix.Bool']);
        expect(values['prefix.Int'], allTestValues['prefix.Int']);
        expect(values['prefix.Double'], allTestValues['prefix.Double']);
        expect(values['prefix.StringList'], allTestValues['prefix.StringList']);
      });

      testWidgets('getAllWithNoPrefix', (WidgetTester _) async {
        final Map<String, Object> values =
            await preferences.getAllWithPrefix('');
        expect(values['String'], allTestValues['String']);
        expect(values['Bool'], allTestValues['Bool']);
        expect(values['Int'], allTestValues['Int']);
        expect(values['Double'], allTestValues['Double']);
        expect(values['StringList'], allTestValues['StringList']);
        expect(values['flutter.String'], allTestValues['flutter.String']);
        expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
        expect(values['flutter.Int'], allTestValues['flutter.Int']);
        expect(values['flutter.Double'], allTestValues['flutter.Double']);
        expect(
            values['flutter.StringList'], allTestValues['flutter.StringList']);
      });

      testWidgets('clearWithPrefix', (WidgetTester _) async {
        await preferences.clearWithPrefix('prefix.');
        Map<String, Object> values =
            await preferences.getAllWithPrefix('prefix.');
        expect(values['prefix.String'], null);
        expect(values['prefix.Bool'], null);
        expect(values['prefix.Int'], null);
        expect(values['prefix.Double'], null);
        expect(values['prefix.StringList'], null);
        values = await preferences.getAllWithPrefix('flutter.');
        expect(values['flutter.String'], allTestValues['flutter.String']);
        expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
        expect(values['flutter.Int'], allTestValues['flutter.Int']);
        expect(values['flutter.Double'], allTestValues['flutter.Double']);
        expect(
            values['flutter.StringList'], allTestValues['flutter.StringList']);
      });

      testWidgets('clearWithNoPrefix', (WidgetTester _) async {
        await preferences.clearWithPrefix('');
        final Map<String, Object> values =
            await preferences.getAllWithPrefix('');
        expect(values['String'], null);
        expect(values['Bool'], null);
        expect(values['Int'], null);
        expect(values['Double'], null);
        expect(values['StringList'], null);
        expect(values['flutter.String'], null);
        expect(values['flutter.Bool'], null);
        expect(values['flutter.Int'], null);
        expect(values['flutter.Double'], null);
        expect(values['flutter.StringList'], null);
      });
    });

    group('withParameters', () {
      testWidgets('remove', (WidgetTester _) async {
        const String key = 'flutter.String';
        await preferences.remove(key);
        final Map<String, Object> values =
            await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: ''),
          ),
        );
        expect(values[key], isNull);
      });

      testWidgets('clear', (WidgetTester _) async {
        await preferences.clear();
        final Map<String, Object> values = await preferences.getAll();
        expect(values['flutter.String'], null);
        expect(values['flutter.Bool'], null);
        expect(values['flutter.Int'], null);
        expect(values['flutter.Double'], null);
        expect(values['flutter.StringList'], null);
      });

      testWidgets('get all with prefix', (WidgetTester _) async {
        final Map<String, Object> values =
            await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: 'prefix.'),
          ),
        );
        expect(values['prefix.String'], allTestValues['prefix.String']);
        expect(values['prefix.Bool'], allTestValues['prefix.Bool']);
        expect(values['prefix.Int'], allTestValues['prefix.Int']);
        expect(values['prefix.Double'], allTestValues['prefix.Double']);
        expect(values['prefix.StringList'], allTestValues['prefix.StringList']);
      });

      testWidgets('get all with allow list', (WidgetTester _) async {
        final Map<String, Object> values =
            await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(
              prefix: 'prefix.',
              allowList: <String>{'prefix.String'},
            ),
          ),
        );
        expect(values['prefix.String'], allTestValues['prefix.String']);
        expect(values['prefix.Bool'], null);
        expect(values['prefix.Int'], null);
        expect(values['prefix.Double'], null);
        expect(values['prefix.StringList'], null);
      });

      testWidgets('getAllWithNoPrefix', (WidgetTester _) async {
        final Map<String, Object> values =
            await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: ''),
          ),
        );
        expect(values['String'], allTestValues['String']);
        expect(values['Bool'], allTestValues['Bool']);
        expect(values['Int'], allTestValues['Int']);
        expect(values['Double'], allTestValues['Double']);
        expect(values['StringList'], allTestValues['StringList']);
        expect(values['flutter.String'], allTestValues['flutter.String']);
        expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
        expect(values['flutter.Int'], allTestValues['flutter.Int']);
        expect(values['flutter.Double'], allTestValues['flutter.Double']);
        expect(
            values['flutter.StringList'], allTestValues['flutter.StringList']);
      });

      testWidgets('clearWithParameters', (WidgetTester _) async {
        await preferences.clearWithParameters(
          ClearParameters(
            filter: PreferencesFilter(prefix: 'prefix.'),
          ),
        );
        Map<String, Object> values = await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: 'prefix.'),
          ),
        );
        expect(values['prefix.String'], null);
        expect(values['prefix.Bool'], null);
        expect(values['prefix.Int'], null);
        expect(values['prefix.Double'], null);
        expect(values['prefix.StringList'], null);
        values = await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: 'flutter.'),
          ),
        );
        expect(values['flutter.String'], allTestValues['flutter.String']);
        expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
        expect(values['flutter.Int'], allTestValues['flutter.Int']);
        expect(values['flutter.Double'], allTestValues['flutter.Double']);
        expect(
            values['flutter.StringList'], allTestValues['flutter.StringList']);
      });

      testWidgets('clearWithParameters with allow list',
          (WidgetTester _) async {
        await addData();
        await preferences.clearWithParameters(
          ClearParameters(
            filter: PreferencesFilter(
              prefix: 'prefix.',
              allowList: <String>{'prefix.StringList'},
            ),
          ),
        );
        Map<String, Object> values = await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: 'prefix.'),
          ),
        );
        expect(values['prefix.String'], allTestValues['prefix.String']);
        expect(values['prefix.Bool'], allTestValues['prefix.Bool']);
        expect(values['prefix.Int'], allTestValues['prefix.Int']);
        expect(values['prefix.Double'], allTestValues['prefix.Double']);
        expect(values['prefix.StringList'], null);
        values = await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: 'flutter.'),
          ),
        );
        expect(values['flutter.String'], allTestValues['flutter.String']);
        expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
        expect(values['flutter.Int'], allTestValues['flutter.Int']);
        expect(values['flutter.Double'], allTestValues['flutter.Double']);
        expect(
            values['flutter.StringList'], allTestValues['flutter.StringList']);
      });

      testWidgets('clearWithNoPrefix', (WidgetTester _) async {
        await preferences.clearWithParameters(
          ClearParameters(
            filter: PreferencesFilter(prefix: ''),
          ),
        );
        final Map<String, Object> values =
            await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: ''),
          ),
        );
        expect(values['String'], null);
        expect(values['Bool'], null);
        expect(values['Int'], null);
        expect(values['Double'], null);
        expect(values['StringList'], null);
        expect(values['flutter.String'], null);
        expect(values['flutter.Bool'], null);
        expect(values['flutter.Int'], null);
        expect(values['flutter.Double'], null);
        expect(values['flutter.StringList'], null);
      });
    });
  });

  group('shared_preferences_async', () {
    const SharedPreferencesWindowsOptions emptyOptions =
        SharedPreferencesWindowsOptions();

    const String stringKey = 'testString';
    const String boolKey = 'testBool';
    const String intKey = 'testInt';
    const String doubleKey = 'testDouble';
    const String listKey = 'testList';

    const String testString = 'hello world';
    const bool testBool = true;
    const int testInt = 42;
    const double testDouble = 3.14159;
    const List<String> testList = <String>['foo', 'bar'];

    Future<SharedPreferencesAsyncPlatform> getPreferences(
        {bool clear = true}) async {
      final SharedPreferencesAsyncPlatform preferences =
          SharedPreferencesAsyncPlatform.instance!;
      if (clear) {
        await preferences.clear(
            const ClearPreferencesParameters(filter: PreferencesFilters()),
            emptyOptions);
      }
      return preferences;
    }

    testWidgets('set and get String', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setString(stringKey, testString, emptyOptions);
      expect(await preferences.getString(stringKey, emptyOptions), testString);
    });

    testWidgets('set and get bool', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setBool(boolKey, testBool, emptyOptions);
      expect(await preferences.getBool(boolKey, emptyOptions), testBool);
    });

    testWidgets('set and get int', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setInt(intKey, testInt, emptyOptions);
      expect(await preferences.getInt(intKey, emptyOptions), testInt);
    });

    testWidgets('set and get double', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setDouble(doubleKey, testDouble, emptyOptions);
      expect(await preferences.getDouble(doubleKey, emptyOptions), testDouble);
    });

    testWidgets('set and get StringList', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setStringList(listKey, testList, emptyOptions);
      expect(await preferences.getStringList(listKey, emptyOptions), testList);
    });

    testWidgets('getStringList does not throw cast error',
        (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setStringList(listKey, testList, emptyOptions);
      await (preferences as SharedPreferencesAsyncWindows).reload(emptyOptions);
      expect(await preferences.getStringList(listKey, emptyOptions), testList);
    });

    testWidgets('getStringList returns mutable list', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setStringList(listKey, testList, emptyOptions);
      final List<String>? list =
          await preferences.getStringList(listKey, emptyOptions);
      list?.add('value');
      expect(list?.length, testList.length + 1);
    });

    testWidgets('getPreferences', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await preferences.setString(stringKey, testString, emptyOptions);
      await preferences.setBool(boolKey, testBool, emptyOptions);
      await preferences.setInt(intKey, testInt, emptyOptions);
      await preferences.setDouble(doubleKey, testDouble, emptyOptions);
      await preferences.setStringList(listKey, testList, emptyOptions);

      final Map<String, Object?> gotAll = await preferences.getPreferences(
        const GetPreferencesParameters(filter: PreferencesFilters()),
        emptyOptions,
      );

      expect(gotAll.length, 5);
      expect(gotAll[stringKey], testString);
      expect(gotAll[boolKey], testBool);
      expect(gotAll[intKey], testInt);
      expect(gotAll[doubleKey], testDouble);
      expect(gotAll[listKey], testList);
    });

    testWidgets('getPreferences with filter', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await preferences.setString(stringKey, testString, emptyOptions);
      await preferences.setBool(boolKey, testBool, emptyOptions);
      await preferences.setInt(intKey, testInt, emptyOptions);
      await preferences.setDouble(doubleKey, testDouble, emptyOptions);
      await preferences.setStringList(listKey, testList, emptyOptions);

      final Map<String, Object?> gotAll = await preferences.getPreferences(
        const GetPreferencesParameters(
          filter: PreferencesFilters(allowList: <String>{stringKey, boolKey}),
        ),
        emptyOptions,
      );

      expect(gotAll.length, 2);
      expect(gotAll[stringKey], testString);
      expect(gotAll[boolKey], testBool);
    });

    testWidgets('getKeys', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await preferences.setString(stringKey, testString, emptyOptions);
      await preferences.setBool(boolKey, testBool, emptyOptions);
      await preferences.setInt(intKey, testInt, emptyOptions);
      await preferences.setDouble(doubleKey, testDouble, emptyOptions);
      await preferences.setStringList(listKey, testList, emptyOptions);

      final Set<String> keys = await preferences.getKeys(
        const GetPreferencesParameters(filter: PreferencesFilters()),
        emptyOptions,
      );

      expect(keys.length, 5);
      expect(keys, contains(stringKey));
      expect(keys, contains(boolKey));
      expect(keys, contains(intKey));
      expect(keys, contains(doubleKey));
      expect(keys, contains(listKey));
    });

    testWidgets('getKeys with filter', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await preferences.setString(stringKey, testString, emptyOptions);
      await preferences.setBool(boolKey, testBool, emptyOptions);
      await preferences.setInt(intKey, testInt, emptyOptions);
      await preferences.setDouble(doubleKey, testDouble, emptyOptions);
      await preferences.setStringList(listKey, testList, emptyOptions);

      final Set<String> keys = await preferences.getKeys(
        const GetPreferencesParameters(
          filter: PreferencesFilters(allowList: <String>{stringKey, boolKey}),
        ),
        emptyOptions,
      );

      expect(keys.length, 2);
      expect(keys, contains(stringKey));
      expect(keys, contains(boolKey));
    });

    testWidgets('clear', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await preferences.setString(stringKey, testString, emptyOptions);
      await preferences.setBool(boolKey, testBool, emptyOptions);
      await preferences.setInt(intKey, testInt, emptyOptions);
      await preferences.setDouble(doubleKey, testDouble, emptyOptions);
      await preferences.setStringList(listKey, testList, emptyOptions);

      await preferences.clear(
        const ClearPreferencesParameters(filter: PreferencesFilters()),
        emptyOptions,
      );

      expect(await preferences.getString(stringKey, emptyOptions), null);
      expect(await preferences.getBool(boolKey, emptyOptions), null);
      expect(await preferences.getInt(intKey, emptyOptions), null);
      expect(await preferences.getDouble(doubleKey, emptyOptions), null);
      expect(await preferences.getStringList(listKey, emptyOptions), null);
    });

    testWidgets('clear with filter', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await preferences.setString(stringKey, testString, emptyOptions);
      await preferences.setBool(boolKey, testBool, emptyOptions);
      await preferences.setInt(intKey, testInt, emptyOptions);
      await preferences.setDouble(doubleKey, testDouble, emptyOptions);
      await preferences.setStringList(listKey, testList, emptyOptions);
      await preferences.clear(
        const ClearPreferencesParameters(
          filter: PreferencesFilters(allowList: <String>{stringKey, boolKey}),
        ),
        emptyOptions,
      );
      expect(await preferences.getString(stringKey, emptyOptions), null);
      expect(await preferences.getBool(boolKey, emptyOptions), null);
      expect(await preferences.getInt(intKey, emptyOptions), testInt);
      expect(await preferences.getDouble(doubleKey, emptyOptions), testDouble);
      expect(await preferences.getStringList(listKey, emptyOptions), testList);
    });
  });
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\windows\flutter\ephemeral\.plugin_symlinks\shared_preferences_windows\example\lib\main.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// ignore_for_file: public_member_api_docs

import 'package:flutter/material.dart';
import 'package:shared_preferences_platform_interface/shared_preferences_async_platform_interface.dart';
import 'package:shared_preferences_windows/shared_preferences_windows.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return const MaterialApp(
      title: 'SharedPreferences Demo',
      home: SharedPreferencesDemo(),
    );
  }
}

class SharedPreferencesDemo extends StatefulWidget {
  const SharedPreferencesDemo({super.key});

  @override
  SharedPreferencesDemoState createState() => SharedPreferencesDemoState();
}

class SharedPreferencesDemoState extends State<SharedPreferencesDemo> {
  final SharedPreferencesAsyncPlatform? _prefs =
      SharedPreferencesAsyncPlatform.instance;
  final SharedPreferencesWindowsOptions options =
      const SharedPreferencesWindowsOptions();
  static const String _counterKey = 'counter';
  late Future<int> _counter;

  Future<void> _incrementCounter() async {
    final int? value = await _prefs!.getInt(_counterKey, options);
    final int counter = (value ?? 0) + 1;

    setState(() {
      _counter = _prefs.setInt(_counterKey, counter, options).then((_) {
        return counter;
      });
    });
  }

  Future<void> _getAndSetCounter() async {
    setState(() {
      _counter = _prefs!.getInt(_counterKey, options).then((int? counter) {
        return counter ?? 0;
      });
    });
  }

  @override
  void initState() {
    super.initState();
    _getAndSetCounter();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('SharedPreferences Demo'),
      ),
      body: Center(
          child: FutureBuilder<int>(
              future: _counter,
              builder: (BuildContext context, AsyncSnapshot<int> snapshot) {
                switch (snapshot.connectionState) {
                  case ConnectionState.none:
                  case ConnectionState.waiting:
                    return const CircularProgressIndicator();
                  case ConnectionState.active:
                  case ConnectionState.done:
                    if (snapshot.hasError) {
                      return Text('Error: ${snapshot.error}');
                    } else {
                      return Text(
                        'Button tapped ${snapshot.data} time${snapshot.data == 1 ? '' : 's'}.\n\n'
                        'This should persist across restarts.',
                      );
                    }
                }
              })),
      floatingActionButton: FloatingActionButton(
        onPressed: _incrementCounter,
        tooltip: 'Increment',
        child: const Icon(Icons.add),
      ),
    );
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\windows\flutter\ephemeral\.plugin_symlinks\shared_preferences_windows\example\test_driver\integration_test.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:integration_test/integration_test_driver.dart';

Future<void> main() => integrationDriver();
.
===== D:\Computer Science\flutter project\stock_tracker_app\windows\flutter\ephemeral\.plugin_symlinks\shared_preferences_windows\lib\shared_preferences_windows.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:async';
import 'dart:convert' show json;

import 'package:file/file.dart';
import 'package:file/local.dart';
import 'package:flutter/foundation.dart' show debugPrint, visibleForTesting;
import 'package:path/path.dart' as path;
import 'package:path_provider_windows/path_provider_windows.dart';
import 'package:shared_preferences_platform_interface/shared_preferences_async_platform_interface.dart';
import 'package:shared_preferences_platform_interface/shared_preferences_platform_interface.dart';
import 'package:shared_preferences_platform_interface/types.dart';

const String _defaultFileName = 'shared_preferences';

const String _defaultPrefix = 'flutter.';

/// The Windows implementation of [SharedPreferencesStorePlatform].
///
/// This class implements the `package:shared_preferences` functionality for Windows.
class SharedPreferencesWindows extends SharedPreferencesStorePlatform {
  /// Deprecated instance of [SharedPreferencesWindows].
  /// Use [SharedPreferencesStorePlatform.instance] instead.
  @Deprecated('Use `SharedPreferencesStorePlatform.instance` instead.')
  static SharedPreferencesWindows instance = SharedPreferencesWindows();

  /// Registers the Windows implementation.
  static void registerWith() {
    SharedPreferencesStorePlatform.instance = SharedPreferencesWindows();
    // A temporary work-around for having two plugins contained in a single package.
    SharedPreferencesAsyncWindows.registerWith();
  }

  /// Local copy of preferences
  Map<String, Object>? _cachedPreferences;

  /// File system used to store to disk. Exposed for testing only.
  @visibleForTesting
  FileSystem fs = const LocalFileSystem();

  /// The path_provider_windows instance used to find the support directory.
  @visibleForTesting
  PathProviderWindows pathProvider = PathProviderWindows();

  /// Checks for cached preferences and returns them or loads preferences from
  /// file and returns and caches them.
  Future<Map<String, Object>> _readPreferences() async {
    _cachedPreferences ??= await _readFromFile(
      _defaultFileName,
      fs: fs,
      pathProvider: pathProvider,
    );
    return _cachedPreferences!;
  }

  @override
  Future<bool> clear() async {
    return clearWithParameters(
      ClearParameters(
        filter: PreferencesFilter(prefix: _defaultPrefix),
      ),
    );
  }

  @override
  Future<bool> clearWithPrefix(String prefix) async {
    return clearWithParameters(
        ClearParameters(filter: PreferencesFilter(prefix: prefix)));
  }

  @override
  Future<bool> clearWithParameters(ClearParameters parameters) async {
    final PreferencesFilter filter = parameters.filter;

    final Map<String, Object> preferences = await _readPreferences();
    preferences.removeWhere((String key, _) =>
        key.startsWith(filter.prefix) &&
        (filter.allowList == null || filter.allowList!.contains(key)));
    return _writePreferences(
      preferences,
      _defaultFileName,
      fs: fs,
      pathProvider: pathProvider,
    );
  }

  @override
  Future<Map<String, Object>> getAll() async {
    return getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: _defaultPrefix),
      ),
    );
  }

  @override
  Future<Map<String, Object>> getAllWithPrefix(String prefix) async {
    return getAllWithParameters(
        GetAllParameters(filter: PreferencesFilter(prefix: prefix)));
  }

  @override
  Future<Map<String, Object>> getAllWithParameters(
      GetAllParameters parameters) async {
    final PreferencesFilter filter = parameters.filter;
    final Map<String, Object> withPrefix =
        Map<String, Object>.from(await _readPreferences());
    withPrefix.removeWhere((String key, _) => !(key.startsWith(filter.prefix) &&
        (filter.allowList?.contains(key) ?? true)));
    return withPrefix;
  }

  @override
  Future<bool> remove(String key) async {
    final Map<String, Object> preferences = await _readPreferences();
    preferences.remove(key);
    return _writePreferences(
      preferences,
      _defaultFileName,
      fs: fs,
      pathProvider: pathProvider,
    );
  }

  @override
  Future<bool> setValue(String valueType, String key, Object value) async {
    final Map<String, Object> preferences = await _readPreferences();
    preferences[key] = value;
    return _writePreferences(
      preferences,
      _defaultFileName,
      fs: fs,
      pathProvider: pathProvider,
    );
  }
}

/// The Windows implementation of [SharedPreferencesAsyncPlatform].
///
/// This class implements the `package:shared_preferences` functionality for Windows.
base class SharedPreferencesAsyncWindows
    extends SharedPreferencesAsyncPlatform {
  /// Registers the Windows implementation.
  static void registerWith() {
    SharedPreferencesAsyncPlatform.instance = SharedPreferencesAsyncWindows();
  }

  /// Local copy of preferences
  Map<String, Object>? _cachedPreferences;

  /// File system used to store to disk. Exposed for testing only.
  @visibleForTesting
  FileSystem fs = const LocalFileSystem();

  /// The path_provider_windows instance used to find the support directory.
  @visibleForTesting
  PathProviderWindows pathProvider = PathProviderWindows();

  @override
  Future<Set<String>> getKeys(
    GetPreferencesParameters parameters,
    SharedPreferencesOptions options,
  ) async {
    return (await getPreferences(parameters, options)).keys.toSet();
  }

  @override
  Future<void> setString(
    String key,
    String value,
    SharedPreferencesOptions options,
  ) {
    return _setValue(key, value, options);
  }

  @override
  Future<void> setBool(
    String key,
    bool value,
    SharedPreferencesOptions options,
  ) {
    return _setValue(key, value, options);
  }

  @override
  Future<void> setDouble(
    String key,
    double value,
    SharedPreferencesOptions options,
  ) {
    return _setValue(key, value, options);
  }

  @override
  Future<void> setInt(
    String key,
    int value,
    SharedPreferencesOptions options,
  ) {
    return _setValue(key, value, options);
  }

  @override
  Future<void> setStringList(
    String key,
    List<String> value,
    SharedPreferencesOptions options,
  ) {
    return _setValue(key, value, options);
  }

  @override
  Future<String?> getString(
    String key,
    SharedPreferencesOptions options,
  ) async {
    final Map<String, Object> data = await _readAll(<String>{key}, options);
    return data[key] as String?;
  }

  @override
  Future<bool?> getBool(
    String key,
    SharedPreferencesOptions options,
  ) async {
    final Map<String, Object> data = await _readAll(<String>{key}, options);
    return data[key] as bool?;
  }

  @override
  Future<double?> getDouble(
    String key,
    SharedPreferencesOptions options,
  ) async {
    final Map<String, Object> data = await _readAll(<String>{key}, options);
    return data[key] as double?;
  }

  @override
  Future<int?> getInt(
    String key,
    SharedPreferencesOptions options,
  ) async {
    final Map<String, Object> data = await _readAll(<String>{key}, options);
    return data[key] as int?;
  }

  @override
  Future<List<String>?> getStringList(
    String key,
    SharedPreferencesOptions options,
  ) async {
    final Map<String, Object> data = await _readAll(<String>{key}, options);
    return (data[key] as List<Object?>?)?.cast<String>().toList();
  }

  @override
  Future<void> clear(ClearPreferencesParameters parameters,
      SharedPreferencesOptions options) async {
    final SharedPreferencesWindowsOptions windowsOptions =
        SharedPreferencesWindowsOptions.fromSharedPreferencesOptions(options);
    final PreferencesFilters filter = parameters.filter;
    final Map<String, Object> preferences =
        await _readPreferences(windowsOptions.fileName);
    preferences.removeWhere((String key, _) =>
        filter.allowList == null || filter.allowList!.contains(key));
    await _writePreferences(
      preferences,
      windowsOptions.fileName,
      fs: fs,
      pathProvider: pathProvider,
    );
  }

  @override
  Future<Map<String, Object>> getPreferences(
    GetPreferencesParameters parameters,
    SharedPreferencesOptions options,
  ) async {
    return _readAll(parameters.filter.allowList, options);
  }

  /// Reloads preferences from file.
  @visibleForTesting
  Future<void> reload(
    SharedPreferencesWindowsOptions options,
  ) async {
    _cachedPreferences = await _readFromFile(options.fileName);
  }

  Future<Map<String, Object>> _readAll(
    Set<String>? allowList,
    SharedPreferencesOptions options,
  ) async {
    final SharedPreferencesWindowsOptions windowsOptions =
        SharedPreferencesWindowsOptions.fromSharedPreferencesOptions(options);
    final Map<String, Object> prefs = Map<String, Object>.from(
        await _readPreferences(windowsOptions.fileName));
    prefs.removeWhere((String key, _) => !(allowList?.contains(key) ?? true));
    return prefs;
  }

  Future<void> _setValue(
      String key, Object value, SharedPreferencesOptions options) async {
    final SharedPreferencesWindowsOptions windowsOptions =
        SharedPreferencesWindowsOptions.fromSharedPreferencesOptions(options);
    final Map<String, Object> preferences =
        await _readPreferences(windowsOptions.fileName);
    preferences[key] = value;
    await _writePreferences(
      preferences,
      windowsOptions.fileName,
      fs: fs,
      pathProvider: pathProvider,
    );
  }

  /// Checks for cached preferences and returns them or loads preferences from
  /// file and returns and caches them.
  Future<Map<String, Object>> _readPreferences(String fileName) async {
    _cachedPreferences ??= await _readFromFile(
      fileName,
      fs: fs,
      pathProvider: pathProvider,
    );
    return _cachedPreferences!;
  }
}

/// Gets the file where the preferences are stored.
Future<File?> _getLocalDataFile(
  String fileName, {
  FileSystem fs = const LocalFileSystem(),
  PathProviderWindows? pathProvider,
}) async {
  pathProvider = pathProvider ?? PathProviderWindows();
  final String? directory = await pathProvider.getApplicationSupportPath();
  if (directory == null) {
    return null;
  }
  final String fileLocation = path.join(directory, '$fileName.json');
  return fs.file(fileLocation);
}

/// Gets the preferences from the stored file.
Future<Map<String, Object>> _readFromFile(
  String fileName, {
  FileSystem fs = const LocalFileSystem(),
  PathProviderWindows? pathProvider,
}) async {
  Map<String, Object> preferences = <String, Object>{};
  final File? localDataFile = await _getLocalDataFile(
    fileName,
    fs: fs,
    pathProvider: pathProvider,
  );
  if (localDataFile != null && localDataFile.existsSync()) {
    final String stringMap = localDataFile.readAsStringSync();
    if (stringMap.isNotEmpty) {
      final Object? data = json.decode(stringMap);
      if (data is Map) {
        preferences = data.cast<String, Object>();
      }
    }
  }
  return preferences;
}

/// Writes the cached preferences to disk. Returns [true] if the operation
/// succeeded.
Future<bool> _writePreferences(
  Map<String, Object> preferences,
  String fileName, {
  FileSystem fs = const LocalFileSystem(),
  PathProviderWindows? pathProvider,
}) async {
  try {
    final File? localDataFile = await _getLocalDataFile(
      fileName,
      fs: fs,
      pathProvider: pathProvider,
    );
    if (localDataFile == null) {
      debugPrint('Unable to determine where to write preferences.');
      return false;
    }
    if (!localDataFile.existsSync()) {
      localDataFile.createSync(recursive: true);
    }
    final String stringMap = json.encode(preferences);
    localDataFile.writeAsStringSync(stringMap);
  } catch (e) {
    debugPrint('Error saving preferences to disk: $e');
    return false;
  }
  return true;
}

/// Windows specific SharedPreferences Options.
class SharedPreferencesWindowsOptions extends SharedPreferencesOptions {
  /// Constructor for SharedPreferencesWindowsOptions.
  const SharedPreferencesWindowsOptions({
    this.fileName = 'shared_preferences', // Same as current defaults.
  });

  /// The name of the file to store preferences in.
  final String fileName;

  /// Returns a new instance of [SharedPreferencesWindowsOptions] from an existing
  /// [SharedPreferencesOptions].
  static SharedPreferencesWindowsOptions fromSharedPreferencesOptions(
      SharedPreferencesOptions options) {
    if (options is SharedPreferencesWindowsOptions) {
      return options;
    }
    return const SharedPreferencesWindowsOptions();
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\windows\flutter\ephemeral\.plugin_symlinks\shared_preferences_windows\test\fake_path_provider_windows.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter_test/flutter_test.dart';
import 'package:path_provider_platform_interface/path_provider_platform_interface.dart';
import 'package:path_provider_windows/path_provider_windows.dart';

/// Fake implementation of PathProviderWindows that returns hard-coded paths,
/// allowing tests to run on any platform.
///
/// Note that this should only be used with an in-memory filesystem, as the
/// path it returns is a root path that does not actually exist on Windows.
class FakePathProviderWindows extends PathProviderPlatform
    implements PathProviderWindows {
  @override
  late VersionInfoQuerier versionInfoQuerier;

  @override
  Future<String?> getApplicationSupportPath() async => r'C:\appsupport';

  @override
  Future<String?> getTemporaryPath() async => null;

  @override
  Future<String?> getLibraryPath() async => null;

  @override
  Future<String?> getApplicationDocumentsPath() async => null;

  @override
  Future<String?> getDownloadsPath() async => null;

  @override
  Future<String> getPath(String folderID) async => '';
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\windows\flutter\ephemeral\.plugin_symlinks\shared_preferences_windows\test\legacy_shared_preferences_windows_test.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:convert';

import 'package:file/memory.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:path/path.dart' as path;
import 'package:path_provider_windows/path_provider_windows.dart';
import 'package:shared_preferences_platform_interface/shared_preferences_platform_interface.dart';
import 'package:shared_preferences_platform_interface/types.dart';
import 'package:shared_preferences_windows/shared_preferences_windows.dart';

import 'fake_path_provider_windows.dart';

void main() {
  late MemoryFileSystem fs;
  late PathProviderWindows pathProvider;

  SharedPreferencesWindows.registerWith();

  const Map<String, Object> flutterTestValues = <String, Object>{
    'flutter.String': 'hello world',
    'flutter.Bool': true,
    'flutter.Int': 42,
    'flutter.Double': 3.14159,
    'flutter.StringList': <String>['foo', 'bar'],
  };

  const Map<String, Object> prefixTestValues = <String, Object>{
    'prefix.String': 'hello world',
    'prefix.Bool': true,
    'prefix.Int': 42,
    'prefix.Double': 3.14159,
    'prefix.StringList': <String>['foo', 'bar'],
  };

  const Map<String, Object> nonPrefixTestValues = <String, Object>{
    'String': 'hello world',
    'Bool': true,
    'Int': 42,
    'Double': 3.14159,
    'StringList': <String>['foo', 'bar'],
  };

  final Map<String, Object> allTestValues = <String, Object>{};

  allTestValues.addAll(flutterTestValues);
  allTestValues.addAll(prefixTestValues);
  allTestValues.addAll(nonPrefixTestValues);

  setUp(() {
    fs = MemoryFileSystem.test();
    pathProvider = FakePathProviderWindows();
  });

  Future<String> getFilePath() async {
    final String? directory = await pathProvider.getApplicationSupportPath();
    return path.join(directory!, 'shared_preferences.json');
  }

  Future<void> writeTestFile(String value) async {
    fs.file(await getFilePath())
      ..createSync(recursive: true)
      ..writeAsStringSync(value);
  }

  Future<String> readTestFile() async {
    return fs.file(await getFilePath()).readAsStringSync();
  }

  SharedPreferencesWindows getPreferences() {
    final SharedPreferencesWindows prefs = SharedPreferencesWindows();
    prefs.fs = fs;
    prefs.pathProvider = pathProvider;
    return prefs;
  }

  test('registered instance', () async {
    SharedPreferencesWindows.registerWith();
    expect(SharedPreferencesStorePlatform.instance,
        isA<SharedPreferencesWindows>());
  });

  test('getAll', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesWindows prefs = getPreferences();

    final Map<String, Object> values = await prefs.getAll();
    expect(values, hasLength(5));
    expect(values, flutterTestValues);
  });

  test('getAllWithPrefix', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesWindows prefs = getPreferences();

    final Map<String, Object> values = await prefs.getAllWithPrefix('prefix.');
    expect(values, hasLength(5));
    expect(values, prefixTestValues);
  });

  test('getAllWithParameters with Prefix', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesWindows prefs = getPreferences();

    final Map<String, Object> values = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: 'prefix.'),
      ),
    );
    expect(values, hasLength(5));
    expect(values, prefixTestValues);
  });

  test('getAllWithParameters with Prefix with allow list', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesWindows prefs = getPreferences();

    final Map<String?, Object?> all = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(
          prefix: 'prefix.',
          allowList: <String>{'prefix.Bool'},
        ),
      ),
    );
    expect(all.length, 1);
    expect(all['prefix.Bool'], prefixTestValues['prefix.Bool']);
  });

  test('remove', () async {
    await writeTestFile('{"key1":"one","key2":2}');
    final SharedPreferencesWindows prefs = getPreferences();

    await prefs.remove('key2');

    expect(await readTestFile(), '{"key1":"one"}');
  });

  test('setValue', () async {
    await writeTestFile('{}');
    final SharedPreferencesWindows prefs = getPreferences();

    await prefs.setValue('', 'key1', 'one');
    await prefs.setValue('', 'key2', 2);

    expect(await readTestFile(), '{"key1":"one","key2":2}');
  });

  test('clear', () async {
    await writeTestFile(json.encode(flutterTestValues));
    final SharedPreferencesWindows prefs = getPreferences();

    expect(await readTestFile(), json.encode(flutterTestValues));
    await prefs.clear();
    expect(await readTestFile(), '{}');
  });

  test('clearWithPrefix', () async {
    await writeTestFile(json.encode(flutterTestValues));
    final SharedPreferencesWindows prefs = getPreferences();
    await prefs.clearWithPrefix('prefix.');
    final Map<String, Object> noValues =
        await prefs.getAllWithPrefix('prefix.');
    expect(noValues, hasLength(0));

    final Map<String, Object> values = await prefs.getAll();
    expect(values, hasLength(5));
    expect(values, flutterTestValues);
  });

  test('getAllWithNoPrefix', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesWindows prefs = getPreferences();

    final Map<String, Object> values = await prefs.getAllWithPrefix('');
    expect(values, hasLength(15));
    expect(values, allTestValues);
  });

  test('clearWithNoPrefix', () async {
    await writeTestFile(json.encode(flutterTestValues));
    final SharedPreferencesWindows prefs = getPreferences();
    await prefs.clearWithPrefix('');
    final Map<String, Object> noValues = await prefs.getAllWithPrefix('');
    expect(noValues, hasLength(0));
  });

  test('clearWithParameters with Prefix', () async {
    await writeTestFile(json.encode(flutterTestValues));
    final SharedPreferencesWindows prefs = getPreferences();
    await prefs.clearWithParameters(
      ClearParameters(
        filter: PreferencesFilter(prefix: 'prefix.'),
      ),
    );
    final Map<String, Object> noValues = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: 'prefix.'),
      ),
    );
    expect(noValues, hasLength(0));

    final Map<String, Object> values = await prefs.getAll();
    expect(values, hasLength(5));
    expect(values, flutterTestValues);
  });

  test('clearWithParameters with allow list', () async {
    await writeTestFile(json.encode(prefixTestValues));
    final SharedPreferencesWindows prefs = getPreferences();
    await prefs.clearWithParameters(
      ClearParameters(
        filter: PreferencesFilter(
          prefix: 'prefix.',
          allowList: <String>{'prefix.StringList'},
        ),
      ),
    );
    final Map<String, Object> noValues = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: 'prefix.'),
      ),
    );
    expect(noValues, hasLength(4));
  });

  test('getAllWithNoPrefix', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesWindows prefs = getPreferences();

    final Map<String, Object> values = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: ''),
      ),
    );
    expect(values, hasLength(15));
    expect(values, allTestValues);
  });

  test('clearWithNoPrefix', () async {
    await writeTestFile(json.encode(flutterTestValues));
    final SharedPreferencesWindows prefs = getPreferences();
    await prefs.clearWithParameters(
      ClearParameters(
        filter: PreferencesFilter(prefix: ''),
      ),
    );
    final Map<String, Object> noValues = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: ''),
      ),
    );
    expect(noValues, hasLength(0));
  });
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\windows\flutter\ephemeral\.plugin_symlinks\shared_preferences_windows\test\shared_preferences_windows_async_test.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file/memory.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:path_provider_windows/path_provider_windows.dart';
import 'package:shared_preferences_platform_interface/types.dart';
import 'package:shared_preferences_windows/shared_preferences_windows.dart';

import 'fake_path_provider_windows.dart';

void main() {
  late MemoryFileSystem fs;
  late PathProviderWindows pathProvider;

  SharedPreferencesAsyncWindows.registerWith();

  const String stringKey = 'testString';
  const String boolKey = 'testBool';
  const String intKey = 'testInt';
  const String doubleKey = 'testDouble';
  const String listKey = 'testList';

  const String testString = 'hello world';
  const bool testBool = true;
  const int testInt = 42;
  const double testDouble = 3.14159;
  const List<String> testList = <String>['foo', 'bar'];

  const SharedPreferencesWindowsOptions emptyOptions =
      SharedPreferencesWindowsOptions();

  setUp(() {
    fs = MemoryFileSystem.test();
    pathProvider = FakePathProviderWindows();
  });

  SharedPreferencesAsyncWindows getPreferences() {
    final SharedPreferencesAsyncWindows prefs = SharedPreferencesAsyncWindows();
    prefs.fs = fs;
    prefs.pathProvider = pathProvider;
    return prefs;
  }

  test('set and get String', () async {
    final SharedPreferencesAsyncWindows preferences = getPreferences();

    await preferences.setString(stringKey, testString, emptyOptions);
    expect(await preferences.getString(stringKey, emptyOptions), testString);
  });

  test('set and get bool', () async {
    final SharedPreferencesAsyncWindows preferences = getPreferences();

    await preferences.setBool(boolKey, testBool, emptyOptions);
    expect(await preferences.getBool(boolKey, emptyOptions), testBool);
  });

  test('set and get int', () async {
    final SharedPreferencesAsyncWindows preferences = getPreferences();

    await preferences.setInt(intKey, testInt, emptyOptions);
    expect(await preferences.getInt(intKey, emptyOptions), testInt);
  });

  test('set and get double', () async {
    final SharedPreferencesAsyncWindows preferences = getPreferences();

    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    expect(await preferences.getDouble(doubleKey, emptyOptions), testDouble);
  });

  test('set and get StringList', () async {
    final SharedPreferencesAsyncWindows preferences = getPreferences();

    await preferences.setStringList(listKey, testList, emptyOptions);
    expect(await preferences.getStringList(listKey, emptyOptions), testList);
  });

  test('getPreferences', () async {
    final SharedPreferencesAsyncWindows preferences = getPreferences();
    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);

    final Map<String, Object?> gotAll = await preferences.getPreferences(
        const GetPreferencesParameters(filter: PreferencesFilters()),
        emptyOptions);

    expect(gotAll.length, 5);
    expect(gotAll[stringKey], testString);
    expect(gotAll[boolKey], testBool);
    expect(gotAll[intKey], testInt);
    expect(gotAll[doubleKey], testDouble);
    expect(gotAll[listKey], testList);
  });

  test('getPreferences with filter', () async {
    final SharedPreferencesAsyncWindows preferences = getPreferences();
    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);

    final Map<String, Object?> gotAll = await preferences.getPreferences(
        const GetPreferencesParameters(
            filter:
                PreferencesFilters(allowList: <String>{stringKey, boolKey})),
        emptyOptions);

    expect(gotAll.length, 2);
    expect(gotAll[stringKey], testString);
    expect(gotAll[boolKey], testBool);
  });

  test('getKeys', () async {
    final SharedPreferencesAsyncWindows preferences = getPreferences();
    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);

    final Set<String> keys = await preferences.getKeys(
      const GetPreferencesParameters(filter: PreferencesFilters()),
      emptyOptions,
    );

    expect(keys.length, 5);
    expect(keys, contains(stringKey));
    expect(keys, contains(boolKey));
    expect(keys, contains(intKey));
    expect(keys, contains(doubleKey));
    expect(keys, contains(listKey));
  });

  test('getKeys with filter', () async {
    final SharedPreferencesAsyncWindows preferences = getPreferences();
    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);

    final Set<String> keys = await preferences.getKeys(
      const GetPreferencesParameters(
        filter: PreferencesFilters(allowList: <String>{stringKey, boolKey}),
      ),
      emptyOptions,
    );

    expect(keys.length, 2);
    expect(keys, contains(stringKey));
    expect(keys, contains(boolKey));
  });

  test('clear', () async {
    final SharedPreferencesAsyncWindows preferences = getPreferences();
    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);
    await preferences.clear(
        const ClearPreferencesParameters(filter: PreferencesFilters()),
        emptyOptions);
    expect(await preferences.getString(stringKey, emptyOptions), null);
    expect(await preferences.getBool(boolKey, emptyOptions), null);
    expect(await preferences.getInt(intKey, emptyOptions), null);
    expect(await preferences.getDouble(doubleKey, emptyOptions), null);
    expect(await preferences.getStringList(listKey, emptyOptions), null);
  });

  test('clear with filter', () async {
    final SharedPreferencesAsyncWindows preferences = getPreferences();
    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);
    await preferences.clear(
      const ClearPreferencesParameters(
        filter: PreferencesFilters(allowList: <String>{stringKey, boolKey}),
      ),
      emptyOptions,
    );
    expect(await preferences.getString(stringKey, emptyOptions), null);
    expect(await preferences.getBool(boolKey, emptyOptions), null);
    expect(await preferences.getInt(intKey, emptyOptions), testInt);
    expect(await preferences.getDouble(doubleKey, emptyOptions), testDouble);
    expect(await preferences.getStringList(listKey, emptyOptions), testList);
  });
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\windows\flutter\ephemeral\.plugin_symlinks\url_launcher_windows\example\integration_test\url_launcher_test.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:url_launcher_platform_interface/url_launcher_platform_interface.dart';

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  testWidgets('canLaunch', (WidgetTester _) async {
    final UrlLauncherPlatform launcher = UrlLauncherPlatform.instance;

    expect(await launcher.canLaunch('randomstring'), false);

    // Generally all devices should have some default browser.
    expect(await launcher.canLaunch('http://flutter.dev'), true);
  });
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\windows\flutter\ephemeral\.plugin_symlinks\url_launcher_windows\example\lib\main.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// ignore_for_file: public_member_api_docs

import 'dart:async';
import 'package:flutter/material.dart';
import 'package:url_launcher_platform_interface/url_launcher_platform_interface.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'URL Launcher',
      theme: ThemeData(
        primarySwatch: Colors.blue,
      ),
      home: const MyHomePage(title: 'URL Launcher'),
    );
  }
}

class MyHomePage extends StatefulWidget {
  const MyHomePage({super.key, required this.title});
  final String title;

  @override
  State<MyHomePage> createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> {
  Future<void>? _launched;

  Future<void> _launchInBrowser(String url) async {
    if (await UrlLauncherPlatform.instance.canLaunch(url)) {
      await UrlLauncherPlatform.instance.launch(
        url,
        useSafariVC: false,
        useWebView: false,
        enableJavaScript: false,
        enableDomStorage: false,
        universalLinksOnly: false,
        headers: <String, String>{},
      );
    } else {
      throw Exception('Could not launch $url');
    }
  }

  Widget _launchStatus(BuildContext context, AsyncSnapshot<void> snapshot) {
    if (snapshot.hasError) {
      return Text('Error: ${snapshot.error}');
    } else {
      return const Text('');
    }
  }

  @override
  Widget build(BuildContext context) {
    const String toLaunch = 'https://www.cylog.org/headers/';
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.title),
      ),
      body: ListView(
        children: <Widget>[
          Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: <Widget>[
              const Padding(
                padding: EdgeInsets.all(16.0),
                child: Text(toLaunch),
              ),
              ElevatedButton(
                onPressed: () => setState(() {
                  _launched = _launchInBrowser(toLaunch);
                }),
                child: const Text('Launch in browser'),
              ),
              const Padding(padding: EdgeInsets.all(16.0)),
              FutureBuilder<void>(future: _launched, builder: _launchStatus),
            ],
          ),
        ],
      ),
    );
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\windows\flutter\ephemeral\.plugin_symlinks\url_launcher_windows\example\test_driver\integration_test.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:integration_test/integration_test_driver.dart';

Future<void> main() => integrationDriver();
.
===== D:\Computer Science\flutter project\stock_tracker_app\windows\flutter\ephemeral\.plugin_symlinks\url_launcher_windows\lib\url_launcher_windows.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter/foundation.dart';
import 'package:url_launcher_platform_interface/link.dart';
import 'package:url_launcher_platform_interface/url_launcher_platform_interface.dart';

import 'src/messages.g.dart';

/// An implementation of [UrlLauncherPlatform] for Windows.
class UrlLauncherWindows extends UrlLauncherPlatform {
  /// Creates a new plugin implementation instance.
  UrlLauncherWindows({
    @visibleForTesting UrlLauncherApi? api,
  }) : _hostApi = api ?? UrlLauncherApi();

  final UrlLauncherApi _hostApi;

  /// Registers this class as the default instance of [UrlLauncherPlatform].
  static void registerWith() {
    UrlLauncherPlatform.instance = UrlLauncherWindows();
  }

  @override
  final LinkDelegate? linkDelegate = null;

  @override
  Future<bool> canLaunch(String url) {
    return _hostApi.canLaunchUrl(url);
  }

  @override
  Future<bool> launch(
    String url, {
    required bool useSafariVC,
    required bool useWebView,
    required bool enableJavaScript,
    required bool enableDomStorage,
    required bool universalLinksOnly,
    required Map<String, String> headers,
    String? webOnlyWindowName,
  }) async {
    return _hostApi.launchUrl(url);
  }

  @override
  Future<bool> supportsMode(PreferredLaunchMode mode) async {
    return mode == PreferredLaunchMode.platformDefault ||
        mode == PreferredLaunchMode.externalApplication;
  }

  @override
  Future<bool> supportsCloseForMode(PreferredLaunchMode mode) async {
    // No supported mode is closeable.
    return false;
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\windows\flutter\ephemeral\.plugin_symlinks\url_launcher_windows\lib\src\messages.g.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Autogenerated from Pigeon (v21.0.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import, no_leading_underscores_for_local_identifiers

import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

PlatformException _createConnectionError(String channelName) {
  return PlatformException(
    code: 'channel-error',
    message: 'Unable to establish connection on channel: "$channelName".',
  );
}

class _PigeonCodec extends StandardMessageCodec {
  const _PigeonCodec();
}

class UrlLauncherApi {
  /// Constructor for [UrlLauncherApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  UrlLauncherApi(
      {BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : __pigeon_binaryMessenger = binaryMessenger,
        __pigeon_messageChannelSuffix =
            messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? __pigeon_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();

  final String __pigeon_messageChannelSuffix;

  Future<bool> canLaunchUrl(String url) async {
    final String __pigeon_channelName =
        'dev.flutter.pigeon.url_launcher_windows.UrlLauncherApi.canLaunchUrl$__pigeon_messageChannelSuffix';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[url]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as bool?)!;
    }
  }

  Future<bool> launchUrl(String url) async {
    final String __pigeon_channelName =
        'dev.flutter.pigeon.url_launcher_windows.UrlLauncherApi.launchUrl$__pigeon_messageChannelSuffix';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[url]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as bool?)!;
    }
  }
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\windows\flutter\ephemeral\.plugin_symlinks\url_launcher_windows\pigeons\messages.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:pigeon/pigeon.dart';

@ConfigurePigeon(PigeonOptions(
  dartOut: 'lib/src/messages.g.dart',
  cppOptions: CppOptions(namespace: 'url_launcher_windows'),
  cppHeaderOut: 'windows/messages.g.h',
  cppSourceOut: 'windows/messages.g.cpp',
  copyrightHeader: 'pigeons/copyright.txt',
))
@HostApi(dartHostTestHandler: 'TestUrlLauncherApi')
abstract class UrlLauncherApi {
  bool canLaunchUrl(String url);
  bool launchUrl(String url);
}
.
===== D:\Computer Science\flutter project\stock_tracker_app\windows\flutter\ephemeral\.plugin_symlinks\url_launcher_windows\test\url_launcher_windows_test.dart ===== 
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter/services.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:url_launcher_platform_interface/url_launcher_platform_interface.dart';
import 'package:url_launcher_windows/src/messages.g.dart';
import 'package:url_launcher_windows/url_launcher_windows.dart';

void main() {
  late _FakeUrlLauncherApi api;
  late UrlLauncherWindows plugin;

  setUp(() {
    api = _FakeUrlLauncherApi();
    plugin = UrlLauncherWindows(api: api);
  });

  test('registers instance', () {
    UrlLauncherWindows.registerWith();
    expect(UrlLauncherPlatform.instance, isA<UrlLauncherWindows>());
  });

  group('canLaunch', () {
    test('handles true', () async {
      api.canLaunch = true;

      final bool result = await plugin.canLaunch('http://example.com/');

      expect(result, isTrue);
      expect(api.argument, 'http://example.com/');
    });

    test('handles false', () async {
      api.canLaunch = false;

      final bool result = await plugin.canLaunch('http://example.com/');

      expect(result, isFalse);
      expect(api.argument, 'http://example.com/');
    });
  });

  group('launch', () {
    test('handles success', () async {
      api.canLaunch = true;

      expect(
          await plugin.launch(
            'http://example.com/',
            useSafariVC: true,
            useWebView: false,
            enableJavaScript: false,
            enableDomStorage: false,
            universalLinksOnly: false,
            headers: const <String, String>{},
          ),
          true);
      expect(api.argument, 'http://example.com/');
    });

    test('handles failure', () async {
      api.canLaunch = false;

      expect(
          await plugin.launch(
            'http://example.com/',
            useSafariVC: true,
            useWebView: false,
            enableJavaScript: false,
            enableDomStorage: false,
            universalLinksOnly: false,
            headers: const <String, String>{},
          ),
          false);
      expect(api.argument, 'http://example.com/');
    });

    test('handles errors', () async {
      api.throwError = true;

      await expectLater(
          plugin.launch(
            'http://example.com/',
            useSafariVC: true,
            useWebView: false,
            enableJavaScript: false,
            enableDomStorage: false,
            universalLinksOnly: false,
            headers: const <String, String>{},
          ),
          throwsA(isA<PlatformException>()));
      expect(api.argument, 'http://example.com/');
    });
  });

  group('supportsMode', () {
    test('returns true for platformDefault', () async {
      final UrlLauncherWindows launcher = UrlLauncherWindows(api: api);
      expect(await launcher.supportsMode(PreferredLaunchMode.platformDefault),
          true);
    });

    test('returns true for external application', () async {
      final UrlLauncherWindows launcher = UrlLauncherWindows(api: api);
      expect(
          await launcher.supportsMode(PreferredLaunchMode.externalApplication),
          true);
    });

    test('returns false for other modes', () async {
      final UrlLauncherWindows launcher = UrlLauncherWindows(api: api);
      expect(
          await launcher
              .supportsMode(PreferredLaunchMode.externalNonBrowserApplication),
          false);
      expect(await launcher.supportsMode(PreferredLaunchMode.inAppBrowserView),
          false);
      expect(
          await launcher.supportsMode(PreferredLaunchMode.inAppWebView), false);
    });
  });

  test('supportsCloseForMode returns false', () async {
    final UrlLauncherWindows launcher = UrlLauncherWindows(api: api);
    expect(
        await launcher
            .supportsCloseForMode(PreferredLaunchMode.platformDefault),
        false);
    expect(
        await launcher
            .supportsCloseForMode(PreferredLaunchMode.externalApplication),
        false);
  });
}

class _FakeUrlLauncherApi implements UrlLauncherApi {
  /// The argument that was passed to an API call.
  String? argument;

  /// Controls the behavior of the fake canLaunch implementations.
  ///
  /// - [canLaunchUrl] returns this value.
  /// - [launchUrl] returns this value if [throwError] is false.
  bool canLaunch = false;

  /// Whether to throw a platform exception.
  bool throwError = false;

  @override
  Future<bool> canLaunchUrl(String url) async {
    argument = url;
    return canLaunch;
  }

  @override
  Future<bool> launchUrl(String url) async {
    argument = url;
    if (throwError) {
      throw PlatformException(code: 'Failed');
    }
    return canLaunch;
  }
}
.
